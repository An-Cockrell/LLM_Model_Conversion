{
      "0": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: acos \n\nEntry Data: acos\nusage: abs number \n Reports the absolute value of number. show abs -7 => 7 show abs 5 => 5"
      ],
      "1": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: acos \n\nEntry Data: acos\nusage: acos number \n Reports the arc cosine (inverse cosine) of the given number. The input must be in the range -1 to 1. The result is in degrees, and lies in the range 0 to 180."
      ],
      "2": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: all \n\nEntry Data: all\nusage: all? agentset [reporter] \n Reports true if all of the agents in the agentset report true for the given reporter. Otherwise reports false as soon as a counterexample is found. If the agentset is empty, reports true. The reporter must report a boolean value for every agent (either true or false), otherwise an error occurs. if all? turtles [color = red] [ show \"every turtle is red!\" ] See also any?."
      ],
      "3": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: and \n\nEntry Data: and\nusage: boolean1 and boolean2 \n Reports true if both boolean1 and boolean2 are true. Otherwise reports false. Note that if boolean1 is false, then boolean2 will not be run (since it can't affect the result). See the programming guide for more information on logical operator precedence. if (pxcor > 0) and (pycor > 0) [ set pcolor blue ] ;; the upper-right quadrant of ;; patches turn blue"
      ],
      "4": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: any \n\nEntry Data: any\nusage: any? agentset \n Reports true if the given agentset is non-empty, false otherwise. Equivalent to \"count agentset > 0\", but more efficient (and arguably more readable). if any? turtles with [color = red] [ show \"at least one turtle is red!\" ] Note: nobody is not an agentset. You only get nobody back in situations where you were expecting a single agent, not a whole agentset. If any? gets nobody as input, an error results. See also all?, nobody."
      ],
      "5": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: approximate-hsb \n\nEntry Data: approximate-hsb\nusage: approximate-hsb hue saturation brightness \n Reports a number in the range 0 to 140, not including 140 itself, that represents the given color, specified in the HSB spectrum, in NetLogo's color space. The first value (hue) should be in the range of 0 to 360, the second and third (saturation and brightness) in the range between 0 and 100. The color reported may be only an approximation, since the NetLogo color space does not include all possible colors. show approximate-hsb 0 0 0 => 0 ;; (black) show approximate-hsb 180 57.143 76.863 => 85 ;; (cyan) See also extract-hsb, approximate-rgb, extract-rgb."
      ],
      "6": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: approximate-rgb \n\nEntry Data: approximate-rgb\nusage: approximate-rgb red green blue \n Reports a number in the range 0 to 140, not including 140 itself, that represents the given color, specified in the RGB spectrum, in NetLogo's color space. All three inputs should be in the range 0 to 255. The color reported may be only an approximation, since the NetLogo color space does not include all possible colors. show approximate-rgb 0 0 0 => 0 ;; black show approximate-rgb 0 255 255 => 85.2 ;; cyan See also extract-rgb, approximate-hsb, and extract-hsb."
      ],
      "7": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: Symbols \n\nEntry Data: Symbols\nArithmetic Operators +1.0 EXAMPLE OVER NOW*1.0 EXAMPLE OVER NOW-1.0 EXAMPLE OVER NOW/1.0 EXAMPLE OVER NOW^1.0 EXAMPLE OVER NOW<1.0 EXAMPLE OVER NOW>1.0 EXAMPLE OVER NOW=1.0 EXAMPLE OVER NOW!=1.0 EXAMPLE OVER NOW<=1.0 EXAMPLE OVER NOW>=1.0 EXAMPLE OVER NOW All of these operators take two inputs, and all act as \"infix operators\" (going between the two inputs, as in standard mathematical use). NetLogo correctly supports order of operations for infix operators. The operators work as follows: + is addition, * is multiplication, - is subtraction, / is division, ^ is exponentiation, < is less than, > is greater than, = is equal to, != is not equal to, <= is less than or equal, >= is greater than or equal. Note that the subtraction operator (-) always takes two inputs unless you put parentheses around it, in which case it can take one input. For example, to take the negative of x, write (- x), with the parentheses. All of the comparison operators also work on strings. All of the comparison operators work on agents. Turtles are compared by who number. Patches are compared top to bottom left to right, so patch 0 10 is less than patch 0 9 and patch 9 0 is less than patch 10 0. Links are ordered by end points and in case of a tie by breed. So link 0 9 is before link 1 10 as the end1 is smaller, and link 0 8 is less than link 0 9. If there are multiple breeds of links unbreeded links will come before breeded links of the same end points and breeded links will be sorted in the order they are declared in the Code tab. Agentsets can be tested for equality or inequality. Two agentsets are equal if they are the same type (turtle or patch or link) and contain the same agents. If you are not sure how NetLogo will interpret your code, you should add parentheses. show 5 * 6 + 6 / 3 => 32 show 5 * (6 + 6) / 3 => 20 Many extension objects may be tested for equality and inequality using = and !=. For instance, the array, matrix, and table objects returned by their respective extensions may be compared for equality / inequality. Extension objects may not be tested using <, >, <=, or >=."
      ],
      "8": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: asin \n\nEntry Data: asin\nusage: asin number \n Reports the arc sine (inverse sine) of the given number. The input must be in the range -1 to 1. The result is in degrees, and lies in the range -90 to 90."
      ],
      "9": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: ask \n\nEntry Data: ask\nusage: [('class', 'prim_example')]ask agent [commands] \n The specified agent or agentset runs the given commands. Because agentset members are always read in a random order, when ask is used with an agentset each agent will take its turn in a random order. See Agentsets for more information. ask turtles [ fd 1 ] ;; all turtles move forward one step ask patches [ set pcolor red ] ;; all patches turn red ask turtle 4 [ rt 90 ] ;; only the turtle with id 4 turns right Note: only the observer can ask all turtles or all patches. This prevents you from inadvertently having all turtles ask all turtles or all patches ask all patches, which is a common mistake to make if you're not careful about which agents will run the code you are writing. Note: Only the agents that are in the agentset at the time the ask begins run the commands."
      ],
      "10": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: ask-concurrent \n\nEntry Data: ask-concurrent\nusage: ask-concurrent agentset [commands] \n This primitive exists only for backwards compatibility. We don't recommend using it new models. The agents in the given agentset run the given commands, using a turn-taking mechanism to produce simulated concurrency. See the Ask-Concurrent section of the Programming Guide for details on how this works. Note: Only the agents that are in the agentset at the time the ask begins run the commands. See also without-interruption."
      ],
      "11": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: at-points \n\nEntry Data: at-points\nusage: agentset at-points [[x1 y1] [x2 y2] ...] \n Reports a subset of the given agentset that includes only the agents on the patches at the given coordinates (relative to this agent). The coordinates are specified as a list of two-item lists, where the two items are the x and y offsets. If the caller is the observer, then the points are measured relative to the origin, in other words, the points are taken as absolute patch coordinates. If the caller is a turtle, the points are measured relative to the turtle's exact location, and not from the center of the patch under the turtle. ask turtles at-points [[2 4] [1 2] [10 15]] [ fd 1 ] ;; only the turtles on the patches at the ;; coordinates (2,4), (1,2) and (10,15), ;; relative to the caller, move"
      ],
      "12": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: atan \n\nEntry Data: atan\nusage: atan x y \n Converts x and y offsets to a turtle heading in degrees (from 0 to 360). Note that this version of atan is designed to conform to the geometry of the NetLogo world, where a heading of 0 is straight up, 90 is to the right, and so on clockwise around the circle. (Normally in geometry an angle of 0 is right, 90 is up, and so on, counterclockwise around the circle, and atan would be defined accordingly.) When y is 0: if x is positive, it reports 90; if x is negative, it reports 270; if x is zero, you get an error. show atan 1 -1 => 135 show atan -1 1 => 315 crt 1 [ set heading 30 fd 1 print atan xcor ycor ] => 30 In the final example, note that the result of atan equals the turtle's heading. If you ever need to convert a turtle heading (obtained with atan or otherwise) to a normal mathematical angle, the following should be helpful: to-report heading-to-angle [ h ] report (90 - h) mod 360 end"
      ],
      "13": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: autoplot \n\nEntry Data: autoplot\nusage: autoplot? \n Reports true if auto-plotting is on for the current plot, false otherwise."
      ],
      "14": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: auto-plot-status \n\nEntry Data: auto-plot-status\nusage: [('class', 'prim_example')]auto-plot-on \n This pair of commands is used to control the NetLogo feature of auto-plotting in the current plot. Auto-plotting will automatically update the x and y axes of the plot whenever the current pen exceeds these boundaries when adding a new point with plot or plotxy. When using histogram to plot values, only the y axis will automatically update its ranges, the x axis will be unchanged. Each plot has an auto-plotting setting called Auto Scale? in the user interface that determines if the plot will enable auto-plotting when the model starts. Auto-plotting is useful when wanting to show all plotted values in the current plot, regardless of the current plot ranges. These commands will produce a runtime error if the current plot has not been set. See also plot, plotxy, and histogram, and also the Plots section of the Interface Tab guide."
      ],
      "15": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: back \n\nEntry Data: back\nusage: back number \n The turtle moves backward by number steps. (If number is negative, the turtle moves forward.) Turtles using this primitive can move a maximum of one unit per time increment. So bk 0.5 and bk 1 both take one unit of time, but bk 3 takes three. If the turtle cannot move backward number steps because it is not permitted by the current topology the turtle will complete as many steps of 1 as it can and stop. See also forward, jump, can-move?."
      ],
      "16": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: base-colors \n\nEntry Data: base-colors\nusage: base-colors \n Reports a list of the 14 basic NetLogo hues. print base-colors => [5 15 25 35 45 55 65 75 85 95 105 115 125 135] ask turtles [ set color one-of base-colors ] ;; each turtle turns a random base color ask turtles [ set color one-of remove gray base-colors ] ;; each turtle turns a random base color except for gray"
      ],
      "17": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: beep \n\nEntry Data: beep\nusage: beep \n Emits a beep. Note that the beep sounds immediately, so several beep commands in close succession may produce only one audible sound. Example: beep ;; emits one beep repeat 3 [ beep ] ;; emits 3 beeps at once, ;; so you only hear one sound repeat 3 [ beep wait 0.1 ] ;; produces 3 beeps in succession, ;; separated by 1/10th of a second When running headless, this command has no effect."
      ],
      "18": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: behaviorspace-experiment-name \n\nEntry Data: behaviorspace-experiment-name\nusage: behaviorspace-experiment-name \n Reports the current experiment name in the current experiment. If no BehaviorSpace experiment is running, reports \"\"."
      ],
      "19": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: behaviorspace-run-number \n\nEntry Data: behaviorspace-run-number\nusage: behaviorspace-run-number \n Reports the current run number in the current BehaviorSpace experiment, starting at 1. If no BehaviorSpace experiment is running, reports 0."
      ],
      "20": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: both-ends \n\nEntry Data: both-ends\nusage: both-ends \n Reports the agentset of the 2 nodes connected by this link. crt 2 ask turtle 0 [ create-link-with turtle 1 ] ask link 0 1 [ ask both-ends [ set color red ] ;; turtles 0 and 1 both turn red ]"
      ],
      "21": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: breedvar \n\nEntry Data: breedvar\nusage: breed \n This is a built-in turtle and link variable. It holds the agentset of all turtles or links of the same breed as this turtle or link. (For turtles or links that do not have any particular breed, this is the turtles agentset of all turtles or the links agentset of all links respectively.) You can set this variable to change a turtle or link's breed. (When a turtle changes breeds, its shape is reset to the default shape for that breed. See set-default-shape.) See also breed, directed-link-breed, undirected-link-breed Example: breed [cats cat] breed [dogs dog] ;; turtle code: if breed = cats [ show \"meow!\" ] set breed dogs show \"woof!\" directed-link-breed [ roads road ] ;; link code if breed = roads [ set color gray ]"
      ],
      "22": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: breed \n\nEntry Data: breed\nusage: breed [<breeds> <breed>] \n This keyword, like the globals, turtles-own, and patches-own keywords, can only be used at the beginning of the Code tab, before any procedure definitions. It defines a breed. The first input defines the name of the agentset associated with the breed. The second input defines the name of a single member of the breed. Any turtle of the given breed: is part of the agentset named by the breed name has its breed built-in variable set to that agentset Most often, the agentset is used in conjunction with ask to give commands to only the turtles of a particular breed. breed [mice mouse] breed [frogs frog] to setup clear-all create-mice 50 ask mice [ set color white ] create-frogs 50 ask frogs [ set color green ] show [breed] of one-of mice ;; prints mice show [breed] of one-of frogs ;; prints frogs end show mouse 1 ;; prints (mouse 1) show frog 51 ;; prints (frog 51) show turtle 51 ;; prints (frog 51) See also globals, patches-own, turtles-own, <breeds>-own, create-<breeds>, <breeds>-at, <breeds>-here."
      ],
      "23": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: but-first-and-last \n\nEntry Data: but-first-and-last\nusage: [('class', 'prim_example')][('class', 'prim_example')][('class', 'prim_example')]but-last string \n When used on a list, but-first reports all of the list items of list except the first, and but-last reports all of the list items of list except the last. On strings, but-first and but-last report a shorter string omitting the first or last character of the original string. ;; mylist is [2 4 6 5 8 12] set mylist but-first mylist ;; mylist is now [4 6 5 8 12] set mylist but-last mylist ;; mylist is now [4 6 5 8] show but-first \"string\" ;; prints \"tring\" show but-last \"string\" ;; prints \"strin\""
      ],
      "24": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: can-move \n\nEntry Data: can-move\nusage: can-move? distance \n Reports true if this turtle can move distance in the direction it is facing without violating the topology; reports false otherwise. It is equivalent to: patch-ahead distance != nobody"
      ],
      "25": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: carefully \n\nEntry Data: carefully\nusage: carefully [ commands1 ] [ commands2 ] \n Runs commands1. If a runtime error occurs inside commands1, NetLogo won't stop and alert the user that an error occurred. It will suppress the error and run commands2 instead. The error-message reporter can be used in commands2 to find out what error was suppressed in commands1. See error-message. carefully [ print one-of [1 2 3] ] [ print error-message ] => 3 observer> carefully [ print one-of [] ] [ print error-message ] => ONE-OF got an empty list as input."
      ],
      "26": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: ceiling \n\nEntry Data: ceiling\nusage: ceiling number \n Reports the smallest integer greater than or equal to number. show ceiling 4.5 => 5 show ceiling -4.5 => -4 See also floor, round, precision."
      ],
      "27": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: clear-all \n\nEntry Data: clear-all\nusage: clear-all \n Combines the effects of clear-globals, clear-ticks, clear-turtles, clear-patches, clear-drawing, clear-all-plots, and clear-output."
      ],
      "28": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: clear-all-plots \n\nEntry Data: clear-all-plots\nusage: clear-all-plots \n Clears every plot in the model. See clear-plot for more information."
      ],
      "29": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: clear-drawing \n\nEntry Data: clear-drawing\nusage: clear-drawing \n Clears all lines and stamps drawn by turtles."
      ],
      "30": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: clear-globals \n\nEntry Data: clear-globals\nusage: clear-globals \n Sets all code-defined global variables (i.e., those defined inside of globals [ ... ]) to 0. Global variables defined by widgets are not affected by this primitive."
      ],
      "31": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: clear-links \n\nEntry Data: clear-links\nusage: clear-links \n Kills all links. See also die."
      ],
      "32": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: clear-output \n\nEntry Data: clear-output\nusage: clear-output \n Clears all text from the model's output area, if it has one. Otherwise does nothing."
      ],
      "33": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: clear-patches \n\nEntry Data: clear-patches\nusage: clear-patches \n Clears the patches by resetting all patch variables to their default initial values, including setting their color to black."
      ],
      "34": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: clear-plot \n\nEntry Data: clear-plot\nusage: clear-plot \n In the current plot only, resets all plot pens, deletes all temporary plot pens, resets the plot to its default values (for x range, y range, etc.), and resets all permanent plot pens to their default values. The default values for the plot and for the permanent plot pens are set in the plot Edit dialog, which is displayed when you edit the plot. If there are no plot pens after deleting all temporary pens, that is to say if there are no permanent plot pens, a default plot pen will be created with the following initial settings: Pen: down Color: black Mode: 0 (line mode) Name: \"default\" Interval: 1 See also clear-all-plots. This command will produce a runtime error if the current plot has not been set."
      ],
      "35": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: clear-ticks \n\nEntry Data: clear-ticks\nusage: clear-ticks \n Clears the tick counter. Does not set the counter to zero. After this command runs, the tick counter has no value. Attempting to access or update it is an error until reset-ticks is called. This is useful if you want to set the model to a \"pre-setup\" state with some forever buttons disabled. See also reset-ticks."
      ],
      "36": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: clear-turtles \n\nEntry Data: clear-turtles\nusage: clear-turtles \n Kills all turtles. Also resets the who numbering, so the next turtle created will be turtle 0. See also die."
      ],
      "37": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: color \n\nEntry Data: color\nusage: color \n This is a built-in turtle or link variable. It holds the color of the turtle or link. You can set this variable to make the turtle or link change color. Color can be represented either as a NetLogo color (a single number), or an RGB color (a list of 3 numbers or 4 numbers with transparency). See details in the Colors section of the Programming Guide. See also pcolor."
      ],
      "38": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: cos \n\nEntry Data: cos\nusage: cos number \n Reports the cosine of the given angle. Assumes the angle is given in degrees. show cos 180 => -1"
      ],
      "39": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: count \n\nEntry Data: count\nusage: count agentset \n Reports the number of agents in the given agentset. show count turtles ;; prints the total number of turtles show count patches with [pcolor = red] ;; prints the total number of red patches"
      ],
      "40": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: create-ordered-turtles \n\nEntry Data: create-ordered-turtles\nusage: [('class', 'prim_example')][('class', 'prim_example')][('class', 'prim_example')]create-ordered<breeds> number [ commands ] \n Creates number new turtles. New turtles start at position (0, 0), are created with the 14 primary colors, and have headings from 0 to 360, evenly spaced. If the create-ordered-<breeds> form is used, the new turtles are created as members of the given breed. If commands are supplied, the new turtles immediately run them. This is useful for giving the new turtles a different color, heading, or whatever. (The new turtles are created all at once then run one at a time, in random order.) If number is fractional, it will be rounded down to the nearest integer (4.5 becomes 4, 10.9 becomes 10). cro 100 [ fd 10 ] ;; makes an evenly spaced circle"
      ],
      "41": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: create-link \n\nEntry Data: create-link\nusage: [('class', 'prim_example')][('class', 'prim_example')][('class', 'prim_example')][('class', 'prim_example')][('class', 'prim_example')][('class', 'prim_example')][('class', 'prim_example')][('class', 'prim_example')][('class', 'prim_example')][('class', 'prim_example')][('class', 'prim_example')][('class', 'prim_example')][('class', 'prim_example')][('class', 'prim_example')][('class', 'prim_example')][('class', 'prim_example')][('class', 'prim_example')][('class', 'prim_example')][('class', 'prim_example')][('class', 'prim_example')][('class', 'prim_example')][('class', 'prim_example')][('class', 'prim_example')]create-links-with turtleset [ commands ] \n Used for creating breeded and unbreeded links between turtles. create-link-with creates an undirected link between the caller and agent. create-link-to creates a directed link from the caller to agent. create-link-from creates a directed link from agent to the caller. When the plural form of the breed name is used, an agentset is expected instead of an agent and links are created between the caller and all agents in the agentset. The optional command block is the set of commands each newly formed link runs. (The links are created all at once then run one at a time, in random order.) A node cannot be linked to itself. Also, you cannot have more than one undirected link of the same breed between the same two nodes, nor can you have more than one directed link of the same breed going in the same direction between two nodes. If you try to create a link where one (of the same breed) already exists, nothing happens. If you try to create a link from a turtle to itself you get a runtime error. to setup clear-all create-turtles 5 ;; turtle 1 creates links with all other turtles ;; the link between the turtle and itself is ignored ask turtle 0 [ create-links-with other turtles ] show count links ;; shows 4 ;; this does nothing since the link already exists ask turtle 0 [ create-link-with turtle 1 ] show count links ;; shows 4 since the previous link already existed ask turtle 2 [ create-link-with turtle 1 ] show count links ;; shows 5 end directed-link-breed [red-links red-link] undirected-link-breed [blue-links blue-link] to setup clear-all create-turtles 5 ;; create links in both directions between turtle 0 ;; and all other turtles ask turtle 0 [ create-red-links-to other turtles ] ask turtle 0 [ create-red-links-from other turtles ] show count links ;; shows 8 ;; now create undirected links between turtle 0 and other turtles ask turtle 0 [ create-blue-links-with other turtles ] show count links ;; shows 12 end"
      ],
      "42": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: create-turtles \n\nEntry Data: create-turtles\nusage: [('class', 'prim_example')][('class', 'prim_example')][('class', 'prim_example')]create-<breeds> number [ commands ] \n Creates number new turtles at the origin. New turtles have random integer headings and the color is randomly selected from the 14 primary colors. If the create-<breeds> form is used, the new turtles are created as members of the given breed. If commands are supplied, the new turtles immediately run them. This is useful for giving the new turtles a different color, heading, or whatever. (The new turtles are created all at once then run one at a time, in random order.) If number is fractional, it will be rounded down to the nearest integer (4.5 becomes 4, 10.9 becomes 10). crt 100 [ fd 10 ] ;; makes a randomly spaced circle breed [canaries canary] breed [snakes snake] to setup clear-all create-canaries 50 [ set color yellow ] create-snakes 50 [ set color green ] end See also hatch, sprout."
      ],
      "43": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: create-temporary-plot-pen \n\nEntry Data: create-temporary-plot-pen\nusage: create-temporary-plot-pen string \n A new temporary plot pen with the given name is created in the current plot and set to be the current pen. Few models will want to use this primitive, because all temporary pens disappear when clear-plot or clear-all-plots are called. The normal way to make a pen is to make a permanent pen in the plot's Edit dialog. If a pen with that name already exists in the current plot, no new pen is created, and the existing pen is set to the current pen. The new temporary plot pen has the following initial settings: Pen: down Color: black Mode: 0 (line mode) Interval: 1 This command will produce a runtime error if the current plot has not been set. See: clear-plot, clear-all-plots, and set-current-plot-pen."
      ],
      "44": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: date-and-time \n\nEntry Data: date-and-time\nusage: date-and-time \n Reports a string containing the current date and time. The format is shown below. All fields are fixed width, so they are always at the same locations in the string. The potential resolution of the clock is milliseconds. (Whether you get resolution that high in practice may vary from system to system, depending on the capabilities of the underlying Java Virtual Machine.) show date-and-time => \"01:19:36.685 PM 19-Sep-2002\""
      ],
      "45": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: die \n\nEntry Data: die\nusage: die \n The turtle or link dies. if xcor > 20 [ die ] ;; all turtles with xcor greater than 20 die ask links with [color = blue] [ die ] ;; all the blue links will die A dead agent ceases to exist. The effects of this include: The agent will not execute any further code. So if you write ask turtles [ die print \"last words?\" ], no last words will be printed, because the turtles are already dead before they have a chance to print anything. The agent will disappear from any agentsets it was in, reducing the size of those agentsets by one. Any variable that was storing the agent will now instead have nobody in it. So for example let x one-of turtles ask x [ die ] print x prints nobody. If the dead agent was a turtle, every link connected to it also dies. If the observer was watching or following the agent, the observer's perspective resets, as if reset-perspective had been run. See also: clear-turtles clear-links"
      ],
      "46": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: diffuse \n\nEntry Data: diffuse\nusage: diffuse patch-variable number \n Tells each patch to give equal shares of (number * 100) percent of the value of patch-variable to its eight neighboring patches. number should be between 0 and 1. Regardless of topology the sum of patch-variable will be conserved across the world. (If a patch has fewer than eight neighbors, each neighbor still gets an eighth share; the patch keeps any leftover shares.) Note that this is an observer command only, even though you might expect it to be a patch command. (The reason is that it acts on all the patches at once -- patch commands act on individual patches.) diffuse chemical 0.5 ;; each patch diffuses 50% of its variable ;; chemical to its neighboring 8 patches. Thus, ;; each patch gets 1/8 of 50% of the chemical ;; from each neighboring patch.)"
      ],
      "47": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: diffuse4 \n\nEntry Data: diffuse4\nusage: diffuse4 patch-variable number \n Like diffuse, but only diffuses to the four neighboring patches (to the north, south, east, and west), not to the diagonal neighbors. diffuse4 chemical 0.5 ;; each patch diffuses 50% of its variable ;; chemical to its neighboring 4 patches. Thus, ;; each patch gets 1/4 of 50% of the chemical ;; from each neighboring patch.)"
      ],
      "48": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: directed-link-breed \n\nEntry Data: directed-link-breed\nusage: directed-link-breed [<link-breeds> <link-breed>] \n This keyword, like the globals and breeds keywords, can only be used at the beginning of the Code tab, before any procedure definitions. It defines a directed link breed. Links of a particular breed are always all directed or all undirected The first input defines the name of the agentset associated with the link breed. The second input defines the name of a single member of the breed. Directed links can be created using create-link(s)-to, and create-link(s)-from, but not create-link(s)-with Any link of the given link breed: is part of the agentset named by the link breed name has its built-in variable breed set to that agentset is directed or undirected as declared by the keyword Most often, the agentset is used in conjunction with ask to give commands to only the links of a particular breed. directed-link-breed [streets street] directed-link-breed [highways highway] to setup clear-all crt 2 ;; create a link from turtle 0 to turtle 1 ask turtle 0 [ create-street-to turtle 1 ] ;; create a link from turtle 1 to turtle 0 ask turtle 0 [ create-highway-from turtle 1 ] end ask turtle 0 [ show one-of my-in-links ] ;; prints (street 0 1) ask turtle 0 [ show one-of my-out-links ] ;; prints (highway 1 0) See also breed, undirected-link-breed"
      ],
      "49": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: display \n\nEntry Data: display\nusage: display \n Causes the view to be updated immediately. (Exception: if the user is using the speed slider to fast-forward the model, then the update may be skipped.) Also undoes the effect of the no-display command, so that if view updates were suspended by that command, they will resume. no-display ask turtles [ jump 10 set color blue set size 5 ] display ;; turtles move, change color, and grow, with none of ;; their intermediate states visible to the user, only ;; their final state Even if no-display was not used, \"display\" can still be useful, because ordinarily NetLogo is free to skip some view updates, so that fewer total updates take place, so that models run faster. This command lets you force a view update, so whatever changes have taken place in the world are visible to the user. ask turtles [ set color red ] display ask turtles [ set color blue] ;; turtles turn red, then blue; use of \"display\" forces ;; red turtles to appear briefly Note that display and no-display operate independently of the switch in the view control strip that freezes the view. See also no-display."
      ],
      "50": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: distance \n\nEntry Data: distance\nusage: distance agent \n Reports the distance from this agent to the given turtle or patch. The distance to or a from a patch is measured from the center of the patch. Turtles and patches use the wrapped distance (around the edges of the world) if wrapping is allowed by the topology and the wrapped distance is shorter. ask turtles [ show max-one-of turtles [distance myself] ] ;; each turtle prints the turtle farthest from itself"
      ],
      "51": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: distancexy \n\nEntry Data: distancexy\nusage: distancexy x y \n Reports the distance from this agent to the point (x, y). The distance from a patch is measured from the center of the patch. Turtles and patches use the wrapped distance (around the edges of the world) if wrapping is allowed by the topology and the wrapped distance is shorter. if (distancexy 0 0) > 10 [ set color green ] ;; all turtles more than 10 units from ;; the center of the world turn green."
      ],
      "52": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: downhill \n\nEntry Data: downhill\nusage: [('class', 'prim_example')]downhill4 patch-variable \n Moves the turtle to the neighboring patch with the lowest value for patch-variable. If no neighboring patch has a smaller value than the current patch, the turtle stays put. If there are multiple patches with the same lowest value, the turtle picks one randomly. Non-numeric values are ignored. downhill considers the eight neighboring patches; downhill4 only considers the four neighbors. Equivalent to the following code (assumes variable values are numeric): move-to patch-here ;; go to patch center let p min-one-of neighbors [patch-variable] ;; or neighbors4 if [patch-variable] of p < patch-variable [ face p move-to p ] Note that the turtle always ends up on a patch center and has a heading that is a multiple of 45 (downhill) or 90 (downhill4). See also uphill, uphill4."
      ],
      "53": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: dxy \n\nEntry Data: dxy\nusage: [('class', 'prim_example')]dy \n Reports the x-increment or y-increment (the amount by which the turtle's xcor or ycor would change) if the turtle were to take one step forward in its current heading. Note: dx is simply the sine of the turtle's heading, and dy is simply the cosine. (If this is the reverse of what you expected, it's because in NetLogo a heading of 0 is north and 90 is east, which is the reverse of how angles are usually defined in geometry.) Note: In earlier versions of NetLogo, these primitives were used in many situations where the new patch-ahead primitive is now more appropriate."
      ],
      "54": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: empty \n\nEntry Data: empty\nusage: [('class', 'prim_example')]empty? string \n Reports true if the given list or string is empty, false otherwise. Note: the empty list is written []. The empty string is written \"\"."
      ],
      "55": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: end \n\nEntry Data: end\nusage: end \n Used to conclude a procedure. See to and to-report."
      ],
      "56": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: end1 \n\nEntry Data: end1\nusage: end1 \n This is a built-in link variable. It indicates the first endpoint (turtle) of a link. For directed links this will always be the source for undirected links it will always be the turtle with the lower who number. You cannot set end1. crt 2 ask turtle 0 [ create-link-to turtle 1 ] ask links [ show end1 ] ;; shows turtle 0"
      ],
      "57": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: end2 \n\nEntry Data: end2\nusage: end2 \n This is a built-in link variable. It indicates the second endpoint (turtle) of a link. For directed links this will always be the destination for undirected links it will always be the turtle with the higher who number. You cannot set end2. crt 2 ask turtle 1 [ create-link-with turtle 0 ] ask links [ show end2 ] ;; shows turtle 1"
      ],
      "58": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: error \n\nEntry Data: error\nusage: error value \n Causes a runtime error to occur. The given value is converted to a string (if it isn't one already) and used as the error message. See also error-message, carefully."
      ],
      "59": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: error-message \n\nEntry Data: error-message\nusage: error-message \n Reports a string describing the error that was suppressed by carefully. This reporter can only be used in the second block of a carefully command. See also error, carefully."
      ],
      "60": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: every \n\nEntry Data: every\nusage: every number [ commands ] \n Runs the given commands only if it's been more than number seconds since the last time this agent ran them in this context. Otherwise, the commands are skipped. By itself, every doesn't make commands run over and over again. You need to use every inside a loop, or inside a forever button, if you want the commands run over and over again. every only limits how often the commands run. Above, \"in this context\" means during the same ask (or button press or command typed in the Command Center). So it doesn't make sense to write ask turtles [ every 0.5 [ ... ] ], because when the ask finishes the turtles will all discard their timers for the \"every\". The correct usage is shown below. every 0.5 [ ask turtles [ fd 1 ] ] ;; twice a second the turtles will move forward 1 every 2 [ set index index + 1 ] ;; every 2 seconds index is incremented See also wait."
      ],
      "61": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: exp \n\nEntry Data: exp\nusage: exp number \n Reports the value of e raised to the number power. Note: This is the same as e ^ number."
      ],
      "62": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: export-cmds \n\nEntry Data: export-cmds\nusage: [('class', 'prim_example')][('class', 'prim_example')][('class', 'prim_example')][('class', 'prim_example')][('class', 'prim_example')]export-world filename \n export-view writes the current contents of the current view to an external file given by the string filename. The file is saved in PNG (Portable Network Graphics) format, so it is recommended to supply a filename ending in \".png\". export-interface is similar, but for the whole interface tab. Note that export-view still works when running NetLogo in headless mode, but export-interface doesn't. export-output writes the contents of the model's output area to an external file given by the string filename. (If the model does not have a separate output area, the output portion of the Command Center is used.) export-plot writes the x and y values of all points plotted by all the plot pens in the plot given by the string plotname to an external file given by the string filename. If a pen is in bar mode (mode 0) and the y value of the point plotted is greater than 0, the upper-left corner point of the bar will be exported. If the y value is less than 0, then the lower-left corner point of the bar will be exported. export-all-plots writes every plot in the current model to an external file given by the string filename. Each plot is identical in format to the output of export-plot. export-world writes the values of all variables, both built-in and user-defined, including all observer, turtle, and patch variables, the drawing, the contents of the output area if one exists, the contents of any plots and the state of the random number generator, to an external file given by the string filename. (The result file can be read back into NetLogo with the import-world primitive.) export-world does not save the state of open files. export-plot, export-all-plots and export-world save files in in plain-text, \"comma-separated values\" (.csv) format. CSV files can be read by most popular spreadsheet and database programs as well as any text editor. If you wish to export to a file in a location other than the model's location, you should include the full path to the file you wish to export. (Use the forward-slash \"/\" as the folder separator.) Note that the functionality of these primitives is also available directly from NetLogo's File menu. export-world \"fire.csv\" ;; exports the state of the model to the file fire.csv ;; located in the NetLogo folder export-plot \"Temperature\" \"c:/My Documents/plot.csv\" ;; exports the plot named ;; \"Temperature\" to the file plot.csv located in ;; the C:\\My Documents folder export-all-plots \"c:/My Documents/plots.csv\" ;; exports all plots to the file plots.csv ;; located in the C:\\My Documents folder If the file already exists, it is overwritten. To avoid this you may wish to use some method of generating fresh names. Examples: export-world user-new-file export-world (word \"results \" date-and-time \".csv\") ;; Colon characters in the time cause errors on Windows export-world (word \"results \" random-float 1.0 \".csv\")"
      ],
      "63": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: extensions \n\nEntry Data: extensions\nusage: extensions [name ...] \n Allows the model to use primitives from the extensions with the given names. See the Extensions guide for more information."
      ],
      "64": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: extract-hsb \n\nEntry Data: extract-hsb\nusage: extract-hsb color \n Reports a list of three values, the first (hue) in the range of 0 to 360, the second and third (brightness and saturation) in the range of 0 to 100. The given color can either be a NetLogo color in the range 0 to 140, not including 140 itself, or an RGB list of three values in the range 0 to 255 representing the levels of red, green, and blue. show extract-hsb cyan => [180 57.143 76.863] show extract-hsb red => [3.103 80.93 84.314] show extract-hsb [255 0 0] => [0 100 100] See also approximate-hsb, approximate-rgb, extract-rgb."
      ],
      "65": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: extract-rgb \n\nEntry Data: extract-rgb\nusage: extract-rgb color \n Reports a list of three values in the range 0 to 255 representing the levels of red, green, and blue, respectively, of the given NetLogo or RGB(A) color. show extract-rgb red => [215 50 41] show extract-rgb cyan => [84 196 196] show extract-rgb [31 41 59] => [31 41 59] See also approximate-rgb, approximate-hsb, extract-hsb."
      ],
      "66": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: face \n\nEntry Data: face\nusage: face agent \n Set the caller's heading towards agent. If wrapping is allowed by the topology and the wrapped distance (around the edges of the world) is shorter, face will use the wrapped path. If the caller and the agent are at the exact same position, the caller's heading won't change."
      ],
      "67": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: facexy \n\nEntry Data: facexy\nusage: facexy x y \n Set the caller's heading towards the point (x,y). If wrapping is allowed by the topology and the wrapped distance (around the edges of the world) is shorter and wrapping is allowed, facexy will use the wrapped path. If the caller is on the point (x,y), the caller's heading won't change."
      ],
      "68": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: file-at-end \n\nEntry Data: file-at-end\nusage: file-at-end? \n Reports true when there are no more characters left to read in from the current file (that was opened previously with file-open). Otherwise, reports false. file-open \"my-file.txt\" print file-at-end? => false ;; Can still read in more characters print file-read-line => This is the last line in file print file-at-end? => true ;; We reached the end of the file See also file-open, file-close-all."
      ],
      "69": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: file-close \n\nEntry Data: file-close\nusage: file-close \n Closes a file that has been opened previously with file-open. Note that this and file-close-all are the only ways to restart to the beginning of an opened file or to switch between file modes. If no file is open, does nothing. See also file-close-all, file-open."
      ],
      "70": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: file-close-all \n\nEntry Data: file-close-all\nusage: file-close-all \n Closes all files (if any) that have been opened previously with file-open. See also file-close, file-open."
      ],
      "71": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: file-delete \n\nEntry Data: file-delete\nusage: file-delete string \n Deletes the file specified as string string must be an existing file with writable permission by the user. Also, the file cannot be open. Use the command file-close to close an opened file before deletion. Note that the string can either be a file name or an absolute file path. If it is a file name, it looks in whatever the current directory is. This can be changed using the command set-current-directory. It is defaulted to the model's directory."
      ],
      "72": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: file-exists \n\nEntry Data: file-exists\nusage: file-exists? string \n Reports true if string is the name of an existing file on the system. Otherwise it reports false. Note that the string can either be a file name or an absolute file path. If it is a file name, it looks in whatever the current directory is. This can be changed using the command set-current-directory. It defaults to to the model's directory."
      ],
      "73": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: file-flush \n\nEntry Data: file-flush\nusage: file-flush \n Forces file updates to be written to disk. When you use file-write or other output commands, the values may not be immediately written to disk. This improves the performance of the file output commands. Closing a file ensures that all output is written to disk. Sometimes you need to ensure that data is written to disk without closing the file. For example, you could be using a file to communicate with another program on your machine and want the other program to be able to see the output immediately."
      ],
      "74": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: file-open \n\nEntry Data: file-open\nusage: file-open string \n This command will interpret string as a path name to a file and open the file. You may then use the reporters file-read, file-read-line, and file-read-characters to read in from the file, or file-write, file-print, file-type, or file-show to write out to the file. Note that you can only open a file for reading or writing but not both. The next file i/o primitive you use after this command dictates which mode the file is opened in. To switch modes, you need to close the file using file-close. Also, the file must already exist if opening a file in reading mode. When opening a file in writing mode, all new data will be appended to the end of the original file. If there is no original file, a new blank file will be created in its place. (You must have write permission in the file's directory.) (If you don't want to append, but want to replace the file's existing contents, use file-delete to delete it first, perhaps inside a carefully if you're not sure whether it already exists.) Note that the string can either be a file name or an absolute file path. If it is a file name, it looks in whatever the current directory is. This can be changed using the command set-current-directory. It is defaulted to the model's directory. file-open \"my-file-in.txt\" print file-read-line => First line in file ;; File is in reading mode file-open \"C:\\\\NetLogo\\\\my-file-out.txt\" ;; assuming Windows machine file-print \"Hello World\" ;; File is in writing mode Opening a file does not close previously opened files. You can use file-open to switch back and forth between multiple open files. See also file-close See also file-close-all."
      ],
      "75": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: file-print \n\nEntry Data: file-print\nusage: file-print value \n Prints value to an opened file, followed by a carriage return. This agent is not printed before the value, unlike file-show. Note that this command is the file i/o equivalent of print, and file-open needs to be called before this command can be used. See also file-show, file-type, file-write, and Output (programming guide)."
      ],
      "76": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: file-read \n\nEntry Data: file-read\nusage: file-read \n This reporter will read in the next constant from the opened file and interpret it as if it had been typed in the Command Center. It reports the resulting value. The result may be a number, list, string, boolean, or the special value nobody. Whitespace separates the constants. Each call to file-read will skip past both leading and trailing whitespace. Note that strings need to have quotes around them. Use the command file-write to have quotes included. Also note that the file-open command must be called before this reporter can be used, and there must be data remaining in the file. Use the reporter file-at-end? to determine if you are at the end of the file. file-open \"my-file.data\" print file-read + 5 ;; Next value is the number 1 => 6 print length file-read ;; Next value is the list [1 2 3 4] => 4 Note: This primitive is not compatible with NetLogo Web. If you wish to read the contents of a file with the same code and the same behavior in both NetLogo and NetLogo Web, see fetch:user-file-async. See also file-open and file-write."
      ],
      "77": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: file-read-characters \n\nEntry Data: file-read-characters\nusage: file-read-characters number \n Reports the given number of characters from an opened file as a string. If there are fewer than that many characters left, it will report all of the remaining characters. Note that it will return every character including newlines and spaces. Also note that the file-open command must be called before this reporter can be used, and there must be data remaining in the file. Use the reporter file-at-end? to determine if you are at the end of the file. file-open \"my-file.txt\" print file-read-characters 5 ;; Current line in file is \"Hello World\" => Hello See also file-open."
      ],
      "78": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: file-read-line \n\nEntry Data: file-read-line\nusage: file-read-line \n Reads the next line in the file and reports it as a string. It determines the end of the file by a carriage return, an end of file character or both in a row. It does not return the line terminator characters. Also note that the file-open command must be called before this reporter can be used, and there must be data remaining in the file. Use the reporter file-at-end? to determine if you are at the end of the file. file-open \"my-file.txt\" print file-read-line => Hello World See also file-open."
      ],
      "79": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: file-show \n\nEntry Data: file-show\nusage: file-show value \n Prints value to an opened file, preceded by this agent agent, and followed by a carriage return. (This agent is included to help you keep track of what agents are producing which lines of output.) Also, all strings have their quotes included similar to file-write. Note that this command is the file i/o equivalent of show, and file-open needs to be called before this command can be used. See also file-print, file-type, file-write, and Output (programming guide)."
      ],
      "80": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: file-type \n\nEntry Data: file-type\nusage: file-type value \n Prints value to an opened file, not followed by a carriage return (unlike file-print and file-show). The lack of a carriage return allows you to print several values on the same line. This agent is not printed before the value. unlike file-show. Note that this command is the file i/o equivalent of type, and file-open needs to be called before this command can be used. See also file-print, file-show, file-write, and Output (programming guide)."
      ],
      "81": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: file-write \n\nEntry Data: file-write\nusage: file-write value \n This command will output value, which can be a number, string, list, boolean, or nobody to an opened file, not followed by a carriage return (unlike file-print and file-show). This agent is not printed before the value, unlike file-show. Its output also includes quotes around strings and is prepended with a space. It will output the value in such a manner that file-read will be able to interpret it. Note that this command is the file i/o equivalent of write, and file-open needs to be called before this command can be used. file-open \"locations.txt\" ask turtles [ file-write xcor file-write ycor ] See also file-print, file-show, file-type, and Output (programming guide)."
      ],
      "82": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: filter \n\nEntry Data: filter\nusage: filter reporter list \n Reports a list containing only those items of list for which the reporter reports true -- in other words, the items satisfying the given condition. reporter may be an anonymous reporter or the name of a reporter. show filter is-number? [1 \"2\" 3] => [1 3] show filter [ i -> i < 3 ] [1 3 2] => [1 2] show filter [ s -> first s != \"t\" ] [\"hi\" \"there\" \"everyone\"] => [\"hi\" \"everyone\"] See also map, reduce, -> (anonymous procedure)."
      ],
      "83": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: first \n\nEntry Data: first\nusage: [('class', 'prim_example')]first string \n On a list, reports the first (0th) item in the list. On a string, reports a one-character string containing only the first character of the original string."
      ],
      "84": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: floor \n\nEntry Data: floor\nusage: floor number \n Reports the largest integer less than or equal to number. show floor 4.5 => 4 show floor -4.5 => -5 See also ceiling, round, precision."
      ],
      "85": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: follow \n\nEntry Data: follow\nusage: follow turtle \n Similar to ride, but, in the 3D view, the observer's vantage point is behind and above turtle. The observer may only watch or follow a single subject. Calling follow will alter the highlight created by prior calls to watch and watch-me, highlighting the followed turtle instead. See also follow-me, ride, reset-perspective, watch, subject."
      ],
      "86": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: follow-me \n\nEntry Data: follow-me\nusage: follow-me \n Asks the observer to follow this turtle. The observer may only watch or follow a single subject. Calling follow-me will remove the highlight created by prior calls to watch and watch-me, highlighting this turtle instead. See also follow."
      ],
      "87": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: foreach \n\nEntry Data: foreach\nusage: [('class', 'prim_example')](foreach list1 ... command) \n With a single list, runs the command for each item of list. command may be the name of a command, or an anonymous command created with ->. foreach [1.1 2.2 2.6] show => 1.1 => 2.2 => 2.6 foreach [1.1 2.2 2.6] [ x -> show (word x \" -> \" round x) ] => 1.1 -> 1 => 2.2 -> 2 => 2.6 -> 3 With multiple lists, runs command for each group of items from each list. So, they are run once for the first items, once for the second items, and so on. All the lists must be the same length. Some examples make this clearer: (foreach [1 2 3] [2 4 6] [ [a b] -> show word \"the sum is: \" (a + b) ]) => \"the sum is: 3\" => \"the sum is: 6\" => \"the sum is: 9\" (foreach list (turtle 1) (turtle 2) [3 4] [ [the-turtle num-steps] -> ask the-turtle [ fd num-steps ] ]) ;; turtle 1 moves forward 3 patches ;; turtle 2 moves forward 4 patches See also map, -> (anonymous procedure)."
      ],
      "88": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: forward \n\nEntry Data: forward\nusage: forward number \n The turtle moves forward by number steps, one step at a time. (If number is negative, the turtle moves backward.) fd 10 is equivalent to repeat 10 [ jump 1 ]. fd 10.5 is equivalent to repeat 10 [ jump 1 ] jump 0.5. If the turtle cannot move forward number steps because it is not permitted by the current topology the turtle will complete as many steps of 1 as it can, then stop. See also jump, can-move?."
      ],
      "89": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: fput \n\nEntry Data: fput\nusage: fput item list \n Adds item to the beginning of a list and reports the new list. ;; suppose mylist is [5 7 10] set mylist fput 2 mylist ;; mylist is now [2 5 7 10]"
      ],
      "90": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: globals \n\nEntry Data: globals\nusage: globals [var1 ...] \n This keyword, like the breed, <breeds>-own, patches-own, and turtles-own keywords, can only be used at the beginning of a program, before any function definitions. It defines new global variables. Global variables are \"global\" because they are accessible by all agents and can be used anywhere in a model. Most often, globals is used to define variables or constants that need to be used in many parts of the program."
      ],
      "91": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: hatch \n\nEntry Data: hatch\nusage: [('class', 'prim_example')]hatch-<breeds> number [ commands ] \n This turtle creates number new turtles. Each new turtle inherits of all its variables, including its location, from its parent. (Exceptions: each new turtle will have a new who number, and it may be of a different breed than its parent if the hatch-<breeds> form is used.) The new turtles then run commands. You can use the commands to give the new turtles different colors, headings, locations, or whatever. (The new turtles are created all at once, then run one at a time, in random order.) If the hatch-<breeds> form is used, the new turtles are created as members of the given breed. Otherwise, the new turtles are the same breed as their parent. hatch 1 [ lt 45 fd 1 ] ;; this turtle creates one new turtle, ;; and the child turns and moves away hatch-sheep 1 [ set color black ] ;; this turtle creates a new turtle ;; of the sheep breed See also create-turtles, sprout."
      ],
      "92": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: heading \n\nEntry Data: heading\nusage: heading \n This is a built-in turtle variable. It indicates the direction the turtle is facing. This is a number greater than or equal to 0 and less than 360. 0 is north, 90 is east, and so on. You can set this variable to make a turtle turn. See also right, left, dx, dy. Example: set heading 45 ;; turtle is now facing northeast set heading heading + 10 ;; same effect as \"rt 10\""
      ],
      "93": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: hidden \n\nEntry Data: hidden\nusage: hidden? \n This is a built-in turtle or link variable. It holds a boolean (true or false) value indicating whether the turtle or link is currently hidden (i.e., invisible). You can set this variable to make a turtle or link disappear or reappear. See also hide-turtle, show-turtle, hide-link, show-link Example: set hidden? not hidden? ;; if turtle was showing, it hides, and if it was hiding, ;; it reappears"
      ],
      "94": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: hide-link \n\nEntry Data: hide-link\nusage: hide-link \n The link makes itself invisible. Note: This command is equivalent to setting the link variable \"hidden?\" to true. See also show-link."
      ],
      "95": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: hide-turtle \n\nEntry Data: hide-turtle\nusage: hide-turtle \n The turtle makes itself invisible. Note: This command is equivalent to setting the turtle variable \"hidden?\" to true. See also show-turtle."
      ],
      "96": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: histogram \n\nEntry Data: histogram\nusage: histogram list \n Histograms the values in the given list Draws a histogram showing the frequency distribution of the values in the list. The heights of the bars in the histogram represent the numbers of values in each subrange. Before the histogram is drawn, first any previous points drawn by the current plot pen are removed. Any non-numeric values in the list are ignored. The histogram is drawn on the current plot using the current plot pen and pen color. Auto scaling does not affect a histogram's horizontal range, so set-plot-x-range should be used to control the range, and the pen interval can then be set (either directly with set-plot-pen-interval, or indirectly via set-histogram-num-bars) to control how many bars that range is split up into. Be sure that if you want the histogram drawn with bars that the current pen is in bar mode (mode 1). For histogramming purposes the plot's X range is not considered to include the maximum X value. Values equal to the maximum X will fall outside of the histogram's range. histogram [color] of turtles ;; draws a histogram showing how many turtles there are ;; of each color This command will produce a runtime error if either the current plot or the current pen has not been set. See also set-histogram-num-bars, set-plot-pen-interval, set-plot-x-range."
      ],
      "97": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: home \n\nEntry Data: home\nusage: home \n This turtle moves to the origin (0,0). Equivalent to setxy 0 0."
      ],
      "98": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: hsb \n\nEntry Data: hsb\nusage: hsb hue saturation brightness \n Reports a RGB list when given three numbers describing an HSB color. Hue, saturation, and brightness are integers in the range 0-360, 0-100, 0-100 respectively. The RGB list contains three integers in the range of 0-255. See also rgb"
      ],
      "99": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: hubnet-broadcast \n\nEntry Data: hubnet-broadcast\nusage: hubnet-broadcast tag-name value \n This broadcasts value from NetLogo to the interface element with the name tag-name on the clients. See the HubNet Authoring Guide for details and instructions."
      ],
      "100": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: hubnet-broadcast-clear-output \n\nEntry Data: hubnet-broadcast-clear-output\nusage: hubnet-broadcast-clear-output \n This clears all messages printed to the text area on every client. See also: hubnet-broadcast-message, hubnet-send-clear-output"
      ],
      "101": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: hubnet-broadcast-message \n\nEntry Data: hubnet-broadcast-message\nusage: hubnet-broadcast-message value \n This prints the value in the text area on each client. This is the same functionality as the \"Broadcast Message\" button in the HubNet Control Center. See also: hubnet-send-message"
      ],
      "102": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: hubnet-clear-override \n\nEntry Data: hubnet-clear-override\nusage: [('class', 'prim_example')]hubnet-clear-overrides client \n Remove overrides from the override list on client. hubnet-clear-override removes only the override for the specified variable for the specified agent or agentset. hubnet-clear-overrides removes all overrides from the specified client. See also: hubnet-send-override"
      ],
      "103": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: hubnet-clients-list \n\nEntry Data: hubnet-clients-list\nusage: hubnet-clients-list \n Reports a list containing the names of all the clients currently connected to the HubNet server."
      ],
      "104": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: hubnet-enter-message \n\nEntry Data: hubnet-enter-message\nusage: hubnet-enter-message? \n Reports true if a new client just entered the simulation. Reports false otherwise. hubnet-message-source will contain the user name of the client that just logged on. See the HubNet Authoring Guide for details and instructions."
      ],
      "105": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: hubnet-exit-message \n\nEntry Data: hubnet-exit-message\nusage: hubnet-exit-message? \n Reports true if a client just exited the simulation. Reports false otherwise. hubnet-message-source will contain the user name of the client that just logged off. See the HubNet Authoring Guide for details and instructions."
      ],
      "106": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: hubnet-fetch-message \n\nEntry Data: hubnet-fetch-message\nusage: hubnet-fetch-message \n If there is any new data sent by the clients, this retrieves the next piece of data, so that it can be accessed by hubnet-message, hubnet-message-source, and hubnet-message-tag. This will cause an error if there is no new data from the clients. See the HubNet Authoring Guide for details."
      ],
      "107": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: hubnet-kick-client \n\nEntry Data: hubnet-kick-client\nusage: hubnet-kick-client client-name \n Kicks the client with the given client-name. This is equivalent to clicking the client name in the HubNet Control Center and pressing the Kick button."
      ],
      "108": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: hubnet-kick-all-clients \n\nEntry Data: hubnet-kick-all-clients\nusage: hubnet-kick-all-clients \n Kicks out all currently connected HubNet clients. This is equivalent to selecting all clients in the HubNet Control Center and pressing the Kick button."
      ],
      "109": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: hubnet-message \n\nEntry Data: hubnet-message\nusage: hubnet-message \n Reports the message retrieved by hubnet-fetch-message. See the HubNet Authoring Guide for details."
      ],
      "110": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: hubnet-message-source \n\nEntry Data: hubnet-message-source\nusage: hubnet-message-source \n Reports the name of the client that sent the message retrieved by hubnet-fetch-message. See the HubNet Authoring Guide for details."
      ],
      "111": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: hubnet-message-tag \n\nEntry Data: hubnet-message-tag\nusage: hubnet-message-tag \n Reports the tag that is associated with the data that was retrieved by hubnet-fetch-message. The tag will be one of the Display Names of the interface elements in the client interface. See the HubNet Authoring Guide for details."
      ],
      "112": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: hubnet-message-waiting \n\nEntry Data: hubnet-message-waiting\nusage: hubnet-message-waiting? \n This looks for a new message sent by the clients. It reports true if there is one, and false if there is not. See the HubNet Authoring Guide for details."
      ],
      "113": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: hubnet-reset \n\nEntry Data: hubnet-reset\nusage: hubnet-reset \n Starts up the HubNet system. HubNet must be started to use any of the other hubnet primitives. See the HubNet Authoring Guide for details."
      ],
      "114": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: hubnet-reset-perspective \n\nEntry Data: hubnet-reset-perspective\nusage: hubnet-reset-perspective tag-name \n Clears watch or follow sent directly to the client. The view perspective will revert to the server perspective. See also: hubnet-send-watch hubnet-send-follow"
      ],
      "115": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: hubnet-send \n\nEntry Data: hubnet-send\nusage: [('class', 'prim_example')]hubnet-send list-of-strings tag-name value \n For a string, this sends value from NetLogo to the tag tag-name on the client that has string for its user name. For a list-of-strings, this sends value from NetLogo to the tag tag-name on all the clients that have a user name that is in the list-of-strings. Sending a message to a non-existent client, using hubnet-send, generates a hubnet-exit-message. See the HubNet Authoring Guide for details."
      ],
      "116": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: hubnet-send-clear-output \n\nEntry Data: hubnet-send-clear-output\nusage: [('class', 'prim_example')]hubnet-send-clear-output list-of-strings \n This clears all messages printed to the text area on the given client or clients (specified in the string or list-of-strings. See also: hubnet-send-message, hubnet-broadcast-clear-output"
      ],
      "117": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: hubnet-send-follow \n\nEntry Data: hubnet-send-follow\nusage: hubnet-send-follow client-name agent radius \n Tells the client associated with client-name to follow agent showing a radius sized Moore neighborhood around the agent. A client may only watch or follow a single subject. Calling hubnet-send-follow will alter the highlight created by prior calls to hubnet-send-watch, highlighting the followed agent instead. See also: hubnet-send-watch, hubnet-reset-perspective"
      ],
      "118": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: hubnet-send-message \n\nEntry Data: hubnet-send-message\nusage: hubnet-send-message string value \n This prints value in the text area on the client specified by string. See also: hubnet-broadcast-message"
      ],
      "119": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: hubnet-send-override \n\nEntry Data: hubnet-send-override\nusage: [('class', 'prim_example')][ reporter ] \n Evaluates reporter for the agent or agentset indicated then sends the values to the client to \"override\" the value of variable-name only on client-name. This is used to change the appearance of agents in the client view, hence, only built-in variables that affect the appearance of the agent may be selected. For example, you can override the color variable of a turtle: ask turtles [ hubnet-send-override client-name self \"color\" [ red ] ] In this example assume that there is a turtles-own variable client-name which is associated with a logged in client, and all the turtles are blue. This code makes the turtle associated with each client appear red in his or her own view but not on anyone else's or on the server. See also: hubnet-clear-overrides"
      ],
      "120": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: hubnet-send-watch \n\nEntry Data: hubnet-send-watch\nusage: hubnet-send-watch client-name agent \n Tells the client associated with client-name to watch agent. A client may only watch or follow a single subject. Calling hubnet-send-watch will undo perspective changes caused by prior calls to hubnet-send-follow. See also: hubnet-send-follow, hubnet-reset-perspective"
      ],
      "121": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: if \n\nEntry Data: if\nusage: if boolean [ commands ] \n If boolean reports true then the commands are run, otherwise the commands are not run if boolean reports false. If boolean reports a value other than true or false a runtime error will occur. The boolean may report a different value for different agents when used with a primitive like ask, so some agents may run commands and others don't. ask turtles [ if xcor > 0 [ set color blue ] ;; turtles in the right half of the world ;; turn blue ] See also ifelse, ifelse-value."
      ],
      "122": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: ifelse \n\nEntry Data: ifelse\nusage: [('class', 'prim_example')](ifelse boolean1 [ commands1 ] boolean2 [ commands2 ] ... [ elsecommands ])6.1 \n For the first boolean that reports true, runs the commands that follow. If no boolean reports true, runs elsecommands or does nothing if elsecommands is not given. When using only one boolean you do not need to surround the entire ifelse primitive and its blocks in parentheses. If a boolean reports a value other than true or false a runtime error will occur. ask patches [ ifelse pxcor > 0 [ set pcolor blue ] [ set pcolor red ] ] ;; the left half of the world turns red and ;; the right half turns blue The reporters may report a different value for different agents, so some agents may run different command blocks. When using more than one boolean you must surround the whole ifelse primitive and its blocks in parentheses. This functionality was added in NetLogo 6.1. ask patches [ let choice random 4 (ifelse choice = 0 [ set pcolor red set plabel \"r\" ] choice = 1 [ set pcolor blue set plabel \"b\" ] choice = 2 [ set pcolor green set plabel \"g\" ] ; elsecommands [ set pcolor yellow set plabel \"y\" ]) ] See also if, ifelse-value."
      ],
      "123": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: ifelse-value \n\nEntry Data: ifelse-value\nusage: [('class', 'prim_example')](ifelse-value boolean1 [ reporter1 ] boolean2 [ reporter2 ] ... [ elsereporter ])6.1 \n For the first boolean that reports true, runs the reporter that follows and reports that result. When using only one boolean you do not need to surround the entire ifelse-value primitive and its blocks in parentheses. If all booleans report false, the result is the value of elsereporter. You may leave out the elsereporter, but if all booleans report false then a runtime error will occur. If a boolean reports a value other than true or false a runtime error will occur. This can be used when a conditional is needed in the context of a reporter, where commands (such as ifelse) are not allowed. ask patches [ set pcolor ifelse-value (pxcor > 0) [blue] [red] ] ;; the left half of the world turns red and ;; the right half turns blue show n-values 10 [ n -> ifelse-value (n < 5) [0] [1] ] => [0 0 0 0 0 1 1 1 1 1] show reduce [ [a b] -> ifelse-value (a > b) [a] [b] ] [1 3 2 5 3 8 3 2 1] => 8 When using more than one boolean you must surround the whole ifelse-value primitive and its blocks in parentheses. This functionality was added in NetLogo 6.1. ask patches [ let choice random 4 set pcolor (ifelse-value choice = 0 [ red ] choice = 1 [ blue ] choice = 2 [ green ] [ yellow ]) ] A runtime error can occur if there is no elsereporter. ask patches [ let x = 2 set pcolor (ifelse-value x = 0 [ red ] x = 1 [ blue ] ; no final else reporter is given, and x is 2 so there will be a runtime error ) See also if, ifelse."
      ],
      "124": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: import-drawing \n\nEntry Data: import-drawing\nusage: import-drawing filename \n Reads an image file into the drawing, scaling it to the size of the world, while retaining the original aspect ratio of the image. The image is centered in the drawing. The old drawing is not cleared first. Agents cannot sense the drawing, so they cannot interact with or process images imported by import-drawing. If you need agents to sense an image, use import-pcolors or import-pcolors-rgb. The following image file formats are supported: BMP, JPG, GIF, and PNG. If the image format supports transparency (alpha), that information will be imported as well. Note: This primitive is not compatible with NetLogo Web. If you wish to import a drawing with the same code and the same behavior in both NetLogo and NetLogo Web, see import-a:drawing."
      ],
      "125": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: import-pcolors \n\nEntry Data: import-pcolors\nusage: import-pcolors filename \n Reads an image file, scales it to the same dimensions as the patch grid while maintaining the original aspect ratio of the image, and transfers the resulting pixel colors to the patches. The image is centered in the patch grid. The resulting patch colors may be distorted, since the NetLogo color space does not include all possible colors. (See the Color section of the Programming Guide.) import-pcolors may be slow for some images, particularly when you have many patches and a large image with many different colors. Since import-pcolors sets the pcolor of patches, agents can sense the image. This is useful if agents need to analyze, process, or otherwise interact with the image. If you want to simply display a static backdrop, without color distortion, see import-drawing. The following image file formats are supported: BMP, JPG, GIF, and PNG. If the image format supports transparency (alpha), then all fully transparent pixels will be ignored. (Partially transparent pixels will be treated as opaque.) Note: This primitive is not compatible with NetLogo Web. If you wish to import patch colors with the same code and the same behavior in both NetLogo and NetLogo Web, see import-a:pcolors."
      ],
      "126": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: import-pcolors-rgb \n\nEntry Data: import-pcolors-rgb\nusage: import-pcolors-rgb filename \n Reads an image file, scales it to the same dimensions as the patch grid while maintaining the original aspect ratio of the image, and transfers the resulting pixel colors to the patches. The image is centered in the patch grid. Unlike import-pcolors the exact colors in the original image are retained. The pcolor variable of all the patches will be an RGB list rather than an (approximated) NetLogo color. The following image file formats are supported: BMP, JPG, GIF, and PNG. If the image format supports transparency (alpha), then all fully transparent pixels will be ignored. (Partially transparent pixels will be treated as opaque.) Note: This primitive is not compatible with NetLogo Web. If you wish to import patch colors with the same code and the same behavior in both NetLogo and NetLogo Web, see import-a:pcolors-rgb."
      ],
      "127": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: import-world \n\nEntry Data: import-world\nusage: import-world filename \n Reads the values of all variables for a model, both built-in and user-defined, including all observer, turtle, and patch variables, from an external file named by the given string. The file should be in the format used by the export-world primitive. Note that the functionality of this primitive is also directly available from NetLogo's File menu. When using import-world, to avoid errors, perform these steps in the following order: Open the model from which you created the export file. Press the Setup button, to get the model in a state from which it can be run. Import the file. Re-open any files that the model had opened with the file-open command. If you want, press Go button to continue running the model from the point where it left off. If you wish to import a file from a location other than the model's location, you may include the full path to the file you wish to import. See export-world for an example. Note: This primitive is not compatible with NetLogo Web. If you wish to import a world with the same code and the same behavior in both NetLogo and NetLogo Web, see import-a:world."
      ],
      "128": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: in-cone \n\nEntry Data: in-cone\nusage: agentset in-cone distance angle \n This reporter lets you give a turtle a \"cone of vision\" in front of itself. The cone is defined by the two inputs, the vision distance (radius) and the viewing angle. The viewing angle may range from 0 to 360 and is centered around the turtle's current heading. (If the angle is 360, then in-cone is equivalent to in-radius.) in-cone reports an agentset that includes only those agents from the original agentset that fall in the cone. (This can include the agent itself.) The distance to a patch is measured from the center of the patch. ask turtles [ ask patches in-cone 3 60 [ set pcolor red ] ] ;; each turtle makes a red \"splotch\" of patches in a 60 degree ;; cone of radius 3 ahead of itself"
      ],
      "129": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: in-link-neighbor \n\nEntry Data: in-link-neighbor\nusage: [('class', 'prim_example')]in-link-neighbor? turtle \n Reports true if there is a directed link going from turtle to the caller or an undirected link connecting turtle to the caller. You can think of this as \"is there a link I can use to get from turtle to the caller?\" crt 2 ask turtle 0 [ create-link-to turtle 1 show in-link-neighbor? turtle 1 ;; prints false show out-link-neighbor? turtle 1 ;; prints true ] ask turtle 1 [ show in-link-neighbor? turtle 0 ;; prints true show out-link-neighbor? turtle 0 ;; prints false ]"
      ],
      "130": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: in-link-neighbors \n\nEntry Data: in-link-neighbors\nusage: [('class', 'prim_example')]in-link-neighbors \n Reports the agentset of all the turtles that have directed links coming from them to the caller as well as all turtles that have an undirected link connecting them with the caller. You can think of this as \"all the turtles that can get to the caller using a link.\" crt 4 ask turtle 0 [ create-links-to other turtles ] ask turtle 1 [ ask in-link-neighbors [ set color blue ] ] ;; turtle 0 turns blue"
      ],
      "131": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: in-link-from \n\nEntry Data: in-link-from\nusage: [('class', 'prim_example')]in-link-from turtle \n Reports a directed link from turtle to the caller or an undirected link connecting the two. If no link exists then it reports nobody. If more than one such link exists, reports a random one. You can think of this as \"give me a link that I can use to travel from turtle to the caller.\" crt 2 ask turtle 0 [ create-link-to turtle 1 ] ask turtle 1 [ show in-link-from turtle 0 ] ;; shows link 0 1 ask turtle 0 [ show in-link-from turtle 1 ] ;; shows nobody See also: out-link-to link-with"
      ],
      "132": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: includes \n\nEntry Data: includes\nusage: __includes [ filename ... ] \n Causes external NetLogo source files (with the .nls suffix) to be included in this model. Included files may contain breed, variable, and procedure definitions. __includes can only be used once per file. The file names must be strings, for example: __includes [ \"utils.nls\" ] Or, for multiple files: __includes [ \"utils1.nls\" \"utils2.nls\" ]"
      ],
      "133": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: in-radius \n\nEntry Data: in-radius\nusage: agentset in-radius number \n Reports an agentset that includes only those agents from the original agentset whose distance from the caller is less than or equal to number. (This can include the agent itself.) The distance to or a from a patch is measured from the center of the patch. ask turtles [ ask patches in-radius 3 [ set pcolor red ] ] ;; each turtle makes a red \"splotch\" around itself"
      ],
      "134": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: insert-item \n\nEntry Data: insert-item\nusage: [('class', 'prim_example')]insert-item index string1 string2 \n On a list, inserts an item in that list. index is the index where the item will be inserted. The first item has an index of 0. (The 6th item in a list would have an index of 5.) Likewise for a string, but all characters in a multiple-character string2 are inserted at index. show insert-item 2 [2 7 4 5] 15 => [2 7 15 4 5] show insert-item 2 \"cat\" \"re\" => \"caret\""
      ],
      "135": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: inspect \n\nEntry Data: inspect\nusage: inspect agent \n Opens an agent monitor for the given agent (turtle or patch or link). inspect patch 2 4 ;; an agent monitor opens for that patch inspect one-of sheep ;; an agent monitor opens for a random turtle from ;; the \"sheep\" breed inspect one-of links ;; an agent monitor opens for a random link See stop-inspecting and stop-inspecting-dead-agents"
      ],
      "136": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: int \n\nEntry Data: int\nusage: int number \n Reports the integer part of number -- any fractional part is discarded. show int 4.7 => 4 show int -3.5 => -3"
      ],
      "137": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: is-of-type \n\nEntry Data: is-of-type\nusage: [('class', 'prim_example')][('class', 'prim_example')][('class', 'prim_example')][('class', 'prim_example')][('class', 'prim_example')][('class', 'prim_example')][('class', 'prim_example')][('class', 'prim_example')][('class', 'prim_example')][('class', 'prim_example')][('class', 'prim_example')][('class', 'prim_example')][('class', 'prim_example')][('class', 'prim_example')][('class', 'prim_example')][('class', 'prim_example')][('class', 'prim_example')]is-undirected-link? value \n Reports true if value is of the given type, false otherwise."
      ],
      "138": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: item \n\nEntry Data: item\nusage: [('class', 'prim_example')]item index string \n On lists, reports the value of the item in the given list with the given index. On strings, reports the character in the given string at the given index. Note that the indices begin from 0, not 1. (The first item is item 0, the second item is item 1, and so on.) If index is fractional, it will be rounded down to the nearest integer (4.5 becomes 4, 10.9 becomes 10). ;; suppose mylist is [2 4 6 8 10] show item 2 mylist => 6 show item 3 \"my-shoe\" => \"s\""
      ],
      "139": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: jump \n\nEntry Data: jump\nusage: jump number \n The turtle moves forward by number units all at once (rather than one step at a time as with the forward command). If the turtle cannot jump number units because it is not permitted by the current topology the turtle does not move at all. See also forward, can-move?."
      ],
      "140": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: label \n\nEntry Data: label\nusage: label \n This is a built-in turtle or link variable. It may hold a value of any type. The turtle or link appears in the view with the given value \"attached\" to it as text. You can set this variable to add, change, or remove a turtle or link's label. See also label-color, plabel, plabel-color. Example: ask turtles [ set label who ] ;; all the turtles now are labeled with their ;; who numbers ask turtles [ set label \"\" ] ;; all turtles now are not labeled"
      ],
      "141": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: label-color \n\nEntry Data: label-color\nusage: label-color \n This is a built-in turtle or link variable. It holds a number greater than or equal to 0 and less than 140. This number determines what color the turtle or link's label appears in (if it has a label). You can set this variable to change the color of a turtle or link's label. See also label, plabel, plabel-color. Example: ask turtles [ set label-color red ] ;; all the turtles now have red labels"
      ],
      "142": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: last \n\nEntry Data: last\nusage: [('class', 'prim_example')]last string \n On a list, reports the last item in the list. On a string, reports a one-character string containing only the last character of the original string."
      ],
      "143": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: layout-circle \n\nEntry Data: layout-circle\nusage: [('class', 'prim_example')]layout-circle list-of-turtles radius \n Arranges the given turtles in a circle centered on the patch at the center of the world with the given radius. (If the world has an even size the center of the circle is rounded down to the nearest patch.) The turtles point outwards. If the first input is an agentset, the turtles are arranged in random order. If the first input is a list, the turtles are arranged clockwise in the given order, starting at the top of the circle. (Any non-turtles in the list are ignored.) ;; in random order layout-circle turtles 10 ;; in order by who number layout-circle sort turtles 10 ;; in order by size layout-circle sort-by [ [a b] -> [size] of a < [size] of b ] turtles 10"
      ],
      "144": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: layout-radial \n\nEntry Data: layout-radial\nusage: layout-radial turtle-set link-set root-agent \n Arranges the turtles in turtle-set connected by links in link-set, in a radial tree layout, centered around the root-agent which is moved to the center of the world view. Only links in the link-set will be used to determine the layout. If links connect turtles that are not in turtle-set those turtles will remain stationary. Even if the network does contain cycles, and is not a true tree structure, this layout will still work, although the results will not always be pretty. to make-a-tree set-default-shape turtles \"circle\" crt 6 ask turtle 0 [ create-link-with turtle 1 create-link-with turtle 2 create-link-with turtle 3 ] ask turtle 1 [ create-link-with turtle 4 create-link-with turtle 5 ] ; do a radial tree layout, centered on turtle 0 layout-radial turtles links (turtle 0) end"
      ],
      "145": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: layout-spring \n\nEntry Data: layout-spring\nusage: layout-spring turtle-set link-set spring-constant spring-length repulsion-constant \n Arranges the turtles in turtle-set, as if the links in link-set are springs and the turtles are repelling each other. Turtles that are connected by links in link-set but not included in turtle-set are treated as anchors and are not moved. spring-constant is a measure of the \"tautness\" of the spring. It is the \"resistance\" to change in their length. spring-constant is the force the spring would exert if it's length were changed by 1 unit. spring-length is the \"zero-force\" length or the natural length of the springs. This is the length which all springs try to achieve either by pushing out their nodes or pulling them in. repulsion-constant is a measure of repulsion between the nodes. It is the force that 2 nodes at a distance of 1 unit will exert on each other. The repulsion effect tries to get the nodes as far as possible from each other, in order to avoid crowding and the spring effect tries to keep them at \"about\" a certain distance from the nodes they are connected to. The result is the laying out of the whole network in a way which highlights relationships among the nodes and at the same time is crowded less and is visually pleasing. The layout algorithm is based on the Fruchterman-Reingold layout algorithm. More information about this algorithm can be obtained here. to make-a-triangle set-default-shape turtles \"circle\" crt 3 ask turtle 0 [ create-links-with other turtles ] ask turtle 1 [ create-link-with turtle 2 ] repeat 30 [ layout-spring turtles links 0.2 5 1 ] ;; lays the nodes in a triangle end"
      ],
      "146": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: layout-tutte \n\nEntry Data: layout-tutte\nusage: layout-tutte turtle-set link-set radius \n The turtles that are connected by links in link-set but not included in turtle-set are placed in a circle layout with the given radius. There should be at least 3 agents in this agentset. The turtles in turtle-set are then laid out in the following manner: Each turtle is placed at centroid (or barycenter) of the polygon formed by its linked neighbors. (The centroid is like a 2-dimensional average of the coordinates of the neighbors.) (The purpose of the circle of \"anchor agents\" is to prevent all the turtles from collapsing down to one point.) After a few iterations of this, the layout will stabilize. This layout is named after the mathematician William Thomas Tutte, who proposed it as a method for graph layout. to make-a-tree set-default-shape turtles \"circle\" crt 8 ask turtle 0 [ create-link-with turtle 1 create-link-with turtle 2 create-link-with turtle 3 ] ask turtle 1 [ create-link-with turtle 4 create-link-with turtle 5 create-link-with turtle 6 create-link-with turtle 7 ] ; place all the turtles with just one ; neighbor on the perimeter of a circle ; and then place the remaining turtles inside ; this circle, spread between their neighbors. repeat 10 [ layout-tutte (turtles with [count link-neighbors > 1]) links 8 ] end"
      ],
      "147": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: left \n\nEntry Data: left\nusage: left number \n The turtle turns left by number degrees. (If number is negative, it turns right.)"
      ],
      "148": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: length \n\nEntry Data: length\nusage: [('class', 'prim_example')]length string \n Reports the number of items in the given list, or the number of characters in the given string."
      ],
      "149": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: let \n\nEntry Data: let\nusage: let variable value \n Creates a new local variable and gives it the given value. A local variable is one that exists only within the enclosing block of commands. If you want to change the value afterwards, use set. Example: let prey one-of sheep-here if prey != nobody [ ask prey [ die ] ] You can also create multiple local variables if you put the variable names in a list format. The values for the new variables will be taken from the list given as the second argument. This can be particular useful when you want to calculate multiple values in a reporter procedure, as you can easily create multiple variables with the results. A runtime error will occur if you do not give a list of values or the list you provide doesn't have enough values for all the variables. let [x y z] [10 15 20] show x ; prints 10 show y ; prints 15 show z ; prints 20 let [a b c] [10] ; causes a runtime error as we need at least 3 values in the list"
      ],
      "150": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: link \n\nEntry Data: link\nusage: [('class', 'prim_example')]<breed> end1 end2 \n Given the who numbers of the endpoints, reports the link connecting the turtles. If there is no such link reports nobody. To refer to breeded links you must use the singular breed form with the endpoints. ask link 0 1 [ set color green ] ;; unbreeded link connecting turtle 0 and turtle 1 will turn green ask directed-link 0 1 [ set color red ] ;; directed link connecting turtle 0 and turtle 1 will turn red See also patch-at."
      ],
      "151": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: link-heading \n\nEntry Data: link-heading\nusage: link-heading \n Reports the heading in degrees (at least 0, less than 360) from end1 to end2 of the link. Throws a runtime error if the endpoints are at the same location. ask link 0 1 [ print link-heading ] ;; prints [[towards other-end] of end1] of link 0 1 See also link-length"
      ],
      "152": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: link-length \n\nEntry Data: link-length\nusage: link-length \n Reports the distance between the endpoints of the link. ask link 0 1 [ print link-length ] ;; prints [[distance other-end] of end1] of link 0 1 See also link-heading"
      ],
      "153": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: link-set \n\nEntry Data: link-set\nusage: [('class', 'prim_example')](link-set value1 value2 ...) \n Reports an agentset containing all of the links anywhere in any of the inputs. The inputs may be individual links, link agentsets, nobody, or lists (or nested lists) containing any of the above. link-set self link-set [my-links] of nodes with [color = red] See also turtle-set, patch-set."
      ],
      "154": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: link-shapes \n\nEntry Data: link-shapes\nusage: link-shapes \n Reports a list of strings containing all of the link shapes in the model. New shapes can be created, or imported from other models, in the Link Shapes Editor. show link-shapes => [\"default\"]"
      ],
      "155": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: links \n\nEntry Data: links\nusage: links \n Reports the agentset consisting of all links. This is a special agentset that can grow as links are added to the world, see the programming guide for more info. show count links ;; prints the number of links"
      ],
      "156": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: links-own \n\nEntry Data: links-own\nusage: [('class', 'prim_example')]<link-breeds>-own [var1 ...] \n The links-own keyword, like the globals, breed, <breeds>-own, turtles-own, and patches-own keywords, can only be used at the beginning of a program, before any function definitions. It defines the variables belonging to each link. If you specify a breed instead of \"links\", only links of that breed have the listed variables. (More than one link breed may list the same variable.) undirected-link-breed [sidewalks sidewalk] directed-link-breed [streets street] links-own [traffic] ;; applies to all breeds sidewalks-own [pedestrians] streets-own [cars bikes]"
      ],
      "157": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: list \n\nEntry Data: list\nusage: [('class', 'prim_example')](list value1 ...) \n Reports a list containing the given items. The items can be of any type, produced by any kind of reporter. show list (random 10) (random 10) => [4 9] ;; or similar list show (list 5) => [5] show (list (random 10) 1 2 3 (random 10)) => [4 1 2 3 9] ;; or similar list"
      ],
      "158": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: ln \n\nEntry Data: ln\nusage: ln number \n Reports the natural logarithm of number, that is, the logarithm to the base e (2.71828...). See also e, log."
      ],
      "159": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: log \n\nEntry Data: log\nusage: log number base \n Reports the logarithm of number in base base. show log 64 2 => 6 See also ln."
      ],
      "160": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: loop \n\nEntry Data: loop\nusage: loop [ commands ] \n Repeats the commands forever, or until the enclosing procedure exits through use of the stop or report commands. to move-to-world-edge ;; turtle procedure loop [ if not can-move? 1 [ stop ] fd 1 ] end In this example, stop exits not just the loop, but the entire procedure. Note: in many circumstances, it is more appropriate to use a forever button to repeat something indefinitely. See Buttons in the Programming Guide."
      ],
      "161": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: lput \n\nEntry Data: lput\nusage: lput value list \n Adds value to the end of a list and reports the new list. ;; suppose mylist is [2 7 10 \"Bob\"] set mylist lput 42 mylist ;; mylist now is [2 7 10 \"Bob\" 42]"
      ],
      "162": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: map \n\nEntry Data: map\nusage: [('class', 'prim_example')](map reporter list1 ...) \n With a single list, the given reporter is run for each item in the list, and a list of the results is collected and reported. reporter may be an anonymous reporter or the name of a reporter. show map round [1.1 2.2 2.7] => [1 2 3] show map [ i -> i * i ] [1 2 3] => [1 4 9] With multiple lists, the given reporter is run for each group of items from each list. So, it is run once for the first items, once for the second items, and so on. All the lists must be the same length. Some examples make this clearer: show (map + [1 2 3] [2 4 6]) => [3 6 9] show (map [ [a b c] -> a + b = c ] [1 2 3] [2 4 6] [3 5 9]) => [true false true] See also foreach, -> (anonymous procedure)."
      ],
      "163": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: max \n\nEntry Data: max\nusage: max list \n Reports the maximum number value in the list. It ignores other types of items. show max [xcor] of turtles ;; prints the x coordinate of the turtle which is ;; farthest right in the world show max list a b ;; prints the larger of the two variables a and b show max (list a b c) ;; prints the largest of the three variables a, b, and c"
      ],
      "164": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: max-n-of \n\nEntry Data: max-n-of\nusage: max-n-of number agentset [reporter] \n Reports an agentset containing number agents from agentset with the highest values of reporter. The agentset is built by finding all the agents with the highest value of reporter, if there are not number agents with that value then agents with the second highest value are found, and so on. At the end, if there is a tie that would make the resulting agentset too large, the tie is broken randomly. ;; assume the world is 11 x 11 show max-n-of 5 patches [pxcor] ;; shows 5 patches with pxcor = max-pxcor show max-n-of 5 patches with [pycor = 0] [pxcor] ;; shows an agentset containing: ;; (patch 1 0) (patch 2 0) (patch 3 0) (patch 4 0) (patch 5 0) See also max-one-of, with-max."
      ],
      "165": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: max-one-of \n\nEntry Data: max-one-of\nusage: max-one-of agentset [reporter] \n Reports the agent in the agentset that has the highest value for the given reporter. If there is a tie this command reports one random agent with the highest value. If you want all such agents, use with-max instead. show max-one-of patches [count turtles-here] ;; prints the first patch with the most turtles on it See also max-n-of, with-max."
      ],
      "166": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: max-pcor \n\nEntry Data: max-pcor\nusage: [('class', 'prim_example')]max-pycor \n These reporters give the maximum x-coordinate and maximum y-coordinate, (respectively) for patches, which determines the size of the world. Unlike in older versions of NetLogo the origin does not have to be at the center of the world. However, the maximum x- and y- coordinates must be greater than or equal to zero. Note: You can set the size of the world by editing the view or using resize-world. crt 100 [ setxy random-float max-pxcor random-float max-pycor ] ;; distributes 100 turtles randomly in the ;; first quadrant See also min-pxcor, min-pycor, world-width, and world-height"
      ],
      "167": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: mean \n\nEntry Data: mean\nusage: mean list \n Reports the statistical mean of the numeric items in the given list. Ignores non-numeric items. The mean is the average, i.e., the sum of the items divided by the total number of items. In NetLogo 6.1.1 and earlier, mean would error when finding non-number values in the given list. show mean [xcor] of turtles ;; prints the average of all the turtles' x coordinates See this FAQ question for information on possible issues using mean with agentsets"
      ],
      "168": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: median \n\nEntry Data: median\nusage: median list \n Reports the statistical median of the numeric items of the given list. Ignores non-numeric items. The median is the item that would be in the middle if all the items were arranged in order. (If two items would be in the middle, the median is the average of the two.) show median [xcor] of turtles ;; prints the median of all the turtles' x coordinates"
      ],
      "169": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: member \n\nEntry Data: member\nusage: [('class', 'prim_example')][('class', 'prim_example')]member? agent agentset \n For a list, reports true if the given value appears in the given list, otherwise reports false. For a string, reports true or false depending on whether string1 appears anywhere inside string2 as a substring. For an agentset, reports true if the given agent is appears in the given agentset, otherwise reports false. show member? 2 [1 2 3] => true show member? 4 [1 2 3] => false show member? \"bat\" \"abate\" => true show member? turtle 0 turtles => true show member? turtle 0 patches => false See also position."
      ],
      "170": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: min \n\nEntry Data: min\nusage: min list \n Reports the minimum number value in the list. It ignores other types of items. show min [xcor] of turtles ;; prints the lowest x-coordinate of all the turtles show min list a b ;; prints the smaller of the two variables a and b show min (list a b c) ;; prints the smallest of the three variables a, b, and c"
      ],
      "171": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: min-n-of \n\nEntry Data: min-n-of\nusage: min-n-of number agentset [reporter] \n Reports an agentset containing number agents from agentset with the lowest values of reporter. The agentset is built by finding all the agents with the lowest value of reporter, if there are not number agents with that value then the agents with the second lowest value are found, and so on. At the end, if there is a tie that would make the resulting agentset too large, the tie is broken randomly. ;; assume the world is 11 x 11 show min-n-of 5 patches [pxcor] ;; shows 5 patches with pxcor = min-pxcor show min-n-of 5 patches with [pycor = 0] [pxcor] ;; shows an agentset containing: ;; (patch -5 0) (patch -4 0) (patch -3 0) (patch -2 0) (patch -1 0) See also min-one-of, with-min."
      ],
      "172": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: min-one-of \n\nEntry Data: min-one-of\nusage: min-one-of agentset [reporter] \n Reports a random agent in the agentset that reports the lowest value for the given reporter. If there is a tie, this command reports one random agent that meets the condition. If you want all such agents use with-min instead. show min-one-of turtles [xcor + ycor] ;; reports the first turtle with the smallest sum of ;; coordinates See also with-min, min-n-of."
      ],
      "173": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: min-pcor \n\nEntry Data: min-pcor\nusage: [('class', 'prim_example')]min-pycor \n These reporters give the minimum x-coordinate and minimum y-coordinate, (respectively) for patches, which determines the size of the world. Unlike in older versions of NetLogo the origin does not have to be at the center of the world. However, the minimum x- and y- coordinates must be less than or equal to zero. Note: You can set the size of the world by editing the view or using resize-world. crt 100 [ setxy random-float min-pxcor random-float min-pycor ] ;; distributes 100 turtles randomly in the ;; third quadrant See also max-pxcor, max-pycor, world-width, and world-height"
      ],
      "174": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: mod \n\nEntry Data: mod\nusage: number1 mod number2 \n Reports number1 modulo number2: that is, the residue of number1 (mod number2). mod is is equivalent to the following NetLogo code: number1 - (floor (number1 / number2)) * number2 Note that mod is \"infix\", that is, it comes between its two inputs. show 62 mod 5 => 2 show -8 mod 3 => 1 See also remainder. mod and remainder behave the same for positive numbers, but differently for negative numbers."
      ],
      "175": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: modes \n\nEntry Data: modes\nusage: modes list \n Reports a list of the most common item or items in list. The input list may contain any NetLogo values. If the input is an empty list, reports an empty list. show modes [1 2 2 3 4] => [2] show modes [1 2 2 3 3 4] => [2 3] show modes [ [1 2 [3]] [1 2 [3]] [2 3 4] ] => [[1 2 [3]]] show modes [pxcor] of turtles ;; shows which columns of patches have the most ;; turtles on them"
      ],
      "176": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: mouse-down \n\nEntry Data: mouse-down\nusage: mouse-down? \n Reports true if the mouse button is down, false otherwise. Note: If the mouse pointer is outside of the current view , mouse-down? will always report false."
      ],
      "177": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: mouse-inside \n\nEntry Data: mouse-inside\nusage: mouse-inside? \n Reports true if the mouse pointer is inside the world boundaries inside the current view, false otherwise. In the case of an unwrapped world and using follow on an agent, It's possible for the mouse pointer to be inside the view but not inside the world boundaries."
      ],
      "178": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: mouse-cor \n\nEntry Data: mouse-cor\nusage: [('class', 'prim_example')]mouse-ycor \n Reports the x or y coordinate of the mouse in the 2D view. The value is in terms of turtle coordinates, so it might not be an integer. If you want patch coordinates, use round mouse-xcor and round mouse-ycor. Note: If the mouse is outside of the 2D view, reports the value from the last time it was inside. ;; to make the mouse \"draw\" in red: if mouse-down? [ ask patch mouse-xcor mouse-ycor [ set pcolor red ] ]"
      ],
      "179": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: move-to \n\nEntry Data: move-to\nusage: move-to agent \n The turtle sets its x and y coordinates to be the same as the given agent's. (If that agent is a patch, the effect is to move the turtle to the center of that patch.) move-to turtle 5 ;; turtle moves to same point as turtle 5 move-to one-of patches ;; turtle moves to the center of a random patch move-to max-one-of turtles [size] ;; turtle moves to same point as biggest turtle Note that the turtle's heading is unaltered. You may want to use the face command first to orient the turtle in the direction of motion. See also setxy."
      ],
      "180": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: my-links \n\nEntry Data: my-links\nusage: [('class', 'prim_example')]my-links \n Reports an agentset of all links connected to the caller of the corresponding breed, regardless of directedness. Generally, you might consider using my-out-links instead of this primitive, as it works well for either directed or undirected networks (since it excludes directed, incoming links). crt 5 ask turtle 0 [ create-links-with other turtles show my-links ;; prints the agentset containing all links ;; (since all the links we created were with turtle 0 ) ] ask turtle 1 [ show my-links ;; shows an agentset containing the link 0 1 ] end If you only want the undirected links connected to a node, you can do my-links with [ not is-directed-link? self ]."
      ],
      "181": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: my-in-links \n\nEntry Data: my-in-links\nusage: [('class', 'prim_example')]my-in-links \n Reports an agentset of all the directed links coming in from other nodes to the caller as well as all undirected links connected to the caller. You can think of this as \"all links that you can use to travel to this node\". crt 5 ask turtle 0 [ create-links-to other turtles show my-in-links ;; shows an empty agentset ] ask turtle 1 [ show my-in-links ;; shows an agentset containing the link 0 1 ]"
      ],
      "182": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: my-out-links \n\nEntry Data: my-out-links\nusage: [('class', 'prim_example')]my-out-links \n Reports an agentset of all the directed links going out from the caller to other nodes as well as undirected links connected to the caller. You can think of this as \"all links you can use to travel from this node\". crt 5 ask turtle 0 [ create-links-to other turtles show my-out-links ;; shows agentset containing all the links ] ask turtle 1 [ show my-out-links ;; shows an empty agentset ]"
      ],
      "183": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: myself \n\nEntry Data: myself\nusage: myself \n \"self\" and \"myself\" are very different. \"self\" is simple; it means \"me\". \"myself\" means \"the turtle, patch or link who asked me to do what I'm doing right now.\" When an agent has been asked to run some code, using myself in that code reports the agent (turtle, patch or link) that did the asking. myself is most often used in conjunction with of to read or set variables in the asking agent. myself can be used within blocks of code not just in the ask command, but also hatch, sprout, of, with, all?, with-min, with-max, min-one-of, max-one-of, min-n-of, max-n-of. ask turtles [ ask patches in-radius 3 [ set pcolor [color] of myself ] ] ;; each turtle makes a colored \"splotch\" around itself See the \"Myself Example\" code example for more examples. See also self."
      ],
      "184": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: n-of \n\nEntry Data: n-of\nusage: [('class', 'prim_example')]n-of size list \n From an agentset, reports an agentset of size size randomly chosen from the input set, with no repeats. From a list, reports a list of size size randomly chosen from the input set, with no repeats. The items in the result appear in the same order that they appeared in the input list. (If you want them in random order, use shuffle on the result.) It is an error for size to be greater than the size of the input. If size is fractional, it will be rounded down to the nearest integer (4.5 becomes 4, 10.9 becomes 10). ask n-of 50 patches [ set pcolor green ] ;; 50 randomly chosen patches turn green See also one-of and up-to-n-of, a version that does not error with a size greater than the size of the input."
      ],
      "185": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: n-values \n\nEntry Data: n-values\nusage: n-values size reporter \n Reports a list of length size containing values computed by repeatedly running the reporter. reporter may be an anonymous reporter or the name of a reporter. If the reporter accepts inputs, the input will be the number of the item currently being computed, starting from zero. If size is fractional, it will be rounded down to the nearest integer (4.5 becomes 4, 10.9 becomes 10). show n-values 5 [1] => [1 1 1 1 1] show n-values 5 [ i -> i ] => [0 1 2 3 4] show n-values 3 turtle => [(turtle 0) (turtle 1) (turtle 2)] show n-values 5 [ x -> x * x ] => [0 1 4 9 16] See also reduce, filter, -> (anonymous procedure), range."
      ],
      "186": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: neighbors \n\nEntry Data: neighbors\nusage: [('class', 'prim_example')]neighbors4 \n Reports an agentset containing the 8 surrounding patches (neighbors) or 4 surrounding patches (neighbors4). show sum [count turtles-here] of neighbors ;; prints the total number of turtles on the eight ;; patches around this turtle or patch show count turtles-on neighbors ;; a shorter way to say the same thing ask neighbors4 [ set pcolor red ] ;; turns the four neighboring patches red"
      ],
      "187": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: link-neighbors \n\nEntry Data: link-neighbors\nusage: [('class', 'prim_example')]link-neighbors \n Reports the agentset of all turtles found at the other end of any links (undirected or directed, incoming or outgoing) connected to this turtle. crt 3 ask turtle 0 [ create-links-with other turtles ask link-neighbors [ set color red ] ;; turtles 1 and 2 turn red ] ask turtle 1 [ ask link-neighbors [ set color blue ] ;; turtle 0 turns blue ] end"
      ],
      "188": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: link-neighbor \n\nEntry Data: link-neighbor\nusage: [('class', 'prim_example')]link-neighbor? turtle \n Reports true if there is a link (either directed or undirected, incoming or outgoing) between turtle and the caller. crt 2 ask turtle 0 [ create-link-with turtle 1 show link-neighbor? turtle 1 ;; prints true ] ask turtle 1 [ show link-neighbor? turtle 0 ;; prints true ]"
      ],
      "189": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: netlogo-version \n\nEntry Data: netlogo-version\nusage: netlogo-version \n Reports a string containing the version number of the NetLogo you are running. show netlogo-version => \"6.4.0\""
      ],
      "190": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: netlogo-web \n\nEntry Data: netlogo-web\nusage: netlogo-web? \n Reports true if the model is running in NetLogo Web."
      ],
      "191": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: new-seed \n\nEntry Data: new-seed\nusage: new-seed \n Reports a number suitable for seeding the random number generator. The numbers reported by new-seed are based on the current date and time in milliseconds and lie in the generator's usable range of seeds, -2147483648 to 2147483647. new-seed never reports the same number twice in succession, even across parallel BehaviorSpace runs. (This is accomplished by waiting a millisecond if the seed for the current millisecond was already used.) See also random-seed."
      ],
      "192": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: no-display \n\nEntry Data: no-display\nusage: no-display \n Turns off all updates to the current view until the display command is issued. This has two major uses. One, you can control when the user sees view updates. You might want to change lots of things on the view behind the user's back, so to speak, then make them visible to the user all at once. Two, your model will run faster when view updating is off, so if you're in a hurry, this command will let you get results faster. (Note that normally you don't need to use no-display for this, since you can also use the on/off switch in view control strip to freeze the view.) Note that display and no-display operate independently of the switch in the view control strip that freezes the view. See also display."
      ],
      "193": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: nobody \n\nEntry Data: nobody\nusage: nobody \n This is a special value which some primitives such as turtle, one-of, max-one-of, etc. report to indicate that no agent was found. Also, when a turtle dies, it becomes equal to nobody. Note: Empty agentsets are not equal to nobody. If you want to test for an empty agentset, use any?. You only get nobody back in situations where you were expecting a single agent, not a whole agentset. set target one-of other turtles-here if target != nobody [ ask target [ set color red ] ]"
      ],
      "194": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: no-links \n\nEntry Data: no-links\nusage: no-links \n Reports an empty link agentset."
      ],
      "195": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: no-patches \n\nEntry Data: no-patches\nusage: no-patches \n Reports an empty patch agentset."
      ],
      "196": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: not \n\nEntry Data: not\nusage: not boolean \n Reports true if boolean is false, otherwise reports false. if not any? turtles [ crt 10 ]"
      ],
      "197": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: no-turtles \n\nEntry Data: no-turtles\nusage: no-turtles \n Reports an empty turtle agentset."
      ],
      "198": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: of \n\nEntry Data: of\nusage: [('class', 'prim_example')][reporter] of agentset \n For an agent, reports the value of the reporter for that agent (turtle or patch). show [pxcor] of patch 3 5 ;; prints 3 show [pxcor] of one-of patches ;; prints the value of a random patch's pxcor variable show [who * who] of turtle 5 => 25 show [count turtles in-radius 3] of patch 0 0 ;; prints the number of turtles located within a ;; three-patch radius of the origin For an agentset, reports a list that contains the value of the reporter for each agent in the agentset (in random order). crt 4 show sort [who] of turtles => [0 1 2 3] show sort [who * who] of turtles => [0 1 4 9]"
      ],
      "199": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: one-of \n\nEntry Data: one-of\nusage: [('class', 'prim_example')]one-of list \n From an agentset, reports a random agent. If the agentset is empty, reports nobody. From a list, reports a random list item. It is an error for the list to be empty. ask one-of patches [ set pcolor green ] ;; a random patch turns green ask patches with [any? turtles-here] [ show one-of turtles-here ] ;; for each patch containing turtles, prints one of ;; those turtles ;; suppose mylist is [1 2 3 4 5 6] show one-of mylist ;; prints a value randomly chosen from the list See also n-of, up-to-n-of."
      ],
      "200": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: or \n\nEntry Data: or\nusage: boolean1 or boolean2 \n Reports true if boolean1 is true, boolean2 is true, or both are true. Otherwise returns false if both booleans are false. Note that if boolean1 is true, then boolean2 will not be run (since it can't affect the result). See the programming guide for more information on logical operator precedence. if (pxcor > 0) or (pycor > 0) [ set pcolor red ] ;; patches turn red except in lower-left quadrant"
      ],
      "201": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: other \n\nEntry Data: other\nusage: other agentset \n Reports an agentset which is the same as the input agentset but omits this agent. show count turtles-here => 10 show count other turtles-here => 9"
      ],
      "202": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: other-end \n\nEntry Data: other-end\nusage: other-end \n If run by a turtle, reports the turtle at the other end of the asking link. If run by a link, reports the turtle at the end of the link that isn't the asking turtle. These definitions are difficult to understand in the abstract, but the following examples should help: ask turtle 0 [ create-link-with turtle 1 ] ask turtle 0 [ ask link 0 1 [ show other-end ] ] ;; prints turtle 1 ask turtle 1 [ ask link 0 1 [ show other-end ] ] ;; prints turtle 0 ask link 0 1 [ ask turtle 0 [ show other-end ] ] ;; prints turtle 1 As these examples hopefully make plain, the \"other\" end is the end that is neither asking nor being asked."
      ],
      "203": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: out-link-neighbor \n\nEntry Data: out-link-neighbor\nusage: [('class', 'prim_example')]out-link-neighbor? turtle \n Reports true if there is a directed link going from the caller to turtle or if there is an undirected link connecting the caller with turtle. You can think of this as \"can I get from the caller to turtle using a link?\" crt 2 ask turtle 0 [ create-link-to turtle 1 show in-link-neighbor? turtle 1 ;; prints false show out-link-neighbor? turtle 1 ;; prints true ] ask turtle 1 [ show in-link-neighbor? turtle 0 ;; prints true show out-link-neighbor? turtle 0 ;; prints false ]"
      ],
      "204": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: out-link-neighbors \n\nEntry Data: out-link-neighbors\nusage: [('class', 'prim_example')]out-link-neighbors \n Reports the agentset of all the turtles that have directed links from the caller, or undirected links with the caller. You can think of this as \"who can I get to from the caller using a link?\" crt 4 ask turtle 0 [ create-links-to other turtles ask out-link-neighbors [ set color pink ] ;; turtles 1-3 turn pink ] ask turtle 1 [ ask out-link-neighbors [ set color orange ] ;; no turtles change colors ;; since turtle 1 only has in-links ] end"
      ],
      "205": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: out-link-to \n\nEntry Data: out-link-to\nusage: [('class', 'prim_example')]out-link-to turtle \n Reports a directed link from the caller to turtle or an undirected link connecting the two. If no link exists then it reports nobody. If more than one such link exists, reports a random one. You can think of this as \"give me a link that I can use to travel from the caller to turtle.\" crt 2 ask turtle 0 [ create-link-to turtle 1 show out-link-to turtle 1 ;; shows link 0 1 ] ask turtle 1 [ show out-link-to turtle 0 ;; shows nobody ] See also: in-link-from link-with"
      ],
      "206": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: output-cmds \n\nEntry Data: output-cmds\nusage: [('class', 'prim_example')][('class', 'prim_example')][('class', 'prim_example')]output-write value \n These commands are the same as the print, show, type, and write commands except that value is printed in the model's output area, instead of in the Command Center. (If the model does not have a separate output area, then the Command Center is used.) See also Output (programming guide)."
      ],
      "207": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: patch \n\nEntry Data: patch\nusage: patch xcor ycor \n Given the x and y coordinates of a point, reports the patch containing that point. (The coordinates are absolute coordinates; they are not computed relative to this agent, as with patch-at.) If x and y are integers, the point is the center of a patch. If x or y is not an integer, rounding to the nearest integer is used to determine which patch contains the point. If wrapping is allowed by the topology, the given coordinates will be wrapped to be within the world. If wrapping is not allowed and the given coordinates are outside the world, reports nobody. ask patch 3 -4 [ set pcolor green ] ;; patch with pxcor of 3 and pycor of -4 turns green show patch 1.2 3.7 ;; prints (patch 1 4); note rounding show patch 18 19 ;; supposing min-pxcor and min-pycor are -17 ;; and max-pxcor and max-pycor are 17, ;; in a wrapping topology, prints (patch -17 -16); ;; in a non-wrapping topology, prints nobody See also patch-at."
      ],
      "208": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: patch-ahead \n\nEntry Data: patch-ahead\nusage: patch-ahead distance \n Reports the single patch that is the given distance \"ahead\" of this turtle, that is, along the turtle's current heading. Reports nobody if the patch does not exist because it is outside the world. ask patch-ahead 1 [ set pcolor green ] ;; turns the patch 1 in front of this turtle ;; green; note that this might be the same patch ;; the turtle is standing on See also patch-at, patch-left-and-ahead, patch-right-and-ahead, patch-at-heading-and-distance."
      ],
      "209": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: patch-at \n\nEntry Data: patch-at\nusage: patch-at dx dy \n Reports the patch at (dx, dy) from the caller, that is, the patch containing the point dx east and dy patches north of this agent. Reports nobody if there is no such patch because that point is beyond a non-wrapping world boundary. ask patch-at 1 -1 [ set pcolor green ] ;; if caller is a turtle or patch, turns the ;; patch just southeast of the caller green See also patch, patch-ahead, patch-left-and-ahead, patch-right-and-ahead, patch-at-heading-and-distance."
      ],
      "210": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: patch-at-heading-and-distance \n\nEntry Data: patch-at-heading-and-distance\nusage: patch-at-heading-and-distance heading distance \n patch-at-heading-and-distance reports the single patch that is the given distance from this turtle or patch, along the given absolute heading. (In contrast to patch-left-and-ahead and patch-right-and-ahead, this turtle's current heading is not taken into account.) Reports nobody if the patch does not exist because it is outside the world. ask patch-at-heading-and-distance -90 1 [ set pcolor green ] ;; turns the patch 1 to the west of this patch green See also patch, patch-at, patch-left-and-ahead, patch-right-and-ahead."
      ],
      "211": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: patch-here \n\nEntry Data: patch-here\nusage: patch-here \n patch-here reports the patch under the turtle. Note that this reporter isn't available to a patch because a patch can just say \"self\"."
      ],
      "212": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: patch-lr-and-ahead \n\nEntry Data: patch-lr-and-ahead\nusage: [('class', 'prim_example')]patch-right-and-ahead angle distance \n Reports the single patch that is the given distance from this turtle, in the direction turned left or right the given angle (in degrees) from the turtle's current heading. Reports nobody if the patch does not exist because it is outside the world. (If you want to find a patch in a given absolute heading, rather than one relative to the current turtle's heading, use patch-at-heading-and-distance instead.) ask patch-right-and-ahead 30 1 [ set pcolor green ] ;; this turtle \"looks\" 30 degrees right of its ;; current heading at the patch 1 unit away, and turns ;; that patch green; note that this might be the same ;; patch the turtle is standing on See also patch, patch-at, patch-at-heading-and-distance."
      ],
      "213": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: patch-set \n\nEntry Data: patch-set\nusage: [('class', 'prim_example')](patch-set value1 value2 ...) \n Reports an agentset containing all of the patches anywhere in any of the inputs. The inputs may be individual patches, patch agentsets, nobody, or lists (or nested lists) containing any of the above. patch-set self patch-set patch-here (patch-set self neighbors) (patch-set patch-here neighbors) (patch-set patch 0 0 patch 1 3 patch 4 -2) (patch-set patch-at -1 1 patch-at 0 1 patch-at 1 1) patch-set [patch-here] of turtles patch-set [neighbors] of turtles See also turtle-set, link-set."
      ],
      "214": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: patch-size \n\nEntry Data: patch-size\nusage: patch-size \n Reports the size of the patches in the view in pixels. The size is typically an integer, but may also be a floating point number. See also set-patch-size."
      ],
      "215": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: patches \n\nEntry Data: patches\nusage: patches \n Reports the agentset consisting of all patches."
      ],
      "216": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: patches-own \n\nEntry Data: patches-own\nusage: patches-own [var1 ...] \n This keyword, like the globals, breed, <breed>-own, and turtles-own keywords, can only be used at the beginning of a program, before any function definitions. It defines the variables that all patches can use. All patches will then have the given variables and be able to use them. All patch variables can also be directly accessed by any turtle standing on the patch. See also globals, turtles-own, breed, <breeds>-own."
      ],
      "217": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: pcolor \n\nEntry Data: pcolor\nusage: pcolor \n This is a built-in patch variable. It holds the color of the patch. You can set this variable to make the patch change color. All patch variables can be directly accessed by any turtle standing on the patch. Color can be represented either as a NetLogo color (a single number) or an RGB color (a list of 3 numbers). See details in the Colors section of the Programming Guide. If you give an RGBA color with 4 numbers the transparency value will be ignored (except in NetLogo 3D). See also color."
      ],
      "218": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: pen-switch-status \n\nEntry Data: pen-switch-status\nusage: [('class', 'prim_example')][('class', 'prim_example')]pen-up \n The turtle changes modes between drawing lines, removing lines or neither. The lines will always be displayed on top of the patches and below the turtles. To change the color of the pen set the color of the turtle using set color. Note: When a turtle's pen is down, all movement commands cause lines to be drawn, including jump, setxy, and move-to. Note: These commands are equivalent to setting the turtle variable \"pen-mode\" to \"down\" , \"up\", and \"erase\". Note: On Windows drawing and erasing a line might not erase every pixel."
      ],
      "219": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: pen-mode \n\nEntry Data: pen-mode\npen-mode This is a built-in turtle variable. It holds the state of the turtle's pen. You set the variable to draw lines, erase lines or stop either of these actions. Possible values are \"up\", \"down\", and \"erase\"."
      ],
      "220": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: pen-size \n\nEntry Data: pen-size\npen-size This is a built-in turtle variable. It holds the width of the line, in pixels, that the turtle will draw (or erase) when the pen is down (or erasing)."
      ],
      "221": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: plabel \n\nEntry Data: plabel\nusage: plabel \n This is a built-in patch variable. It may hold a value of any type. The patch appears in the view with the given value \"attached\" to it as text. You can set this variable to add, change, or remove a patch's label. All patch variables can be directly accessed by any turtle standing on the patch. See also plabel-color, label, label-color."
      ],
      "222": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: plabel-color \n\nEntry Data: plabel-color\nusage: plabel-color \n This is a built-in patch variable. It holds a number greater than or equal to 0 and less than 140. This number determines what color the patch's label appears in (if it has a label). You can set this variable to change the color of a patch's label. All patch variables can be directly accessed by any turtle standing on the patch. See also plabel, label, label-color."
      ],
      "223": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: plot \n\nEntry Data: plot\nusage: plot number \n Increments the x-value of the plot pen by plot-pen-interval, then plots a point at the updated x-value and a y-value of number. (The first time the command is used on a plot, the point plotted has an x-value of 0.) This command will produce a runtime error if the current plot has not been set."
      ],
      "224": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: plot-name \n\nEntry Data: plot-name\nusage: plot-name \n Reports the name of the current plot (a string) This command will produce a runtime error if the current plot has not been set."
      ],
      "225": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: plot-pen-exists \n\nEntry Data: plot-pen-exists\nusage: plot-pen-exists? string \n Reports true if a plot pen with the given name is defined in the current plot. Otherwise reports false. This command will produce a runtime error if the current plot has not been set."
      ],
      "226": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: plot-pen-switch-status \n\nEntry Data: plot-pen-switch-status\nusage: [('class', 'prim_example')]plot-pen-up \n Puts down (or up) the current plot-pen, so that it draws (or doesn't). (By default, all pens are down initially.) These commands will produce a runtime error if either the current plot or the current pen has not been set."
      ],
      "227": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: plot-pen-reset \n\nEntry Data: plot-pen-reset\nusage: plot-pen-reset \n Clears everything the current plot pen has drawn, moves it to (0,0), and puts it down. If the pen is a permanent pen, the color, mode, and interval are reset to the default values from the plot Edit dialog. This command will produce a runtime error if either the current plot or the current pen has not been set."
      ],
      "228": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: plotxy \n\nEntry Data: plotxy\nusage: plotxy number1 number2 \n Moves the current plot pen to the point with coordinates (number1, number2). If the pen is down, a line, bar, or point will be drawn (depending on the pen's mode). This command will produce a runtime error if the current plot has not been set."
      ],
      "229": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: plot-cor-max-or-min \n\nEntry Data: plot-cor-max-or-min\nusage: [('class', 'prim_example')][('class', 'prim_example')][('class', 'prim_example')]plot-y-max \n Reports the minimum or maximum value on the x or y axis of the current plot. These values can be set with the commands set-plot-x-range and set-plot-y-range. (Their default values are set from the plot Edit dialog.) These commands will produce a runtime error if the current plot has not been set."
      ],
      "230": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: position \n\nEntry Data: position\nusage: [('class', 'prim_example')]position string1 string2 \n On a list, reports the first position of item in list, or false if it does not appear. On strings, reports the position of the first appearance string1 as a substring of string2, or false if it does not appear. Note: The positions are numbered beginning with 0, not with 1. ;; suppose mylist is [2 7 4 7 \"Bob\"] show position 7 mylist => 1 show position 10 mylist => false show position \"in\" \"string\" => 3 See also member?."
      ],
      "231": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: precision \n\nEntry Data: precision\nusage: precision number places \n Reports number rounded to places decimal places. If places is negative, the rounding takes place to the left of the decimal point. show precision 1.23456789 3 => 1.235 show precision 3834 -3 => 4000 See also round, ceiling, floor."
      ],
      "232": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: print \n\nEntry Data: print\nusage: print value \n Prints value in the Command Center, followed by a carriage return. This agent is not printed before the value, unlike show. See also show, type, write, output-print, and Output (programming guide)."
      ],
      "233": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: pcor \n\nEntry Data: pcor\nusage: [('class', 'prim_example')]pycor \n These are built-in patch variables. They hold the x and y coordinate of the patch. They are always integers. You cannot set these variables, because patches don't move. pxcor is greater than or equal to min-pxcor and less than or equal to max-pxcor; similarly for pycor and min-pycor and max-pycor. All patch variables can be directly accessed by any turtle standing on the patch. See also xcor, ycor."
      ],
      "234": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: random \n\nEntry Data: random\nusage: random number \n If number is positive, reports a random integer greater than or equal to 0, but strictly less than number. If number is negative, reports a random integer less than or equal to 0, but strictly greater than number. If number is zero, the result is always 0 as well. Note: In versions of NetLogo prior to version 2.0, this primitive reported a floating point number if given a non-integer input. This is no longer the case. If you want a floating point answer, you must now use random-float instead. show random 3 ;; prints 0, 1, or 2 show random -3 ;; prints 0, -1, or -2 show random 3.5 ;; prints 0, 1, 2, or 3 See also random-float."
      ],
      "235": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: random-float \n\nEntry Data: random-float\nusage: random-float number \n If number is positive, reports a random floating point number greater than or equal to 0 but strictly less than number. If number is negative, reports a random floating point number less than or equal to 0, but strictly greater than number. If number is zero, the result is always 0. show random-float 3 ;; prints a number at least 0 but less than 3, ;; for example 2.589444906014774 show random-float 2.5 ;; prints a number at least 0 but less than 2.5, ;; for example 1.0897423196760796"
      ],
      "236": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: random-reporters \n\nEntry Data: random-reporters\nusage: [('class', 'prim_example')][('class', 'prim_example')][('class', 'prim_example')]random-poisson mean \n Reports an accordingly distributed random number with the mean and, in the case of the normal distribution, the standard-deviation. (The standard deviation may not be negative.) random-exponential reports an exponentially distributed random floating point number. It is equivalent to (- mean) * ln random-float 1.0. random-gamma reports a gamma-distributed random floating point number as controlled by the floating point alpha and lambda parameters. Both inputs must be greater than zero. (Note: for results with a given mean and variance, use inputs as follows: alpha = mean * mean / variance; lambda = 1 / (variance / mean).) random-normal reports a normally distributed random floating point number. random-poisson reports a Poisson-distributed random integer. show random-exponential 2 ;; prints an exponentially distributed random floating ;; point number with a mean of 2 show random-normal 10.1 5.2 ;; prints a normally distributed random floating point ;; number with a mean of 10.1 and a standard deviation ;; of 5.2 show random-poisson 3.4 ;; prints a Poisson-distributed random integer with a ;; mean of 3.4"
      ],
      "237": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: random-pcor \n\nEntry Data: random-pcor\nusage: [('class', 'prim_example')]random-pycor \n Reports a random integer ranging from min-pxcor (or -y) to max-pxcor (or -y) inclusive. ask turtles [ ;; move each turtle to the center of a random patch setxy random-pxcor random-pycor ] See also random-xcor, random-ycor."
      ],
      "238": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: random-seed \n\nEntry Data: random-seed\nusage: random-seed number \n Sets the seed of the pseudo-random number generator to the integer part of number. The seed must be in the range -2147483648 to 2147483647; note that this is smaller than the full range of integers supported by NetLogo (-9007199254740992 to 9007199254740992). See the Random Numbers section of the Programming Guide for more details. random-seed 47822 show random 100 => 50 show random 100 => 35 random-seed 47822 show random 100 => 50 show random 100 => 35 See also the new-seed reporter that generates proper random seed values."
      ],
      "239": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: random-cor \n\nEntry Data: random-cor\nusage: [('class', 'prim_example')]random-ycor \n Reports a random floating point number from the allowable range of turtle coordinates along the given axis, x or y. Turtle coordinates range from min-pxcor - 0.5 (inclusive) to max-pxcor + 0.5 (exclusive) horizontally; vertically, substitute -y for -x. ask turtles [ ;; move each turtle to a random point setxy random-xcor random-ycor ] See also random-pxcor, random-pycor."
      ],
      "240": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: range \n\nEntry Data: range\nusage: [('class', 'prim_example')][('class', 'prim_example')](range start stop step) \n Generates a list of numbers, starting at start, ending before stop, counting by step. start defaults to 0 and step defaults to 1. show range 5 => [0 1 2 3 4] show (range 2 5) => [2 3 4] show (range 2 5 0.5) => [2 2.5 3 3.5 4 4.5] show (range 10 0 -1) => [10 9 8 7 6 5 4 3 2 1] See also n-values"
      ],
      "241": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: read-from-string \n\nEntry Data: read-from-string\nusage: read-from-string string \n Interprets the given string as if it had been typed in the Command Center, and reports the resulting value. The result may be a number, list, string, or boolean value, or the special value \"nobody\". Useful in conjunction with the user-input primitive for converting the user's input into usable form. show read-from-string \"3\" + read-from-string \"5\" => 8 show length read-from-string \"[1 2 3]\" => 3 crt read-from-string user-input \"Make how many turtles?\" ;; the number of turtles input by the user ;; are created Note: This primitive is not compatible with NetLogo Web. If you wish to read user input with the same code and the same behavior in both NetLogo and NetLogo Web, see dialog:user-input."
      ],
      "242": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: reduce \n\nEntry Data: reduce\nusage: reduce reporter list \n Reduces a list from left to right using the given reporter, resulting in a single value. This means, for example, that reduce [ [a b] -> a + b] [1 2 3 4] is equivalent to (((1 + 2) + 3) + 4). If list has a single item, that item is reported. It is an error to reduce an empty list. reporter may be an anonymous reporter or the name of a reporter. The first input passed to the reporter is the result so far, and the second input is the next item in the list. Since it can be difficult to develop an intuition about what reduce does, here are some simple examples which, while not useful in themselves, may give you a better understanding of this primitive: show reduce + [1 2 3] => 6 show reduce - [1 2 3] => -4 show reduce [ [result-so-far next-item] -> next-item - result-so-far ] [1 2 3] => 2 show reduce [ [result-so-far ignored-item] -> result-so-far ] [1 2 3] => 1 show reduce [ [ignored next-item] -> next-item ] [1 2 3] => 3 show reduce sentence [[1 2] [3 [4]] 5] => [1 2 3 [4] 5] show reduce [ [result-so-far next-item] -> fput next-item result-so-far ] (fput [] [1 2 3 4 5]) => [5 4 3 2 1] Here are some more useful examples: ;; find the longest string in a list to-report longest-string [strings] report reduce [ [longest-so-far next-string] -> ifelse-value (length longest-so-far >= length next-string) [longest-so-far] [next-string] ] strings end show longest-string [\"hi\" \"there\" \"!\"] => \"there\" ;; count the number of occurrences of an item in a list to-report occurrences [x the-list] report reduce [ [occurrence-count next-item] -> ifelse-value (next-item = x) [occurrence-count + 1] [occurrence-count] ] (fput 0 the-list) end show occurrences 1 [1 2 1 3 1 2 3 1 1 4 5 1] => 6 ;; evaluate the polynomial, with given coefficients, at x to-report evaluate-polynomial [coefficients x] report reduce [ [value coefficient] -> (x * value) + coefficient ] coefficients end ;; evaluate 3x^2 + 2x + 1 at x = 4 show evaluate-polynomial [3 2 1] 4 => 57 See also filter, -> (anonymous procedure."
      ],
      "243": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: remainder \n\nEntry Data: remainder\nusage: remainder number1 number2 \n Reports the remainder when number1 is divided by number2. This is equivalent to the following NetLogo code: number1 - (int (number1 / number2)) * number2 show remainder 62 5 => 2 show remainder -8 3 => -2 See also mod. mod and remainder behave the same for positive numbers, but differently for negative numbers."
      ],
      "244": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: remove \n\nEntry Data: remove\nusage: [('class', 'prim_example')]remove string1 string2 \n For a list, reports a copy of list with all instances of item removed. For strings, reports a copy of string2 with all the appearances of string1 as a substring removed. set mylist [2 7 4 7 \"Bob\"] set mylist remove 7 mylist ;; mylist is now [2 4 \"Bob\"] show remove \"to\" \"phototonic\" => \"phonic\""
      ],
      "245": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: remove-duplicates \n\nEntry Data: remove-duplicates\nusage: remove-duplicates list \n Reports a copy of list with all duplicate items removed. The first of each item remains in place. set mylist [2 7 4 7 \"Bob\" 7] set mylist remove-duplicates mylist ;; mylist is now [2 7 4 \"Bob\"]"
      ],
      "246": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: remove-item \n\nEntry Data: remove-item\nusage: [('class', 'prim_example')]remove-item index string \n For a list, reports a copy of list with the item at the given index removed. For strings, reports a copy of string with the character at the given index removed. Note that the indices begin from 0, not 1. (The first item is item 0, the second item is item 1, and so on.) If index is fractional, it will be rounded down to the nearest integer (4.5 becomes 4, 10.9 becomes 10). set mylist [2 7 4 7 \"Bob\"] set mylist remove-item 2 mylist ;; mylist is now [2 7 7 \"Bob\"] show remove-item 2 \"string\" => \"sting\""
      ],
      "247": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: repeat \n\nEntry Data: repeat\nusage: repeat number [ commands ] \n Runs commands number times. pd repeat 36 [ fd 1 rt 10 ] ;; the turtle draws a circle"
      ],
      "248": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: replace-item \n\nEntry Data: replace-item\nusage: [('class', 'prim_example')]replace-item index string1 string2 \n On a list, replaces an item in that list. index is the index of the item to be replaced, starting with 0. (The 6th item in a list would have an index of 5.) Note that \"replace-item\" is used in conjunction with \"set\" to change a list. Likewise for a string, but the given character of string1 removed and the contents of string2 spliced in instead. If index is fractional, it will be rounded down to the nearest integer (4.5 becomes 4, 10.9 becomes 10). show replace-item 2 [2 7 4 5] 15 => [2 7 15 5] show replace-item 1 \"cat\" \"are\" => \"caret\""
      ],
      "249": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: report \n\nEntry Data: report\nusage: report value \n Immediately exits from the current to-report procedure and reports value as the result of that procedure. report and to-report are always used in conjunction with each other. See to-report for a discussion of how to use them."
      ],
      "250": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: reset-perspective \n\nEntry Data: reset-perspective\nusage: reset-perspective \n The observer stops watching, following, or riding any turtles (or patches or links). (If it wasn't watching, following, or riding anybody, nothing happens.) In the 3D view, the observer also returns to its default position (above the origin, looking straight down). Note: following and riding are valid for turtles only. See also follow, ride, watch."
      ],
      "251": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: reset-ticks \n\nEntry Data: reset-ticks\nusage: reset-ticks \n Resets the tick counter to zero, sets up all plots, then updates all plots (so that the initial state of the world is plotted). Normally reset-ticks goes at the end of a setup procedure. See also clear-ticks, tick, ticks, tick-advance, setup-plots, update-plots."
      ],
      "252": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: reset-timer \n\nEntry Data: reset-timer\nusage: reset-timer \n Resets the timer to zero seconds. See also timer. Note that the timer is different from the tick counter. The timer measures elapsed real time in seconds; the tick counter measures elapsed model time in ticks."
      ],
      "253": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: resize-world \n\nEntry Data: resize-world\nusage: resize-world min-pxcor max-pxcor min-pycor max-pycor \n Changes the size of the patch grid. If the given patch grid coordinates are different than the ones in use, all turtles and links die, and the existing patch grid is discarded and new patches created. Otherwise, existing turtles and links will live if the grid coordinates are unchanged. Retaining references to old patches or patch sets is inadvisable and may subsequently cause runtime errors or other unexpected behavior. If any coordinate is fractional, it will be rounded to the nearest integer towards zero (4.5 becomes 4, 10.9 becomes 10, -2.9 becomes -2). See also set-patch-size."
      ],
      "254": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: reverse \n\nEntry Data: reverse\nusage: [('class', 'prim_example')]reverse string \n Reports a reversed copy of the given list or string. show mylist ;; mylist is [2 7 4 \"Bob\"] set mylist reverse mylist ;; mylist now is [\"Bob\" 4 7 2] show reverse \"live\" => \"evil\""
      ],
      "255": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: rgb \n\nEntry Data: rgb\nusage: rgb red green blue \n Reports a RGB list when given three numbers describing an RGB color. The numbers are range checked to be between 0 and 255. See also hsb"
      ],
      "256": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: ride \n\nEntry Data: ride\nusage: ride turtle \n Set the perspective to turtle. Every time turtle moves the observer also moves. Thus, in the 2D View the turtle will stay at the center of the view. In the 3D view it is as if looking through the eyes of the turtle. If the turtle dies, the perspective resets to the default. The observer may only watch or follow a single subject. Calling ride will remove the highlight created by prior calls to watch and watch-me, highlighting the ridden turtle instead. See also reset-perspective, watch, follow, subject."
      ],
      "257": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: ride-me \n\nEntry Data: ride-me\nusage: ride-me \n Asks the observer to ride this turtle. The observer may only watch or follow a single subject. Calling ride-me will remove the highlight created by prior calls to watch and watch-me, highlighting this turtle instead. See also ride."
      ],
      "258": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: right \n\nEntry Data: right\nusage: right number \n The turtle turns right by number degrees. (If number is negative, it turns left.)"
      ],
      "259": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: round \n\nEntry Data: round\nusage: round number \n Reports the integer nearest to number. If the decimal portion of number is exactly .5, the number is rounded in the positive direction. Note that rounding in the positive direction is not always how rounding is done in other software programs. (In particular, it does not match the behavior of StarLogoT, which always rounded numbers ending in 0.5 to the nearest even integer.) The rationale for this behavior is that it matches how turtle coordinates relate to patch coordinates in NetLogo. For example, if a turtle's xcor is -4.5, then it is on the boundary between a patch whose pxcor is -4 and a patch whose pxcor is -5, but the turtle must be considered to be in one patch or the other, so the turtle is considered to be in the patch whose pxcor is -4, because we round towards the positive numbers. show round 4.2 => 4 show round 4.5 => 5 show round -4.5 => -4 See also precision, ceiling, floor."
      ],
      "260": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: run \n\nEntry Data: run\nusage: [('class', 'prim_example')][('class', 'prim_example')][('class', 'prim_example')][('class', 'prim_example')][('class', 'prim_example')]runresult string \n The run form expects the name of a command, an anonymous command, or a string containing commands. This agent then runs them. The runresult form expects the name of a reporter, an anonymous reporter, or a string containing a reporter. This agent runs it and reports the result. Note that you can't use run to define or redefine procedures. If you care about performance, note that the code must be compiled first which takes time. However, compiled bits of code are cached by NetLogo and thus using run on the same string over and over is much faster than running different strings. The first run, though, will be many times slower than running the same code directly, or in an anonymous command. Anonymous procedures are recommended over strings whenever possible. (An example of when you must use strings is if you accept pieces of code from the user of your model.) Anonymous procedures may freely read and/or set local variables and procedure inputs. Trying to do the same with strings may or may not work and should not be relied on. When using anonymous procedures, you can provide them with inputs, if you surround the entire call with parentheses. For example: (run [ [turtle-count step-count] -> crt turtle-count [ fd step-count ] ] 10 5) ;; creates 10 turtles and move them forward 5 steps show (runresult [ [a b] -> a + b ] 10 5) => 15 ;; adds 10 and 5 See also foreach, -> (anonymous procedure)."
      ],
      "261": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: scale-color \n\nEntry Data: scale-color\nusage: scale-color color number range1 range2 \n Reports a shade of color proportional to the value of number. When range1 is less than or equal to range2, then the larger the number, the lighter the shade of color. However, if range2 is less than range1, the color scaling is inverted. Let min-range be the minimum of range1 and range2. If number is less than or equal to min-range, then the result is the same as if number was equal to min-range. Let max-range be the maximum of range1 and range2. If number is greater than max-range, then the result is the same as if number was equal to max-range. Note: for color shade is irrelevant, e.g. green and green + 2 are equivalent, and the same spectrum of colors will be used. ask turtles [ set color scale-color red age 0 50 ] ;; colors each turtle a shade of red proportional ;; to its value for the age variable"
      ],
      "262": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: self \n\nEntry Data: self\nusage: self \n Reports this turtle, patch, or link. \"self\" and \"myself\" are very different. \"self\" is simple; it means \"me\". \"myself\" means \"the agent who asked me to do what I'm doing right now.\" Note that it is always redundant to write [foo] of self. This is always equivalent to simply writing foo. See also myself."
      ],
      "263": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: semicolon \n\nEntry Data: semicolon\nusage: ; comments \n After a semicolon, the rest of the line is ignored. This is useful for adding \"comments\" to your code -- text that explains the code to human readers. Extra semicolons can be added for visual effect. NetLogo's Edit menu has items that let you comment or uncomment whole sections of code."
      ],
      "264": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: sentence \n\nEntry Data: sentence\nusage: [('class', 'prim_example')](sentence value1 ...) \n Makes a list out of the values. If any value is a list, its items are included in the result directly, rather than being included as a sublist. Examples make this clearer: show sentence 1 2 => [1 2] show sentence [1 2] 3 => [1 2 3] show sentence 1 [2 3] => [1 2 3] show sentence [1 2] [3 4] => [1 2 3 4] show sentence [[1 2]] [[3 4]] => [[1 2] [3 4]] show (sentence [1 2] 3 [4 5] (3 + 3) 7) => [1 2 3 4 5 6 7]"
      ],
      "265": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: set \n\nEntry Data: set\nusage: set variable value \n Sets variable to the given value. Variable can be any of the following: A global variable declared using \"globals\" The global variable associated with a slider, switch, chooser, or input box. A variable belonging to this agent If this agent is a turtle, a variable belonging to the patch under the turtle. A local variable created by the let command. An input to the current procedure. Example: ask turtles [ set color red set size 2 set shape \"arrow\" ] You can also give a list of variable names as the first argument for set and they will be assigned the values from a list given as the second argument. This can be particular useful when you want to calculate multiple values in a reporter procedure, as you can easily set multiple variables with the results. A runtime error will occur if the second argument is not a list value or if there are not enough values in the list for all the variables specified. ask turtles [ set [color size shape] [red 2 \"arrow\"] show color ; prints 15 show size ; prints 2 show shape ; prints \"arrow\" ] ask turtles [ set [color size shape] [red] ; causes a runtime error as we need at least 3 values in the list ]"
      ],
      "266": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: set-current-directory \n\nEntry Data: set-current-directory\nusage: set-current-directory string \n Sets the current directory that is used by the primitives file-delete, file-exists?, and file-open. The current directory is not used if the above commands are given an absolute file path. This is defaulted to the user's home directory for new models, and is changed to the model's directory when a model is opened. Note that in Windows file paths the backslash needs to be escaped within a string by using another backslash \"C:\\\\\" The change is temporary and is not saved with the model. set-current-directory \"C:\\\\NetLogo\" ;; Assume it is a Windows Machine file-open \"my-file.txt\" ;; Opens file \"C:\\\\NetLogo\\\\my-file.txt\""
      ],
      "267": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: set-current-plot \n\nEntry Data: set-current-plot\nusage: set-current-plot plotname \n Sets the current plot to the plot with the given name (a string). Subsequent plotting commands will affect the current plot."
      ],
      "268": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: set-current-plot-pen \n\nEntry Data: set-current-plot-pen\nusage: set-current-plot-pen penname \n The current plot's current pen is set to the pen named penname (a string). If no such pen exists in the current plot, a runtime error occurs. If the current plot has not been set, a runtime error occurs."
      ],
      "269": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: set-default-shape \n\nEntry Data: set-default-shape\nusage: [('class', 'prim_example')][('class', 'prim_example')]set-default-shape breed string \n Specifies a default initial shape for all turtles or links, or for a particular breed of turtles or links. When a turtle or link is created, or it changes breeds, it shape is set to the given shape. This command doesn't affect existing agents, only agents you create afterwards. The given breed must be either turtles, links, or the name of a breed. The given string must be the name of a currently defined shape. In new models, the default shape for all turtles is \"default\". Note that specifying a default shape does not prevent you from changing an agent's shape later. Agents don't have to be stuck with their breed's default shape. create-turtles 1 ;; new turtle's shape is \"default\" create-cats 1 ;; new turtle's shape is \"default\" set-default-shape turtles \"circle\" create-turtles 1 ;; new turtle's shape is \"circle\" create-cats 1 ;; new turtle's shape is \"circle\" set-default-shape cats \"cat\" set-default-shape dogs \"dog\" create-cats 1 ;; new turtle's shape is \"cat\" ask cats [ set breed dogs ] ;; all cats become dogs, and automatically ;; change their shape to \"dog\" See also shape."
      ],
      "270": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: set-histogram-num-bars \n\nEntry Data: set-histogram-num-bars\nusage: set-histogram-num-bars number \n Set the current plot pen's plot interval so that, given the current x range for the plot, there would be number number of bars drawn if the histogram command is called. See also histogram. This command will produce a runtime error if either the current plot or the current pen has not been set."
      ],
      "271": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: set-line-thickness \n\nEntry Data: set-line-thickness\nusage: __set-line-thickness number \n Specifies the thickness of lines and outlined elements in the turtle's shape. The default value is 0. This always produces lines one pixel thick. Non-zero values are interpreted as thickness in patches. A thickness of 1, for example, produces lines which appear one patch thick. (It's common to use a smaller value such as 0.5 or 0.2.) Lines are always at least one pixel thick. This command is experimental and may change in later releases."
      ],
      "272": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: set-patch-size \n\nEntry Data: set-patch-size\nusage: set-patch-size size \n Sets the size of the patches of the view in pixels. The size is typically an integer, but may also be a floating point number. See also patch-size, resize-world."
      ],
      "273": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: set-plot-background-color \n\nEntry Data: set-plot-background-color\nusage: set-plot-background-color color \n Sets the background color of the current plot. The color may be specified as a number or a list. See the Colors section of the programming guide for more details. This change is temporary and is not saved with the model. When the plot is cleared, the background color will revert to white. Note: Plot backgrounds do not support transparency. If a list is used to set the color, the alpha component will be ignored. This command will produce a runtime error if the current plot has not been set."
      ],
      "274": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: set-plot-pen-color \n\nEntry Data: set-plot-pen-color\nusage: set-plot-pen-color color \n Sets the color of the current plot pen to color. This command will produce a runtime error if either the current plot or the current pen has not been set."
      ],
      "275": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: set-plot-pen-interval \n\nEntry Data: set-plot-pen-interval\nusage: set-plot-pen-interval number \n Tells the current plot pen to move a distance of number in the x direction during each use of the plot command. (The plot pen interval also affects the behavior of the histogram command.) This command will produce a runtime error if either the current plot or the current pen has not been set."
      ],
      "276": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: set-plot-pen-mode \n\nEntry Data: set-plot-pen-mode\nusage: set-plot-pen-mode number \n Sets the mode the current plot pen draws in to number. The allowed plot pen modes are: 0 (line mode) the plot pen draws a line connecting two points together. 1 (bar mode): the plot pen draws a bar of width plot-pen-interval with the point plotted as the upper (or lower, if you are plotting a negative number) left corner of the bar. 2 (point mode): the plot pen draws a point at the point plotted. Points are not connected. The default mode for new pens is 0 (line mode). This command will produce a runtime error if either the current plot or the current pen has not been set."
      ],
      "277": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: setup-plots \n\nEntry Data: setup-plots\nusage: setup-plots \n For each plot, runs that plot's setup commands, including the setup code for any pens in the plot. reset-ticks has the same effect, so in models that use the tick counter, this primitive is not normally used. See the Plotting section of the Programming Guide for more details. See also update-plots."
      ],
      "278": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: set-plot--range \n\nEntry Data: set-plot--range\nusage: [('class', 'prim_example')]set-plot-y-range min max \n Sets the minimum and maximum values of the x or y axis of the current plot. The change is temporary and is not saved with the model. When the plot is cleared, the ranges will revert to their default values as set in the plot's Edit dialog. These commands will produce a runtime error if the current plot has not been set."
      ],
      "279": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: setxy \n\nEntry Data: setxy\nusage: setxy x y \n The turtle sets its x-coordinate to x and its y-coordinate to y. Equivalent to set xcor x set ycor y, except it happens in one time step instead of two. If x or y is outside the world, NetLogo will throw a runtime error, unless wrapping is turned on in the relevant dimensions. For example, with wrapping turned on in both dimensions and the default world size where min-pxcor = -16, max-pxcor = 16, min-pycor = -16 and max-pycor = 16, asking a turtle to setxy 17 17 will move it to the center of patch (-16, -16). setxy 0 0 ;; turtle moves to the middle of the center patch setxy random-xcor random-ycor ;; turtle moves to a random point setxy random-pxcor random-pycor ;; turtle moves to the center of a random patch See also move-to."
      ],
      "280": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: shade-of \n\nEntry Data: shade-of\nusage: shade-of? color1 color2 \n Reports true if both colors are shades of one another, false otherwise. show shade-of? blue red => false show shade-of? blue (blue + 1) => true show shade-of? gray white => true"
      ],
      "281": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: shape \n\nEntry Data: shape\nusage: shape \n This is a built-in turtle and link variable. It holds a string that is the name of the turtle or link's current shape. You can set this variable to change the shape. New turtles and links have the shape \"default\" unless the a different shape has been specified using set-default-shape. Example: ask turtles [ set shape \"wolf\" ] ;; assumes you have made a \"wolf\" ;; shape in NetLogo's Turtle Shapes Editor ask links [ set shape \"link 1\" ] ;; assumes you have made a \"link 1\" shape in ;; the Link Shapes Editor See also set-default-shape, shapes."
      ],
      "282": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: shapes \n\nEntry Data: shapes\nusage: shapes \n Reports a list of strings containing all of the turtle shapes in the model. New shapes can be created, or imported from the shapes library or from other models, in the Shapes Editor. show shapes => [\"default\" \"airplane\" \"arrow\" \"box\" \"bug\" ... ask turtles [ set shape one-of shapes ]"
      ],
      "283": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: show \n\nEntry Data: show\nusage: show value \n Prints value in the Command Center, preceded by this agent, and followed by a carriage return. (This agent is included to help you keep track of what agents are producing which lines of output.) Also, all strings have their quotes included similar to write. See also print, type, write, output-show, and Output (programming guide)."
      ],
      "284": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: show-turtle \n\nEntry Data: show-turtle\nusage: show-turtle \n The turtle becomes visible again. Note: This command is equivalent to setting the turtle variable \"hidden?\" to false. See also hide-turtle."
      ],
      "285": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: show-link \n\nEntry Data: show-link\nusage: show-link \n The link becomes visible again. Note: This command is equivalent to setting the link variable \"hidden?\" to false. See also hide-link."
      ],
      "286": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: shuffle \n\nEntry Data: shuffle\nusage: shuffle list \n Reports a new list containing the same items as the input list, but in randomized order. show shuffle [1 2 3 4 5] => [5 2 4 1 3] show shuffle [1 2 3 4 5] => [1 3 5 2 4]"
      ],
      "287": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: sin \n\nEntry Data: sin\nusage: sin number \n Reports the sine of the given angle. Assumes angle is given in degrees. show sin 270 => -1"
      ],
      "288": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: size \n\nEntry Data: size\nusage: size \n This is a built-in turtle variable. It holds a number that is the turtle's apparent size. The default size is 1, which means that the turtle is the same size as a patch. You can set this variable to change a turtle's size."
      ],
      "289": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: sort \n\nEntry Data: sort\nusage: [('class', 'prim_example')]sort agentset \n Reports a sorted list of numbers, strings, or agents. If the input contains no numbers, strings, or agents, the result is the empty list. If the input contains at least one number, the numbers in the list are sorted in ascending order and a new list reported; non-numbers are ignored. Or, if the input contains at least one string, the strings in the list are sorted in ascending order and a new list reported; non-strings are ignored. Or, if the input is an agentset or a list containing at least one agent, a sorted list of agents (never an agentset) is reported; non-agents are ignored. Agents are sorted in the same order the < operator uses. (Patches are sorted with the top left-most patch first and the bottom right-most patch last, turtles are sorted by who number). show sort [3 1 4 2] => [1 2 3 4] show sort [2 1 \"a\"] => [1 2] show sort (list \"a\" \"c\" \"b\" (patch 0 0)) => [\"a\" \"b\" \"c\"] show sort (list (patch 0 0) (patch 0 1) (patch 1 0)) => [(patch 0 1) (patch 0 0) (patch 1 0)] ;; label patches with numbers in left-to-right, top-to-bottom order let n 0 foreach sort patches [ the-patch -> ask the-patch [ set plabel n set n n + 1 ] ] ;; some additional examples to clarify behavior in strange cases show sort (list patch 0 0 patch 0 1 patch 1 0 turtle 0 turtle 1) ; turtles are always sorted lower than patches => [(turtle 0) (turtle 1) (patch 0 1) (patch 0 0) (patch 1 0)] show sort (list nobody false true) ; booleans and nobody cannot be sorted => [] show sort (list [1 2 3] turtles) ; lists and agentsets are not included if they are inside a list passed to sort => [] See also sort-by, sort-on."
      ],
      "290": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: sort-by \n\nEntry Data: sort-by\nusage: [('class', 'prim_example')]sort-by reporter agentset \n If the input is a list, reports a new list containing the same items as the input list, in a sorted order defined by the boolean reporter. reporter may be an anonymous reporter or the name of a reporter. The two inputs to reporter are the values being compared. The reporter should report true if the first argument comes strictly before the second in the desired sort order, and false otherwise. If the input is an agentset or a list of agents, reports a list (never an agentset) of agents. If the input is a list, the sort is stable, that is, the order of items considered equal by the reporter is not disturbed. If the input is an agentset, ties are broken randomly. show sort-by < [3 1 4 2] => [1 2 3 4] show sort-by > [3 1 4 2] => [4 3 2 1] show sort-by [ [string1 string2] -> length string1 < length string2 ] [\"Grumpy\" \"Doc\" \"Happy\"] => [\"Doc\" \"Happy\" \"Grumpy\"] See also sort, sort-on, -> (anonymous procedure)."
      ],
      "291": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: sort-on \n\nEntry Data: sort-on\nusage: sort-on [reporter] agentset \n Reports a list of agents, sorted according to each agent's value for reporter. Ties are broken randomly. The values must be all numbers, all strings, or all agents of the same type. crt 3 show sort-on [who] turtles => [(turtle 0) (turtle 1) (turtle 2)] show sort-on [(- who)] turtles => [(turtle 2) (turtle 1) (turtle 0)] foreach sort-on [size] turtles [ the-turtle -> ask the-turtle [ do-something ] ] ;; turtles run \"do-something\" one at a time, in ;; ascending order by size See also sort, sort-by."
      ],
      "292": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: sprout \n\nEntry Data: sprout\nusage: [('class', 'prim_example')]sprout-<breeds> number [ commands ] \n Creates number new turtles on the current patch. The new turtles have random integer headings and the color is randomly selected from the 14 primary colors. The turtles immediately run commands. This is useful for giving the new turtles different colors, headings, or whatever. (The new turtles are created all at once then run one at a time, in random order.) If the sprout-<breeds> form is used, the new turtles are created as members of the given breed. If number is fractional, it will be rounded down to the nearest integer (4.5 becomes 4, 10.9 becomes 10). sprout 5 sprout-wolves 10 sprout 1 [ set color red ] sprout-sheep 1 [ set color black ] See also create-turtles, hatch."
      ],
      "293": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: sqrt \n\nEntry Data: sqrt\nusage: sqrt number \n Reports the square root of number."
      ],
      "294": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: stamp \n\nEntry Data: stamp\nusage: stamp \n This turtle or link leaves an image of its shape in the drawing at its current location. Note: The shapes made by stamp may not be pixel-for-pixel identical from computer to computer."
      ],
      "295": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: stamp-erase \n\nEntry Data: stamp-erase\nusage: stamp-erase \n This turtle or link removes any pixels below it in the drawing inside the bounds of its shape. Note: The shapes made by stamp-erase may not be pixel-for-pixel identical from computer to computer."
      ],
      "296": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: standard-deviation \n\nEntry Data: standard-deviation\nusage: standard-deviation list \n Reports the sample standard deviation of a list of numbers. Ignores other types of items. (Note that this estimates the standard deviation for a sample, rather than for a whole population, using Bessel's correction.) show standard-deviation [1 2 3 4 5 6] => 1.8708286933869707 show standard-deviation [energy] of turtles ;; prints the standard deviation of the variable \"energy\" ;; from all the turtles See this FAQ question for information on possible issues using standard-deviation with agentsets"
      ],
      "297": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: startup \n\nEntry Data: startup\nusage: startup \n User-defined procedure which, if it exists, will be called when a model is first loaded in the NetLogo application. to startup setup end startup does not run when a model is run headless from the command line, or by parallel BehaviorSpace."
      ],
      "298": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: stop \n\nEntry Data: stop\nusage: stop \n This agent exits immediately from the enclosing procedure, ask, or ask-like construct (e.g. crt, hatch, sprout). Only the enclosing procedure or construct stops, not all execution for the agent. if not any? turtles [ stop ] ;; exits if there are no more turtles Note: stop can also be used to stop a forever button. See Buttons in the Programming Guide for details. stop can also be used to stop a BehaviorSpace model run. If the go commands directly call a procedure, then when that procedure calls stop, the run ends."
      ],
      "299": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: stop-inspecting \n\nEntry Data: stop-inspecting\nusage: stop-inspecting agent \n Closes the agent monitor for the given agent (turtle or patch or link). In the case that no agent monitor is open, stop-inspecting does nothing. stop-inspecting patch 2 4 ;; the agent monitor for that patch closes ask sheep [ stop-inspecting self ] ;; close all agent monitors for sheep ask links [ stop-inspecting self ] ;; close all agent monitors for links See inspect and stop-inspecting-dead-agents."
      ],
      "300": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: stop-inspecting-dead-agents \n\nEntry Data: stop-inspecting-dead-agents\nusage: stop-inspecting-dead-agents \n Closes all agent monitors for dead agents. See inspect and stop-inspecting."
      ],
      "301": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: subject \n\nEntry Data: subject\nusage: subject \n Reports the turtle (or patch or link) that the observer is currently watching, following, or riding. Reports nobody if there is no such turtle (or patch or link). Note: following and riding are valid for turtles only. See also watch, follow, ride."
      ],
      "302": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: subliststring \n\nEntry Data: subliststring\nusage: [('class', 'prim_example')]substring string position1 position2 \n Reports just a section of the given list or string, ranging between the first position (inclusive) and the second position (exclusive). If either position is fractional, it will be rounded down to the nearest integer (4.5 becomes 4, 10.9 becomes 10). Note: The positions are numbered beginning with 0, not with 1. show sublist [99 88 77 66] 1 3 => [88 77] show substring \"apartment\" 1 5 => \"part\""
      ],
      "303": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: subtract-headings \n\nEntry Data: subtract-headings\nusage: subtract-headings heading1 heading2 \n Computes the difference between the given headings, that is, the number of degrees in the smallest angle by which heading2 could be rotated to produce heading1. A positive answer means a clockwise rotation, a negative answer counterclockwise. The result is always in the range -180 to 180, but is never exactly -180. Note that simply subtracting the two headings using the - (minus) operator wouldn't work. Just subtracting corresponds to always rotating clockwise from heading2 to heading1; but sometimes the counterclockwise rotation is shorter. For example, the difference between 5 degrees and 355 degrees is 10 degrees, not -350 degrees. show subtract-headings 80 60 => 20 show subtract-headings 60 80 => -20 show subtract-headings 5 355 => 10 show subtract-headings 355 5 => -10 show subtract-headings 180 0 => 180 show subtract-headings 0 180 => 180"
      ],
      "304": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: sum \n\nEntry Data: sum\nusage: sum list \n Reports the sum of the items in the list. show sum [energy] of turtles ;; prints the total of the variable \"energy\" ;; from all the turtles See this FAQ question for information on possible issues using sum with agentsets"
      ],
      "305": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: tan \n\nEntry Data: tan\nusage: tan number \n Reports the tangent of the given angle. Assumes the angle is given in degrees."
      ],
      "306": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: thickness \n\nEntry Data: thickness\nusage: thickness \n This is a built-in link variable. It holds a number that is the link's apparent size as a fraction of the patch size. The default thickness is 0, which means that regardless of patch-size the links will always appear 1 pixel wide. You can set this variable to change a link's thickness."
      ],
      "307": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: tick \n\nEntry Data: tick\nusage: tick \n Advances the tick counter by one and updates all plots. If the tick counter has not been started yet with reset-ticks, an error results. Normally tick goes at the end of a go procedure. See also ticks, tick-advance, reset-ticks, clear-ticks, update-plots."
      ],
      "308": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: tick-advance \n\nEntry Data: tick-advance\nusage: tick-advance number \n Advances the tick counter by number. The input may be an integer or a floating point number. (Some models divide ticks more finely than by ones.) The input may not be negative. When using tick-based view updates, the view is normally updated every 1.0 ticks, so using tick-advance with a number less then 1.0 may not always trigger an update. If you want to make sure that the view is updated, you can use the display command. If the tick counter has not been started yet with reset-ticks, an error results. Does not update plots. See also tick, ticks, reset-ticks, clear-ticks."
      ],
      "309": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: ticks \n\nEntry Data: ticks\nusage: ticks \n Reports the current value of the tick counter. The result is always a number and never negative. If the tick counter has not been started yet with reset-ticks, an error results. Most models use the tick command to advance the tick counter, in which case ticks will always report an integer. If the tick-advance command is used, then ticks may report a floating point number. See also tick, tick-advance, reset-ticks, clear-ticks."
      ],
      "310": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: tie \n\nEntry Data: tie\nusage: tie \n Ties end1 and end2 of the link together. If the link is a directed link end1 is the root turtle and end2 is the leaf turtle. The movement of the root turtle affects the location and heading of the leaf turtle. If the link is undirected the tie is reciprocal so both turtles can be considered root turtles and leaf turtles. Movement or change in heading of either turtle affects the location and heading of the other turtle. When the root turtle moves, the leaf turtles moves the same distance, in the same direction. The heading of the leaf turtle is not affected. This works with forward, jump, and setting the xcor or ycor of the root turtle. When the root turtle turns right or left, the leaf turtle is rotated around the root turtle the same amount. The heading of the leaf turtle is also changed by the same amount. If the link dies, the tie relation is removed. crt 2 [ fd 3 ] ;; creates a link and ties turtle 1 to turtle 0 ask turtle 0 [ create-link-to turtle 1 [ tie ] ] See also untie"
      ],
      "311": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: tie-mode \n\nEntry Data: tie-mode\nusage: tie-mode \n This is a built-in link variable. It holds a string that is the name of the tie mode the link is currently in. Using the tie and untie commands changes the mode of the link. You can also set tie-mode to \"free\" to create a non-rigid joint between two turtles (see the Tie section of the Programming Guide for details). By default links are not tied. See also: tie, untie"
      ],
      "312": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: timer \n\nEntry Data: timer\nusage: timer \n Reports how many seconds have passed since the command reset-timer was last run (or since NetLogo started). The potential resolution of the clock is milliseconds. (Whether you get resolution that high in practice may vary from system to system, depending on the capabilities of the underlying Java Virtual Machine.) See also reset-timer. Note that the timer is different from the tick counter. The timer measures elapsed real time in seconds; the tick counter measures elapsed model time in ticks."
      ],
      "313": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: to \n\nEntry Data: to\nusage: [('class', 'prim_example')]to procedure-name [input1 ...] \n Used to begin a command procedure. to setup clear-all crt 500 end to circle [radius] crt 100 [ fd radius ] end"
      ],
      "314": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: to-report \n\nEntry Data: to-report\nusage: [('class', 'prim_example')]to-report procedure-name [input1 ...] \n Used to begin a reporter procedure. The body of the procedure should use report to report a value for the procedure. See report. to-report average [a b] report (a + b) / 2 end to-report absolute-value [number] ifelse number >= 0 [ report number ] [ report (- number) ] end to-report first-turtle? report who = 0 ;; reports true or false end"
      ],
      "315": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: towards \n\nEntry Data: towards\nusage: towards agent \n Reports the heading from this agent to the given agent. If wrapping is allowed by the topology and the wrapped distance (around the edges of the world) is shorter, towards will use the wrapped path. Note: asking for the heading from an agent to itself, or an agent on the same location, will cause a runtime error. set heading towards turtle 1 ;; same as \"face turtle 1\" See also face."
      ],
      "316": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: towardsxy \n\nEntry Data: towardsxy\nusage: towardsxy x y \n Reports the heading from the turtle or patch towards the point (x,y). If wrapping is allowed by the topology and the wrapped distance (around the edges of the world) is shorter, towardsxy will use the wrapped path. Note: asking for the heading to the point the agent is already standing on will cause a runtime error. See also facexy."
      ],
      "317": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: turtle \n\nEntry Data: turtle\nusage: [('class', 'prim_example')]<breed> number \n Reports the turtle with the given who number, or nobody if there is no such turtle. For breeded turtles you may also use the single breed form to refer to them. ask turtle 5 [ set color red ] ;; turtle with who number 5 turns red"
      ],
      "318": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: turtle-set \n\nEntry Data: turtle-set\nusage: [('class', 'prim_example')](turtle-set value1 value2 ...) \n Reports an agentset containing all of the turtles anywhere in any of the inputs. The inputs may be individual turtles, turtle agentsets, nobody, or lists (or nested lists) containing any of the above. turtle-set self (turtle-set self turtles-on neighbors) (turtle-set turtle 0 turtle 2 turtle 9) (turtle-set frogs mice) See also patch-set, link-set."
      ],
      "319": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: turtles \n\nEntry Data: turtles\nusage: turtles \n Reports the agentset consisting of all turtles. This is a special agentset that can grow as turtles are added to the world, see the programming guide for more info. show count turtles ;; prints the number of turtles"
      ],
      "320": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: turtles-at \n\nEntry Data: turtles-at\nusage: [('class', 'prim_example')]<breeds>-at dx dy \n Reports an agentset containing the turtles on the patch (dx, dy) from the caller. (The result may include the caller itself if the caller is a turtle.) create-turtles 5 [ setxy 2 3 ] show count [turtles-at 1 1] of patch 1 2 => 5 If the name of a breed is substituted for \"turtles\", then only turtles of that breed are included."
      ],
      "321": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: turtles-here \n\nEntry Data: turtles-here\nusage: [('class', 'prim_example')]<breeds>-here \n Reports an agentset containing all the turtles on the caller's patch (including the caller itself if it's a turtle). crt 10 ask turtle 0 [ show count turtles-here ] => 10 If the name of a breed is substituted for \"turtles\", then only turtles of that breed are included. breed [cats cat] breed [dogs dog] create-cats 5 create-dogs 1 ask dogs [ show count cats-here ] => 5"
      ],
      "322": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: turtles-on \n\nEntry Data: turtles-on\nusage: [('class', 'prim_example')][('class', 'prim_example')][('class', 'prim_example')]<breeds>-on agentset \n Reports an agentset containing all the turtles that are on the given patch or patches, or standing on the same patch as the given turtle or turtles. ask turtles [ if not any? turtles-on patch-ahead 1 [ fd 1 ] ] ask turtles [ if not any? turtles-on neighbors [ die-of-loneliness ] ] If the name of a breed is substituted for \"turtles\", then only turtles of that breed are included."
      ],
      "323": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: turtles-own \n\nEntry Data: turtles-own\nusage: [('class', 'prim_example')]<breeds>-own [var1 ...] \n The turtles-own keyword, like the globals, breed, <breeds>-own, and patches-own keywords, can only be used at the beginning of a program, before any function definitions. It defines the variables belonging to each turtle. If you specify a breed instead of \"turtles\", only turtles of that breed have the listed variables. (More than one turtle breed may list the same variable.) breed [cats cat ] breed [dogs dog] breed [hamsters hamster] turtles-own [eyes legs] ;; applies to all breeds cats-own [fur kittens] hamsters-own [fur cage] dogs-own [hair puppies] See also globals, patches-own, breed, <breeds>-own."
      ],
      "324": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: type \n\nEntry Data: type\nusage: type value \n Prints value in the Command Center, not followed by a carriage return (unlike print and show). The lack of a carriage return allows you to print several values on the same line. This agent is not printed before the value. unlike show. type 3 type \" \" print 4 => 3 4 See also print, show, write, output-type, and Output (programming guide)."
      ],
      "325": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: undirected-link-breed \n\nEntry Data: undirected-link-breed\nusage: undirected-link-breed [<link-breeds> <link-breed>] \n This keyword, like the globals and breeds keywords, can only be used at the beginning of the Code tab, before any procedure definitions. It defines an undirected link breed. Links of a particular breed are always either all directed or all undirected. The first input defines the name of the agentset associated with the link breed. The second input defines the name of a single member of the breed. Any link of the given link breed: is part of the agentset named by the link breed name has its built-in variable breed set to that agentset is directed or undirected as declared by the keyword Most often, the agentset is used in conjunction with ask to give commands to only the links of a particular breed. undirected-link-breed [streets street] undirected-link-breed [highways highway] to setup clear-all crt 2 ask turtle 0 [ create-street-with turtle 1 ] ask turtle 0 [ create-highway-with turtle 1 ] end ask turtle 0 [ show sort my-links ] ;; prints [(street 0 1) (highway 0 1)] See also breed, directed-link-breed"
      ],
      "326": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: untie \n\nEntry Data: untie\nusage: untie \n Unties end2 from end1 (sets tie-mode to \"none\") if they were previously tied together. If the link is an undirected link, then it will untie end1 from end2 as well. It does not remove the link between the two turtles. See also tie See the Tie section of the Programming Guide for more details."
      ],
      "327": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: up-to-n-of \n\nEntry Data: up-to-n-of\nusage: [('class', 'prim_example')]up-to-n-of size list \n From an agentset, reports an agentset of size size randomly chosen from the input set, with no repeats. If the input does not have enough agents to satisfy the size, reports the entire agentset. From a list, reports a list of size size randomly chosen from the input set, with no repeats. The items in the result appear in the same order that they appeared in the input list. (If you want them in random order, use shuffle on the result.) If the input does not have enough items to satisfy the size, reports the entire list. If size is fractional, it will be rounded down to the nearest integer (4.5 becomes 4, 10.9 becomes 10). ask up-to-n-of 50 patches [ set pcolor green ] ;; 50 randomly chosen patches turn green ;; if less than 50 patches exist, they all turn green See also n-of, one-of."
      ],
      "328": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: update-plots \n\nEntry Data: update-plots\nusage: update-plots \n For each plot, runs that plot's update commands, including the update code for any pens in the plot. tick has the same effect, so in models that use the tick counter, this primitive is not normally used. Models that use fractional ticks may need update-plots, since tick-advance does not update the plots. See the Plotting section of the Programming Guide for more details. See also setup-plots."
      ],
      "329": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: uphill \n\nEntry Data: uphill\nusage: [('class', 'prim_example')]uphill4 patch-variable \n Moves the turtle to the neighboring patch with the highest value for patch-variable. If no neighboring patch has a higher value than the current patch, the turtle stays put. If there are multiple patches with the same highest value, the turtle picks one randomly. Non-numeric values are ignored. uphill considers the eight neighboring patches; uphill4 only considers the four neighbors. Equivalent to the following code (assumes variable values are numeric): move-to patch-here ;; go to patch center let p max-one-of neighbors [patch-variable] ;; or neighbors4 if [patch-variable] of p > patch-variable [ face p move-to p ] Note that the turtle always ends up on a patch center and has a heading that is a multiple of 45 (uphill) or 90 (uphill4). See also downhill, downhill4."
      ],
      "330": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: user-directory \n\nEntry Data: user-directory\nusage: user-directory \n Opens a dialog that allows the user to choose an existing directory on the system. It reports a string with the absolute path or false if the user cancels. set-current-directory user-directory ;; Assumes the user will choose a directory"
      ],
      "331": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: user-file \n\nEntry Data: user-file\nusage: user-file \n Opens a dialog that allows the user to choose an existing file on the system. It reports a string with the absolute file path or false if the user cancels. file-open user-file ;; Assumes the user will choose a file"
      ],
      "332": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: user-new-file \n\nEntry Data: user-new-file\nusage: user-new-file \n Opens a dialog that allows the user to choose a location and name of a new file to be created. It reports a string with the absolute file path or false if the user cancels. file-open user-new-file ;; Assumes the user will choose a file Note that this reporter doesn't actually create the file; normally you would create the file using file-open, as in the example. If the user chooses an existing file, they will be asked if they wish to replace it or not, but the reporter itself doesn't cause the file to be replaced. To do that you would use file-delete. Note: This primitive is not compatible with NetLogo Web. If you wish to read the contents of a file with the same code and the same behavior in both NetLogo and NetLogo Web, see fetch:user-file-async."
      ],
      "333": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: user-input \n\nEntry Data: user-input\nusage: user-input value \n Reports the string that a user types into an entry field in a dialog with title value. value may be of any type, but is typically a string. show user-input \"What is your name?\" See the User Interaction Primitives section of the Programming Guide for additional details."
      ],
      "334": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: user-message \n\nEntry Data: user-message\nusage: user-message value \n Opens a dialog with value displayed as the message to the user. value may be of any type, but is typically a string. user-message (word \"There are \" count turtles \" turtles.\") Note that if a user closes the user-message dialog with the \"X\" in the corner, the behavior will be the same as if they had clicked \"OK\". See the User Interaction Primitives section of the Programming Guide for additional details."
      ],
      "335": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: user-one-of \n\nEntry Data: user-one-of\nusage: user-one-of value list-of-choices \n Opens a dialog with value displayed as the message and list-of-choices displayed as a popup menu for the user to select from. Reports the item in list-of-choices selected by the user. value may be of any type, but is typically a string. if \"yes\" = user-one-of \"Set up the model?\" [\"yes\" \"no\"] [ setup ] Note: This primitive is not compatible with NetLogo Web. If you wish to read a chooser value from the user with the same code and the same behavior in both NetLogo and NetLogo Web, see dialog:user-one-of. See the User Interaction Primitives section of the Programming Guide for additional details."
      ],
      "336": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: user-yes-or-no \n\nEntry Data: user-yes-or-no\nusage: user-yes-or-no? value \n Reports true or false based on the user's response to value. value may be of any type, but is typically a string. if user-yes-or-no? \"Set up the model?\" [ setup ] Note: This primitive is not compatible with NetLogo Web. If you wish to read a true or false value from the user with the same code and the same behavior in both NetLogo and NetLogo Web, see dialog:user-yes-or-no?. See the User Interaction Primitives section of the Programming Guide for additional details."
      ],
      "337": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: variance \n\nEntry Data: variance\nusage: variance list \n Reports the sample variance of a list of numbers. Ignores other types of items. (Note that this computes an unbiased estimate of the variance for a sample, rather than for a whole population, using Bessel's correction.) The sample variance is the sum of the squares of the deviations of the numbers from their mean, divided by one less than the number of numbers in the list. show variance [2 7 4 3 5] => 3.7 See this FAQ question for information on possible issues using variance with agentsets"
      ],
      "338": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: wait \n\nEntry Data: wait\nusage: wait number \n Wait the given number of seconds. (This needn't be an integer; you can specify fractions of seconds.) Note that you can't expect complete precision; the agent will never wait less than the given amount, but might wait slightly more. repeat 10 [ fd 1 wait 0.5 ] While the agent is waiting, no other agents can do anything. Everything stops until the agent is done. See also every."
      ],
      "339": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: watch \n\nEntry Data: watch\nusage: watch agent \n Puts a spotlight on agent. In the 3D view the observer will also turn to face the subject. The observer may only watch or follow a single subject. Calling watch will undo perspective changes caused by prior calls to follow, follow-me, ride, and ride-me. See also follow, subject, reset-perspective, ride, ride-me, watch-me."
      ],
      "340": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: watch-me \n\nEntry Data: watch-me\nusage: watch-me \n Asks the observer to watch this agent. The observer may only watch or follow a single subject. Calling watch will undo perspective changes caused by prior calls to follow, follow-me, ride, and ride-me. See also follow, subject, reset-perspective, ride, ride-me, watch."
      ],
      "341": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: while \n\nEntry Data: while\nusage: while [reporter] [ commands ] \n If reporter reports false, exit the loop. Otherwise run commands and repeat. The reporter may have different values for different agents, so some agents may run commands a different number of times than other agents. while [any? other turtles-here] [ fd 1 ] ;; turtle moves until it finds a patch that has ;; no other turtles on it"
      ],
      "342": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: who \n\nEntry Data: who\nusage: who \n This is a built-in turtle variable. It holds the turtle's \"who number\" or ID number, an integer greater than or equal to zero. You cannot set this variable; a turtle's who number never changes. Who numbers start at 0. A dead turtle's number will not be reassigned to a new turtle until you use the clear-turtles or clear-all commands, at which time who numbering starts over again at 0. Example: show [who] of turtles with [color = red] ;; prints a list of the who numbers of all red turtles ;; in the Command Center, in random order crt 100 [ ifelse who < 50 [ set color red ] [ set color blue ] ] ;; turtles 0 through 49 are red, turtles 50 ;; through 99 are blue You can use the turtle reporter to retrieve a turtle with a given who number. See also turtle. Note that who numbers aren't breed-specific. No two turtles can have the same who number, even if they are different breeds: clear-turtles create-frogs 1 create-mice 1 ask turtles [ print who ] ;; prints (in some random order): ;; (frog 0): 0 ;; (mouse 1): 1 Even though we only have one mouse, it is mouse 1 not mouse 0, because the who number 0 was already taken by the frog."
      ],
      "343": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: who-are-not \n\nEntry Data: who-are-not\nusage: [('class', 'prim_example')]agentset who-are-not agent \n Takes an agentset on the left and an agentset or an agent on the right. Reports a new agentset containing all agents from the left-hand agentset that are not in the right-hand agentset (or are not the right-hand agent). breed [frogs frog] breed [mice mouse] create-frogs 10 create-mice 10 create-turtles 10 ; contains all the turtles who are not frogs ask turtles who-are-not frogs [ forward 1 ] Another example: ask turtles [ ; contains all the turtles this turtle is not linked to let targets (other turtles who-are-not link-neighbors) if count targets > 0 [ create-link-with one-of targets ] ]"
      ],
      "344": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: with \n\nEntry Data: with\nusage: agentset with [reporter] \n Takes two inputs: on the left, an agentset (usually \"turtles\" or \"patches\"). On the right, a boolean reporter. Reports a new agentset containing only those agents that reported true -- in other words, the agents satisfying the given condition. show count patches with [pcolor = red] ;; prints the number of red patches"
      ],
      "345": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: link-with \n\nEntry Data: link-with\nusage: [('class', 'prim_example')]link-with turtle \n Reports a link between turtle and the caller (directed or undirected, incoming or outgoing). If no link exists then it reports nobody. If more than one such link exists, reports a random one. crt 2 ask turtle 0 [ create-link-with turtle 1 show link-with turtle 1 ;; prints link 0 1 ] See also: in-link-from, out-link-to"
      ],
      "346": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: with-max \n\nEntry Data: with-max\nusage: agentset with-max [reporter] \n Takes two inputs: on the left, an agentset (usually \"turtles\" or \"patches\"). On the right, a reporter. Reports a new agentset containing all agents reporting the maximum value of the given reporter. show count patches with-max [pxcor] ;; prints the number of patches on the right edge See also max-one-of, max-n-of."
      ],
      "347": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: with-min \n\nEntry Data: with-min\nusage: agentset with-min [reporter] \n Takes two inputs: on the left, an agentset (usually \"turtles\" or \"patches\"). On the right, a reporter. Reports a new agentset containing only those agents that have the minimum value of the given reporter. show count patches with-min [pycor] ;; prints the number of patches on the bottom edge See also min-one-of, min-n-of."
      ],
      "348": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: with-local-randomness \n\nEntry Data: with-local-randomness\nusage: with-local-randomness [ commands ] \n The commands are run without affecting subsequent random events. This is useful for performing extra operations (such as output) without changing the outcome of a model. Example: ;; Run #1: random-seed 50 setup repeat 10 [ go ] ;; Run #2: random-seed 50 setup with-local-randomness [ watch one-of turtles ] repeat 10 [ go ] Since one-of is used inside with-local-randomness, both runs will be identical. Specifically how it works is, the state of the random number generator is remembered before the commands run, then restored afterwards. (If you want to run the commands with a fresh random state instead of the same random state that will be restored later, you can begin the commands with random-seed new-seed.) The following example demonstrates that the random number generator state is the same both before the commands run and afterwards. random-seed 10 with-local-randomness [ print n-values 10 [random 10] ] ;; prints [8 9 8 4 2 4 5 4 7 9] print n-values 10 [random 10] ;; prints [8 9 8 4 2 4 5 4 7 9]"
      ],
      "349": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: without-interruption \n\nEntry Data: without-interruption\nusage: without-interruption [ commands ] \n This primitive exists only for backwards compatibility. We don't recommend using it in new models. The agent runs all the commands in the block without allowing other agents using ask-concurrent to \"interrupt\". That is, other agents are put \"on hold\" and do not run any commands until the commands in the block are finished. Note: This command is only useful in conjunction with ask-concurrent. See also ask-concurrent."
      ],
      "350": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: word \n\nEntry Data: word\nusage: [('class', 'prim_example')](word value1 ...) \n Concatenates the inputs together and reports the result as a string. show word \"tur\" \"tle\" => \"turtle\" word \"a\" 6 => \"a6\" set directory \"c:\\\\foo\\\\fish\\\\\" show word directory \"bar.txt\" => \"c:\\foo\\fish\\bar.txt\" show word [1 54 8] \"fishy\" => \"[1 54 8]fishy\" show (word 3) => \"3\" show (word \"a\" \"b\" \"c\" 1 23) => \"abc123\""
      ],
      "351": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: world-dim \n\nEntry Data: world-dim\nusage: [('class', 'prim_example')]world-height \n These reporters give the total width and height of the NetLogo world. The width equals max-pxcor - min-pxcor + 1 and the height equals max-pycor - min-pycor + 1. See also max-pxcor, max-pycor, min-pxcor, and min-pycor"
      ],
      "352": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: wrap-color \n\nEntry Data: wrap-color\nusage: wrap-color number \n wrap-color checks whether number is in the NetLogo color range of 0 to 140 (not including 140 itself). If it is not, wrap-color \"wraps\" the numeric input to the 0 to 140 range. The wrapping is done by repeatedly adding or subtracting 140 from the given number until it is in the 0 to 140 range. (This is the same wrapping that is done automatically if you assign an out-of-range number to the color turtle variable or pcolor patch variable.) show wrap-color 150 => 10 show wrap-color -10 => 130"
      ],
      "353": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: write \n\nEntry Data: write\nusage: write value \n This command will output value, which can be a number, string, list, boolean, or nobody to the Command Center, not followed by a carriage return (unlike print and show). This agent is not printed before the value, unlike show. Its output also includes quotes around strings and is prepended with a space. write \"hello world\" => \"hello world\" See also print, show, type, output-write, and Output (programming guide)."
      ],
      "354": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: xcor \n\nEntry Data: xcor\nusage: xcor \n This is a built-in turtle variable. It holds the current x coordinate of the turtle. You can set this variable to change the turtle's location. This variable is always greater than or equal to (min-pxcor - 0.5) and strictly less than (max-pxcor + 0.5). See also setxy, ycor, pxcor, pycor,"
      ],
      "355": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: xor \n\nEntry Data: xor\nusage: boolean1 xor boolean2 \n Reports true if either boolean1 or boolean2 is true, but not when both are true. Otherwise returns false. See the programming guide for more information on logical operator precedence. if (pxcor > 0) xor (pycor > 0) [ set pcolor blue ] ;; upper-left and lower-right quadrants turn blue"
      ],
      "356": [
            "Represent this documentation section of official Netlogo documentation for retrieval:",
            "Here is a relevant example entry from the netlogo dictionary:\nSection Name: ycor \n\nEntry Data: ycor\nusage: ycor \n This is a built-in turtle variable. It holds the current y coordinate of the turtle. You can set this variable to change the turtle's location. This variable is always greater than or equal to (min-pycor - 0.5) and strictly less than (max-pycor + 0.5). See also setxy, xcor, pxcor, pycor, ->"
      ],
      "357": [
            "Represent this documentation section of Netlogo programmer's guide for retrieval:",
            "Here is a relevant example from the netlogo programmer's guide:\nSection Name: Agents \n\nEntry Data: Agents\nThe NetLogo world is made up of agents. Agents are beings that can follow\ninstructions.\nIn NetLogo, there are four types of agents: turtles, patches, links,\nand the observer.\nTurtles are agents that move around in the world. The world is two\ndimensional and is divided up into a grid of patches. Each patch is a square\npiece of \u201cground\u201d over which turtles can move. Links are agents that connect two\nturtles. The observer doesn\u2019t have a location \u2013 you can imagine it as looking\nout over the world of turtles and patches.\nThe observer doesn\u2019t observe passively \u2013 it gives instructions to the other\nagents.\nWhen NetLogo starts up, there are no turtles. The observer can make new turtles.\nPatches can make new turtles too. (Patches can\u2019t move, but otherwise they\u2019re\njust as \u201calive\u201d as turtles.)\nPatches have coordinates. The patch at coordinates (0, 0) is called the origin\nand the coordinates of the other patches are the horizontal and vertical\ndistances from this one. We call the patch\u2019s coordinates pxcor and\npycor. Just like in the standard mathematical coordinate plane,\npxcor increases as you move to the right and pycor increases\nas you move up.\nThe total number of patches is determined by the settings\nmin-pxcor, max-pxcor, min-pycor and\nmax-pycor. When NetLogo starts up, min-pxcor,\nmax-pxcor, min-pycor and max-pycor are\n-16, 16, -16, and 16 respectively. This means that pxcor and\npycor both range from -16 to 16, so there are 33 times 33, or 1089\npatches total. (You can change the number of patches with the Settings button.)\nTurtles have coordinates too: xcor and ycor. A patch\u2019s coordinates are\nalways integers, but a turtle\u2019s coordinates can have decimals. This means that a\nturtle can be positioned at any point within its patch; it doesn\u2019t have to be in\nthe center of the patch.\nLinks do not have coordinates. Every link has two ends, and each end is a\nturtle. If either turtle dies, the link dies too. A link is represented visually\nas a line connecting the two turtles.\n"
      ],
      "358": [
            "Represent this documentation section of Netlogo programmer's guide for retrieval:",
            "Here is a relevant example from the netlogo programmer's guide:\nSection Name: Procedures \n\nEntry Data: Procedures\nIn NetLogo, commands and reporters tell agents what to do. A command is\nan action for an agent to carry out, resulting in some effect. A reporter is\ninstructions for computing a value, which the agent then \u201creports\u201d to whoever\nasked it.\nTypically, a command name begins with a verb, such as \u201ccreate\u201d, \u201cdie\u201d, \u201cjump\u201d,\n\u201cinspect\u201d, or \u201cclear\u201d. Most reporter names are nouns or noun phrases.\nCommands and reporters built into NetLogo are called primitives.\nThe NetLogo Dictionary has a complete list of built-in\ncommands and reporters.\nCommands and reporters you define yourself are called procedures. Each\nprocedure has a name, preceded by the keyword to or to-report, depending\non whether it is a command procedure or a reporter procedure. The keyword\nend marks the end of the commands in the procedure. Once you define a\nprocedure, you can use it elsewhere in your program.\nMany commands and reporters take inputs \u2013 values that the command or\nreporter uses in carrying out its actions or computing its result.\nHere are two command procedures:\nto setup\n  clear-all\n  create-turtles 10\n  reset-ticks\nend\n\nto go\n  ask turtles [\n    fd 1            ;; forward 1 step\n    rt random 10    ;; turn right\n    lt random 10    ;; turn left\n  ]\n  tick\nend\n\nNote the use of semicolons to add \u201ccomments\u201d to the program. Comments can make\nyour code easier to read and understand, but they don\u2019t affect its behavior.\nIn this program,\n\nsetup and go are user-defined commands.\nclear-all, create-turtles, reset-ticks, ask, lt\n(\u201cleft turn\u201d), rt (\u201cright turn\u201d) and tick, are all primitive\ncommands.\nrandom and turtles are primitive reporters. random takes a single\nnumber as an input and reports a random integer that is less than the input\n(in this case, between 0 and 9). turtles reports the agentset consisting\nof all the turtles. (We\u2019ll explain about agentsets later.)\n\nsetup and go can be called by other procedures, or by buttons, or from the\nCommand Center.\nMany NetLogo models have a once button that calls a procedure called setup and\na forever button that calls a procedure called go.\nIn NetLogo, you may specify which agents \u2013 turtles, patches, or links \u2013 are to\nrun each command. If you don\u2019t specify, the code is run by the observer. In the\ncode above, the observer uses ask to make the set of all turtles run the\ncommands between the square brackets.\nclear-all and create-turtles can only be run by the observer.\nfd, on the other hand, can only be run by turtles. Some other\ncommands and reporters, such as set and ticks, can be run by different\nagent types.\nHere are some more advanced features you can take advantage of when defining\nyour own procedures.\nProcedures with inputs\nProcedures can take inputs, just like many primitives do. To create a procedure\nthat accepts inputs, put their names in square brackets after the procedure\nname. For example:\nto draw-polygon [num-sides len]  ;; turtle procedure\n  pen-down\n  repeat num-sides [\n    fd len\n    rt 360 / num-sides\n  ]\nend\n\nElsewhere in the program, you might use the procedure by asking the turtles to\neach draw an octagon with a side length equal to its who number:\nask turtles [ draw-polygon 8 who ]\n\nReporter procedures\nJust like you can define your own commands, you can define your own reporters.\nYou must do two special things. First, use to-report instead of to to\nbegin your procedure. Then, in the body of the procedure, use report to\nreport the value you want to report.\nto-report absolute-value [number]\n  ifelse number >= 0\n    [ report number ]\n    [ report (- number) ]\nend\n\n"
      ],
      "359": [
            "Represent this documentation section of Netlogo programmer's guide for retrieval:",
            "Here is a relevant example from the netlogo programmer's guide:\nSection Name: Variables \n\nEntry Data: Variables\nAgent variables\nAgent variables are places to store values (such as numbers) in an agent. An\nagent variable can be a global variable, a turtle variable, a patch variable, or\na link variable.\nIf a variable is a global variable, there is only one value for the variable,\nand every agent can access it. You can think of global variables as belonging to\nthe observer.\nTurtle, patch, and link variables are different. Each turtle has its own value\nfor every turtle variable. The same goes for patches and links.\nSome variables are built into NetLogo. For example, all turtles and links have a\ncolor variable, and all patches have a pcolor variable. (The patch\nvariable begins with \u201cp\u201d so it doesn\u2019t get confused with the turtle variable,\nsince turtles have direct access to patch variables.) If you set the variable,\nthe turtle or patch changes color. (See next section for details.)\nOther built-in turtle variables including xcor, ycor, and heading.\nOther built-in patch variables include pxcor and pycor. (There\nis a complete list here.)\nYou can also define your own variables. You can make a global variable by adding\na switch, slider, chooser, or input box to your model, or by using the\nglobals keyword at the beginning of your code, like this:\nglobals [score]\n\nYou can also define new turtle, patch and link variables using the\nturtles-own, patches-own and links-own keywords, like this:\nturtles-own [energy speed]\npatches-own [friction]\nlinks-own [strength]\n\nThese variables can then be used freely in your model. Use the set command\nto set them. (Any variable you don\u2019t set has a starting value of zero.)\nGlobal variables can be read and set at any time by any agent. As well, a turtle\ncan read and set patch variables of the patch it is standing on. For example,\nthis code:\nask turtles [ set pcolor red ]\n\ncauses every turtle to make the patch it is standing on red. (Because patch\nvariables are shared by turtles in this way, you can\u2019t have a turtle variable\nand a patch variable with the same name.)\nIn other situations where you want an agent to read a different agent\u2019s\nvariable, you can use of. Example:\nshow [color] of turtle 5\n;; prints current color of turtle with who number 5\n\nYou can also use of with a more complicated expression than just a variable\nname, for example:\nshow [xcor + ycor] of turtle 5\n;; prints the sum of the x and y coordinates of\n;; turtle with who number 5\n\nLocal variables\nA local variable is defined and used only in the context of a particular\nprocedure or part of a procedure. To create a local variable, use the let\ncommand. If you use let at the top of a procedure, the variable will exist\nthroughout the procedure. If you use it inside a set of square brackets, for\nexample inside an \u201cask\u201d, then it will exist only inside those brackets.\nto swap-colors [turtle1 turtle2]\n  let temp [color] of turtle1\n  ask turtle1 [ set color [color] of turtle2 ]\n  ask turtle2 [ set color temp ]\nend\n\n"
      ],
      "360": [
            "Represent this documentation section of Netlogo programmer's guide for retrieval:",
            "Here is a relevant example from the netlogo programmer's guide:\nSection Name: Tick counter \n\nEntry Data: Tick counter\nIn many NetLogo models, time passes in discrete steps, called \u201cticks\u201d. NetLogo\nincludes a built-in tick counter so you can keep track of how many ticks have\npassed.\nThe current value of the tick counter is shown above the view. (You can use the\nSettings button to hide the tick counter, or change the word \u201cticks\u201d to\nsomething else.)\nIn code, to retrieve the current value of the tick counter, use the ticks\nreporter. The tick command advances the tick counter by 1. The clear-all\ncommand clears the tick counter along with everything else.\nWhen the tick counter is clear, it\u2019s an error to try to read or modify it. Use\nthe reset-ticks command when your model is done setting up, to start the\ntick counter.\nIf your model is set to use tick-based updates, then the tick command will\nusually also update the view. See the later section,\nView Updates.\nWhen to tick\nUse reset-ticks at the end of your setup procedure.\nUse tick at the end of your go procedure.\nto setup\n  clear-all\n  create-turtles 10\n  reset-ticks\nend\n\nto go\n  ask turtles [ fd 1 ]\n  tick\nend\n\nFractional ticks\nIn most models, the tick counter starts at 0 and goes up 1 at a time, from\ninteger to integer. But it\u2019s also possible for the tick counter to take on\nin-between floating point values.\nTo advance the tick counter by a fractional amount, use the tick-advance\ncommand. This command takes a numeric input specifying how far to advance the\ntick counter.\nA typical use of fractional ticks is to approximate continuous or curved motion.\nSee, for example, the GasLab models in the Models Library (under\nChemistry & Physics). These models calculate the exact time at which a future\nevent is to occur, then advance the tick counter to exactly that time.\n"
      ],
      "361": [
            "Represent this documentation section of Netlogo programmer's guide for retrieval:",
            "Here is a relevant example from the netlogo programmer's guide:\nSection Name: Colors \n\nEntry Data: Colors\nNetLogo represents colors in different ways. A color can be number in the range\n0 to 140, with the exception of 140 itself. Below is a chart showing the range\nof such NetLogo colors.\n\nThe chart shows that:\n\nSome of the colors have names. (You can use these names in your code.)\nEvery named color except black and white has a number ending in 5.\nOn either side of each named color are darker and lighter shades of the color.\n0 is pure black. 9.9 is pure white.\n10, 20, and so on are all so dark they are very nearly black.\n19.9, 29.9 and so on are all so light they are very nearly white.\n\n\nCode Example: The color chart was made in NetLogo with the Color Chart\nExample model.\n\nIf you use a number outside the 0 to 140 range, NetLogo will repeatedly add or\nsubtract 140 from the number until it is in the 0 to 140 range. For example, 25\nis orange, so 165, 305, 445, and so on are orange too, and so are -115, -255,\n-395, etc. This calculation is done automatically whenever you set the turtle\nvariable color or the patch variable pcolor. Should you need to perform\nthis calculation in some other context, use the wrap-color primitive.\nIf you want a color that\u2019s not on the chart, more exist between the integers.\nFor example, 26.5 is a shade of orange halfway between 26 and 27. This doesn\u2019t\nmean you can make any color in NetLogo; the NetLogo color space is only a subset\nof all possible colors. It contains only a fixed set of discrete hues (one hue\nper row of the chart). Starting from one of those hues, you can either decrease\nits brightness (darken it) or decrease its saturation (lighten it), but you\ncannot decrease both brightness and saturation. Also, only the first digit after\nthe decimal point is significant. Thus, color values are rounded down to the\nnext 0.1, so for example, there\u2019s no visible difference between 26.5 and 26.52\nor 26.58.\nColor primitives\nThere are a few primitives that are helpful for working with colors.\nWe have already mentioned the wrap-color primitive.\nThe scale-color primitive is useful for converting numeric data into colors.\nshade-of? will tell you if two colors are both \u201cshades\u201d of the same basic\nhue. For example, shade-of? orange 27 is true, because 27 is a lighter shade\nof orange.\n\nCode Example: Scale-color Example demonstrates the scale-color reporter.\n\nRGB and RGBA Colors\nNetLogo also represents colors as RGB (red/green/blue) lists and RGBA\n(red/green/blue/alpha) lists. When using RGB colors the full range of colors is\navailable to you. RGBA colors allow all the colors that RGB allows and you can\nalso vary the transparency of a color. RGB and RGBA lists are made up of three\nor four integers, respectively, between 0 and 255. You can set any\ncolor variables in NetLogo (color for turtles and links and pcolor for\npatches) to an RGB list and that agent will be rendered appropriately. So you\ncan set the color of patch 0 0 to pure red using the following code:\nset pcolor [255 0 0]\n\nTurtles, links, and labels can all contain RGBA lists as their color variables.\nPatches only use the alpha value of an RGBA pcolors in NetLogo 3D, it\u2019s\nignored in 2D NetLogo. You can set the color of a turtle to be approximately\nhalf transparent pure red with the following code:\nset color [255 0 0 125]\n\nYou can convert from a NetLogo color to RGB or HSB (hue/saturation/brightness)\nusing extract-hsb and extract-rgb. You can use rgb to generate rgb\nlists and hsb to convert from an HSB color to RGB.\nSince many colors are missing from the NetLogo color space, approximate-hsb\nand approximate-rgb often can\u2019t give you the exact color you ask for, but\nthey try to come as close as possible.\nExample:\nlet my-color approximate-rgb 0 0 255 ;; my-color is now 104.7\nshow extract-rgb my-color ;; shows [48 88 161] which is pretty far from [0 0 255], the color we started with\n\nThis is an approximation, but it is still near NetLogo blue which is 105.\nUsing RGBA colors, the user has more options when it comes to an agent\u2019s color.\nExample: you can change any turtle from its existing NetLogo color to a sixty percent transparent version of that color using:\nask one-of turtles [set color lput 102 extract-rgb color]\n\nNote: because 255 is fully opaque and sixty percent transparent is equal to forty percent opaque, the correct alpha value is  255 * .4 = 102.\nSee the palette extension section below for an alternate implementation.\n\nCode Examples: HSB and RGB Example (lets you experiment with the HSB and\nRGB color systems), Transparency Example\n\nPalette Extension\nThe palette extension offers primitives that give the user more control over colors. It allows for direct\nmanipulation of RGBA and HSB components without the requiring list manipulations.\nExample: changing the transparency of any turtle to sixty percent transparent with the palette extension:\nextensions [palette]\nask one-of turtles [palette:set-transparency 60]\n\nThe extension offers similar commands for Red, Green, Blue, Alpha, Hue, Saturation, and Brightness.\nSee the documentation of the palette extension for more information.\n\nCode Examples: Palette Example, Color Bubbles, Color Painting, Color Reveal\n\nColor Swatches dialog\nThe Color Swatches dialog helps you experiment with and choose colors. Open it\nby choosing Color Swatches on the Tools Menu.\n\nWhen you click on a color swatch (or a color button), that color will be shown\nagainst other colors. In the bottom left, the code for the currently selected\ncolor is displayed (for example, red + 2) so you can copy and paste it into\nyour code. On the bottom right there are three increment options, 1, 0.5, and\n0.1. These numbers indicate the difference between two adjacent swatches. When\nthe increment is 1 there are 10 different shades in each row; when the increment\nis 0.1 there are 100 different shades in each row. 0.5 is an intermediate\nsetting.\n"
      ],
      "362": [
            "Represent this documentation section of Netlogo programmer's guide for retrieval:",
            "Here is a relevant example from the netlogo programmer's guide:\nSection Name: Ask \n\nEntry Data: Ask\nNetLogo uses the ask command to give commands to turtles, patches, and\nlinks. All code to be run by turtles must be located in a turtle \u201ccontext\u201d.\nYou can establish a turtle context in any of three ways:\n\nIn a button, by choosing \u201cTurtles\u201d from the popup menu. Any code you put in\nthe button will be run by all turtles.\nIn the Command Center, by choosing \u201cTurtles\u201d from the popup menu. Any commands\nyou enter will be run by all the turtles.\nBy using ask turtles, hatch, or other commands which establish a turtle\ncontext.\n\nThe same goes for patches, links, and the observer, except that you cannot\nask the observer. Any code that is not inside any ask is by default\nobserver code.\nBecause agentset members are always read in a random order, when ask is used with\nan agentset each agent will take its turn in a random order. See Agentsets\nfor more information.\nHere\u2019s an example of the use of ask in a NetLogo procedure:\nto setup\n  clear-all\n  create-turtles 100   ;; create 100 turtles with random headings\n  ask turtles\n    [ set color red    ;; turn them red\n      fd 50 ]          ;; spread them around\n  ask patches\n    [ if pxcor > 0         ;; patches on the right side\n        [ set pcolor green ] ]  ;; of the view turn green\n  reset-ticks\nend\n\nThe models in the Models Library are full of other examples. A good place to\nstart looking is in the Code Examples section.\nUsually, the observer uses ask to ask all turtles, all patches or all links\nto run commands. You can also use ask to have an individual turtle, patch or\nlink run commands. The reporters turtle, patch, link and\npatch-at are useful for this technique. For example:\nto setup\n  clear-all\n  crt 3                           ;; make 3 turtles\n  ask turtle 0                    ;; tell the first one...\n    [ fd 1 ]                      ;; ...to go forward\n  ask turtle 1                    ;; tell the second one...\n    [ set color green ]           ;; ...to become green\n  ask turtle 2                    ;; tell the third one...\n    [ rt 90 ]                     ;; ...to turn right\n  ask patch 2 -2                  ;; ask the patch at (2,-2)\n    [ set pcolor blue ]           ;; ...to become blue\n  ask turtle 0                    ;; ask the first turtle\n    [ ask patch-at 1 0            ;; ...to ask patch to the east\n      [ set pcolor red ] ]        ;; ...to become red\n  ask turtle 0                    ;; tell the first turtle...\n    [ create-link-with turtle 1 ] ;; ...make a link with the second\n  ask link 0 1                    ;; tell the link between turtle 0 and 1\n    [ set color blue ]            ;; ...to become blue\n  reset-ticks\nend\n\nEvery turtle created has a who number. The first turtle created is number 0, the\nsecond turtle number 1, and so forth.\nThe turtle primitive reporter takes a who number as an input, and reports\nthe turtle with that who number. The patch primitive reporter takes values\nfor pxcor and pycor and reports the patch with those coordinates. The link\nprimitive takes two inputs, the who numbers of the two turtles it connects. And\nthe patch-at primitive reporter takes offsets: distances, in the x and y\ndirections, from the first agent. In the example setup procedure above, the\nturtle with who number 0 is asked to get the patch east (and no patches north)\nof itself like this: ask turtle 0 [ ask patch-at 1 0 [ set pcolor red ] ].\nYou can also select a subset of turtles, or a subset of patches, or a subset of\nlinks and ask them to do something. This involves using agentsets. The next\nsection explains them in detail.\nWhen you ask a set of agents to run more than one command, each agent must\nfinish before the next agent starts. One agent runs all of the commands, then\nthe next agent runs all of them, and so on. For example, if you write:\nask turtles\n  [ fd 1\n    set color red ]\n\nfirst one turtle moves and turns red, then another turtle moves and turns red,\nand so on.\nBut if you write it this way:\nask turtles [ fd 1 ]\nask turtles [ set color red ]\n\nfirst all the turtles move, then they all turn red.\n"
      ],
      "363": [
            "Represent this documentation section of Netlogo programmer's guide for retrieval:",
            "Here is a relevant example from the netlogo programmer's guide:\nSection Name: Agentsets \n\nEntry Data: Agentsets\nAn agentset is exactly what its name implies, a set of agents. An agentset can\ncontain either turtles, patches or links, but not more than one type at once.\nAn agentset is not in any particular order. In fact, it\u2019s always in a random\norder. And every time you use it, the agentset is in a different random order.\nThis helps you keep your model from treating any particular turtles, patches or\nlinks differently from any others (unless you want them to be). Since the order\nis random every time, no one agent always gets to go first.\nYou\u2019ve seen the turtles primitive, which reports the agentset of all\nturtles, the patches primitive, which reports the agentset of all patches\nand the links primitive which reports the agentset of all links.\nBut what\u2019s powerful about the agentset concept is that you can construct\nagentsets that contain only some turtles, some patches or some links. For\nexample, all the red turtles, or the patches with pxcor evenly divisible by\nfive, or the turtles in the first quadrant that are on a green patch or the\nlinks connected to turtle 0. These agentsets can then be used by ask or by\nvarious reporters that take agentsets as inputs.\nOne way is to use turtles-here or turtles-at, to make an agentset\ncontaining only the turtles on my patch, or only the turtles on some other patch\nat some x and y offsets. There\u2019s also turtles-on so you can get the set of\nturtles standing on a given patch or set of patches, or the set of turtles\nstanding on the same patch as a given turtle or set of turtles.\nHere are some more examples of how to make agentsets:\n;; all other turtles:\nother turtles\n;; all other turtles on this patch:\nother turtles-here\n;; all red turtles:\nturtles with [color = red]\n;; all red turtles on my patch\nturtles-here with [color = red]\n;; patches on right side of view\npatches with [pxcor > 0]\n;; all turtles less than 3 patches away\nturtles in-radius 3\n;; the four patches to the east, north, west, and south\npatches at-points [[1 0] [0 1] [-1 0] [0 -1]]\n;; shorthand for those four patches\nneighbors4\n;; turtles in the first quadrant that are on a green patch\nturtles with [(xcor > 0) and (ycor > 0)\n              and (pcolor = green)]\n;; turtles standing on my neighboring four patches\nturtles-on neighbors4\n;; all the links connected to turtle 0\n[my-links] of turtle 0\n\nNote the use of other to exclude this agent. This is common.\nOnce you have created an agentset, here are some simple things you can do:\n\nUse ask to make the agents in the agentset do something\nUse any? to see if the agentset is empty\nUse all? to see if every agent in an agentset satisfies a condition.\nUse count to find out exactly how many agents are in the set\n\nAnd here are some more complex things you can do:\n\n\nPick a random agent from the set using one-of. For example, we can make a\nrandomly chosen turtle turn green:\nask one-of turtles [ set color green ]\n\nOr tell a randomly chosen patch to sprout a new turtle:\nask one-of patches [ sprout 1 ]\n\n\n\nUse the max-one-of or\nmin-one-of reporters to find out which agent\nis the most or least along some scale. For example, to remove the richest\nturtle, you could say\nask max-one-of turtles [sum assets] [ die ]\n\n\n\nMake a histogram of the agentset using the histogram command (in\ncombination with of).\n\nUse of to make a list of values, one for each agent in the agentset. Then\nuse one of NetLogo\u2019s list primitives to do something with the list. (See the\n\u201cLists\u201d section below.) For example, to find out how rich turtles\nare on the average, you could say\nshow mean [sum assets] of turtles\n\n\n\nUse turtle-set, patch-set and link-set reporters to make new\nagentsets by gathering together agents from a variety of possible sources.\n\nUse no-turtles, no-patches and no-links reporters to make empty\nagentsets.\nCheck whether two agentsets are equal using = or !=.\nUse member? to see whether a particular agent is a member of an agentset.\n\nThis only scratches the surface. See the Models Library for many more examples,\nand consult the NetLogo Dictionary for more information about all of the\nagentset primitives.\nMore examples of using agentsets are provided in the individual entries for\nthese primitives in the NetLogo Dictionary.\nSpecial agentsets\nThe agentsets turtles and links have special behavior because they always\nhold the sets of all turtles and all links. Therefore, these agentsets can\ngrow.\nThe following interaction shows the special behavior. Assume the Code tab has\nglobals [g]. Then:\nobserver> clear-all\nobserver> create-turtles 5\nobserver> set g turtles\nobserver> print count g\n5\nobserver> create-turtles 5\nobserver> print count g\n10\nobserver> set g turtle-set turtles\nobserver> print count g\n10\nobserver> create-turtles 5\nobserver> print count g\n10\nobserver> print count turtles\n15\n\nThe turtles agentset grows when new turtles are born, but other agentsets\ndon\u2019t grow. If I write turtle-set turtles, I get a new, normal agentset\ncontaining just the turtles that currently exist. New turtles don\u2019t join when\nthey\u2019re born.\nBreed agentsets are special in the same way as turtles and links. Breeds are\nintroduced and explained below.\nAgentsets and lists\nEarlier, we said that agentsets are always in random order, a different random\norder every time. If you need your agents to do something in a fixed order, you\nneed to make a list of the agents instead. See the Lists section below.\n\nCode Example: Ask Ordering Example\n\n"
      ],
      "364": [
            "Represent this documentation section of Netlogo programmer's guide for retrieval:",
            "Here is a relevant example from the netlogo programmer's guide:\nSection Name: Breeds \n\nEntry Data: Breeds\nNetLogo allows you to define different \u201cbreeds\u201d of turtles and breeds of links.\nOnce you have defined breeds, you can go on and make the different breeds behave\ndifferently. For example, you could have breeds called sheep and wolves, and\nhave the wolves try to eat the sheep or you could have link breeds called\nstreets and sidewalks where foot traffic is routed on sidewalks and car\ntraffic is routed on streets.\nYou define turtle breeds using the breed keyword, at the top of the Code\ntab, before any procedures:\nbreed [wolves wolf]\nbreed [sheep a-sheep]\n\nYou can refer to a member of the breed using the singular form, just like the\nturtle reporter. When printed, members of the breed will be labeled with the\nsingular name.\nSome commands and reporters have the plural name of the breed in them, such as\ncreate-<breeds>. Others have the singular name of the breed\nin them, such as <breed>.\nThe order in which breeds are declared is also the order in which they are\nlayered in the view. So breeds defined later will appear on top of breeds\ndefined earlier; in this example, sheep will be drawn over wolves.\nWhen you define a breed such as sheep, an agentset for that breed is\nautomatically created, so that all of the agentset capabilities described above\nare immediately available with the sheep agentset.\nThe following new primitives are also automatically available once you define a\nbreed: create-sheep, hatch-sheep,\nsprout-sheep, sheep-here, sheep-at,\nsheep-on, and is-a-sheep?.\nAlso, you can use sheep-own to define new turtle variables that\nonly turtles of the given breed have. (It\u2019s allowed for more than one breed to\nown the same variable.)\nA turtle\u2019s breed agentset is stored in the breed turtle variable.\nSo you can test a turtle\u2019s breed, like this:\nif breed = wolves [ ... ]\n\nNote also that turtles can change breeds. A wolf doesn\u2019t have to remain a wolf\nits whole life. Let\u2019s change a random wolf into a sheep:\nask one-of wolves [ set breed sheep ]\n\nThe set-default-shape primitive is useful for associating certain turtle\nshapes with certain breeds. See the section on shapes below.\nWho numbers are assigned irrespective of breeds. If you already have a frog 0,\nthen the first mouse will be mouse 1, not mouse 0, since the who number 0 is\nalready taken.\nHere is a quick example of using breeds:\nbreed [mice mouse]\nbreed [frogs frog]\nmice-own [cheese]\nto setup\n  clear-all\n  create-mice 50\n    [ set color white\n      set cheese random 10 ]\n  create-frogs 50\n    [ set color green ]\n  reset-ticks\nend\n\n\nCode Example: Breeds and Shapes Example\n\nLink breeds\nLink breeds are very similar to turtle breeds, however, there are a few\ndifferences.\nWhen you declare a link breed you must declare whether it is a breed of directed\nor undirected links by using the directed-link-breed and\nundirected-link-breed keywords.\ndirected-link-breed [streets street]\nundirected-link-breed [friendships friendship]\n\nOnce you have created a breeded link you cannot create unbreeded links and vice\nversa. (You can, however, have directed and undirected links in the same world,\njust not in the same breed)\nUnlike with turtle breeds the singular breed name is required for link breeds,\nas many of the link commands and reports use the singular name, such as\n<link-breed>-neighbor?.\nThe following primitives are also automatically available once you define a\ndirected link breed: create-street-from\ncreate-streets-from create-street-to\ncreate-streets-to in-street-neighbor?\nin-street-neighbors in-street-from\nmy-in-streets my-out-streets\nout-street-neighbor?\nout-street-neighbors out-street-to\nAnd the following are automatically available when you define an undirected link\nbreed: create-friendship-with\ncreate-friendships-with friendship-neighbor?\nfriendship-neighbors friendship-with\nmy-friendships\nMultiple link breeds may declare the same -own variable, but a variable may\nnot be shared between a turtle breed and a link breed.\nJust as with turtle breeds the order in which link breeds are declared defines\nthe order in which the links are drawn, so the friendships will always be on top\nof streets (if for some reason these breeds were in the same model). You can\nalso use <link-breeds>-own to declare variables of each link breed\nseparately.\nYou can change the breed of a link with set breed. (However, you cannot change\na breeded link to an unbreeded one, to prevent having breeded and unbreeded\nlinks in the same world.)\nask one-of friendships [ set breed streets ]\nask one-of friendships [ set breed links ] ;; produces a runtime error\n\nset-default-shape may also be used with link breeds to associate it with a\nparticular link shape.\n\nCode Example: Link Breeds Example\n\n"
      ],
      "365": [
            "Represent this documentation section of Netlogo programmer's guide for retrieval:",
            "Here is a relevant example from the netlogo programmer's guide:\nSection Name: Buttons \n\nEntry Data: Buttons\nButtons in the interface tab provide an easy way to control the model. Typically\na model will have at least a \u201csetup\u201d button, to set up the initial state of the\nworld, and a \u201cgo\u201d button to make the model run continuously. Some models will\nhave additional buttons that perform other actions.\nA button contains some NetLogo code. That code is run when you press the button.\nA button may be either a \u201conce button\u201d, or a \u201cforever button\u201d. You can control\nthis by editing the button and checking or unchecking the \u201cForever\u201d checkbox.\nOnce buttons run their code once, then stop and pop back up. Forever buttons\nkeep running their code over and over again.\nA forever button stops if the user presses the button again to stop it. The\nbutton waits until the current iteration has finished, then pops up.\nA forever button can also be stopped from\ncode. If the forever button directly calls a procedure, then when that procedure\nstops, the button stops. (In a turtle or patch forever button, the button won\u2019t\nstop until every turtle or patch stops \u2013 a single turtle or patch doesn\u2019t have\nthe power to stop the whole button.)\nNormally, a button is labeled with the code that it runs. For example, a button\nthat says \u201cgo\u201d on it usually contains the code \u201cgo\u201d, which means \u201crun the go\nprocedure\u201d. (Procedures are defined in the Code tab; see below.) But you can\nalso edit a button and enter a \u201cdisplay name\u201d for the button, which is a text\nthat appears on the button instead of the code. You might use this feature if\nyou think the actual code would be confusing to your users.\nWhen you put code in a button, you must also specify which agents you want to\nrun that code. You can choose to have the observer run the code, or all turtles,\nor all patches, or all links. (If you want the code to be run by only some\nturtles or some patches, you could make an observer button, and then have the\nobserver use the ask command to ask only some of the turtles or patches to\ndo something.)\nWhen you edit a button, you have the option to assign an \u201caction key\u201d. This\nmakes that key on the keyboard behave just like a button press. If the button is\na forever button, it will stay down until the key is pressed again (or the\nbutton is clicked). Action keys are particularly useful for games or any model\nwhere rapid triggering of buttons is needed.\nButtons take turns\nMore than one button can be pressed at a time. If this happens, the buttons\n\u201ctake turns\u201d, which means that only one button runs at a time. Each button runs\nits code all the way through once while the other buttons wait, then the next\nbutton gets its turn.\nIn the following examples, \u201csetup\u201d is a once button and \u201cgo\u201d is a forever\nbutton.\nExample #1: The user presses \u201csetup\u201d, then presses \u201cgo\u201d immediately, before the\n\u201csetup\u201d has popped back up. Result: \u201csetup\u201d finishes before \u201cgo\u201d starts.\nExample #2: While the \u201cgo\u201d button is down, the user presses \u201csetup\u201d. Result: the\n\u201cgo\u201d button finishes its current iteration. Then the \u201csetup\u201d button runs. Then\n\u201cgo\u201d starts running again.\nExample #3: The user has two forever buttons down at the same time. Result:\nfirst one button runs its code all the way through, then the other runs its code\nall the way through, and so on, alternating.\nNote that if one button gets stuck in an infinite loop, then no other buttons\nwill run.\nTurtle, patch, and link forever buttons\nThere is a subtle difference between putting commands in a turtle, patch or link\nforever button, and putting the same commands in an observer button that does\nask turtles, ask patches or ask links. An \u201cask\u201d doesn\u2019t complete until all\nof the agents have finished running all of the commands in the \u201cask\u201d. So the\nagents, as they all run the commands concurrently, can be out of sync with each\nother, but they all sync up again at the end of the ask. The same isn\u2019t true of\nturtle, patch and link forever buttons. Since ask was not used, each turtle\nor patch runs the given code over and over again, so they can become (and\nremain) out of sync with each other.\nAt present, this capability is very rarely used in the models in our Models\nLibrary. A model that does use the capability is the Termites model, in the\nBiology section of Sample Models. The \u201cgo\u201d button is a turtle forever button, so\neach termite proceeds independently of every other termite, and the observer is\nnot involved at all. This means that if, for example, you wanted to add ticks\nand/or a plot to the model, you would need to add a second forever button (an\nobserver forever button), and run both forever buttons at the same time. Note\nalso that a model like this cannot be used with BehaviorSpace.\n\nCode Example: State Machine Example shows how Termites can be recoded in a\ntick-based way, without using a turtle forever button.\n\nAt present, NetLogo has no way for one forever button to start another. Buttons\nare only started when you press them.\n"
      ],
      "366": [
            "Represent this documentation section of Netlogo programmer's guide for retrieval:",
            "Here is a relevant example from the netlogo programmer's guide:\nSection Name: Lists \n\nEntry Data: Lists\nIn the simplest models, each variable holds only one piece of information,\nusually a number or a string. Lists let you store multiple pieces of information\nin a single value by collecting that information in a list. Each value in the\nlist can be any type of value: a number, or a string, an agent or agentset, or\neven another list.\nLists allow for the convenient packaging of information in NetLogo. If your\nagents carry out a repetitive calculation on multiple variables, it might be\neasier to have a list variable, instead of multiple number variables. Several\nprimitives simplify the process of performing the same computation on each value\nin a list.\nThe NetLogo Dictionary has a section that lists all of the\nlist-related primitives.\nConstant lists\nYou can make a list by simply putting the values you want in the list between\nbrackets, like this: set mylist [2 4 6 8]. Note that the individual values are\nseparated by spaces. You can make lists that contain numbers and strings this\nway, as well as lists within lists, for example [[2 4] [3 5]].\nThe empty list is written by putting nothing between the brackets, like this:\n[].\nBuilding lists on the fly\nIf you want to make a list in which the values are determined by reporters, as\nopposed to being a series of constants, use the list reporter. The list\nreporter accepts two other reporters, runs them, and reports the results as a\nlist.\nIf I wanted a list to contain two random values, I might use the following code:\nset random-list list (random 10) (random 20)\n\nThis will set random-list to a new list of two random integers each time it\nruns.\nTo make longer or shorter lists, you can use the list reporter with fewer or\nmore than two inputs, but in order to do so, you must enclose the entire call in\nparentheses, e.g.:\n(list random 10)\n(list random 10 random 20 random 30)\n\nFor more information, see Varying number of inputs.\nSome kinds of lists are most easily built using the n-values reporter, which\nallows you to construct a list of a specific length by repeatedly running a\ngiven reporter. You can make a list of the same value repeated, or all the\nnumbers in a range, or a lot of random numbers, or many other possibilities. See\ndictionary entry for details and examples.\nThe of primitive lets you construct a list from an agentset. It reports a\nlist containing each agent\u2019s value for the given reporter. (The reporter could\nbe a simple variable name, or a more complex expression \u2013 even a call to a\nprocedure defined using to-report.) A common idiom is\nmax [...] of turtles\nsum [...] of turtles\n\nand so on.\nYou can combine two or more lists using the sentence reporter, which\nconcatenates lists by combining their contents into a single, larger list. Like\nlist, sentence normally takes two inputs, but can accept any number of\ninputs if the call is surrounded by parentheses.\nChanging list items\nTechnically, lists can\u2019t be modified, but you can construct new lists based on\nold lists. If you want the new list to replace the old list, use set. For\nexample:\nset mylist [2 7 5 Bob [3 0 -2]]\n; mylist is now [2 7 5 Bob [3 0 -2]]\nset mylist replace-item 2 mylist 10\n; mylist is now [2 7 10 Bob [3 0 -2]]\n\nThe replace-item reporter takes three inputs. The first input specifies\nwhich item in the list is to be changed. 0 means the first item, 1 means the\nsecond item, and so forth.\nTo add an item, say 42, to the end of a list, use the lput reporter.\n(fput adds an item to the beginning of a list.)\nset mylist lput 42 mylist\n; mylist is now [2 7 10 Bob [3 0 -2] 42]\n\nBut what if you changed your mind? The but-last (bl for\nshort) reporter reports all the list items but the last.\nset mylist but-last mylist\n; mylist is now [2 7 10 Bob [3 0 -2]]\n\nSuppose you want to get rid of item 0, the 2 at the beginning of the list.\nset mylist but-first mylist\n; mylist is now [7 10 Bob [3 0 -2]]\n\nSuppose you wanted to change the third item that\u2019s nested inside item 3 from -2\nto 9? The key is to realize that the name that can be used to call the nested\nlist [3 0 -2] is item 3 mylist. Then the replace-item reporter can be\nnested to change the list-within-a-list. The parentheses are added for clarity.\nset mylist (replace-item 3 mylist\n                  (replace-item 2 (item 3 mylist) 9))\n; mylist is now [7 10 Bob [3 0 9]]\n\nIterating over lists\nIf you want to do some operation on each item in a list in turn, the foreach\ncommand and the map reporter may be helpful.\nforeach is used to run a command or commands on each item in a list. It\ntakes an input list and a command name or block of commands, like this:\nforeach [1 2 3] show\n=> 1\n=> 2\n=> 3\nforeach [2 4 6]\n  [ n -> crt n\n    show (word \"created \" n \" turtles\") ]\n=> created 2 turtles\n=> created 4 turtles\n=> created 6 turtles\n\nIn the block, the variable n holds the current value from the input list.\nHere are some more examples of foreach:\nforeach [1 2 3] [ steps -> ask turtles [ fd steps ] ]\n;; turtles move forward 6 patches\nforeach [true false true true] [ should-move? -> ask turtles [ if should-move? [ fd 1 ] ] ]\n;; turtles move forward 3 patches\n\nmap is similar to foreach, but it is a reporter. It takes an input list\nand a reporter name or reporter block. Note that unlike foreach, the\nreporter comes first, like this:\nshow map round [1.2 2.2 2.7]\n;; prints [1 2 3]\n\nmap reports a list containing the results of applying the reporter to each\nitem in the input list. Again, use the variable named in the anonymous procedure\n(x in the examples below) to refer to the current item in the list.\nHere are a couple more examples of map:\nshow map [ x -> x < 0 ] [1 -1 3 4 -2 -10]\n;; prints [false true false false true true]\nshow map [ x -> x * x ] [1 2 3]\n;; prints [1 4 9]\n\nBesides map and foreach, other primitives for processing whole lists in a\nconfigurable way include filter, reduce, and sort-by.\nThese primitives aren\u2019t always the solution for every situation in which you\nwant to operate on an entire list. In some situations, you may need to use some\nother technique such as a loop using repeat or while, or a recursive\nprocedure.\nThe blocks of code we\u2019re giving to map and foreach in these examples are\nactually anonymous procedures. Anonymous procedures are explained in more\ndetail in Anonymous procedures, below.\nVarying number of inputs\nSome commands and reporters involving lists and strings may take a varying\nnumber of inputs. In these cases, in order to pass them a number of inputs other\nthan their default, the primitive and its inputs must be surrounded by\nparentheses. Here are some examples:\nshow list 1 2\n=> [1 2]\nshow (list 1 2 3 4)\n=> [1 2 3 4]\nshow (list)\n=> []\n\nNote that each of these special primitives has a default number of inputs for\nwhich no parentheses are required. The primitives which have this capability are\nlist, word, sentence, map, foreach, run, and\nrunresult.\nLists of agents\nEarlier, we said that agentsets are always in random order, a different random\norder every time. If you need your agents to do something in a fixed order, you\nneed to make a list of the agents instead.\nThere are two primitives that help you do this, sort and sort-by.\nBoth sort and sort-by can take an agentset as input. The result is\nalways a new list, containing the same agents as the agentset did, but in a\nparticular order.\nIf you use sort on an agentset of turtles, the result is a list of turtles\nsorted in ascending order by who number.\nIf you use sort on an agentset of patches, the result is a list of patches\nsorted left-to-right, top-to-bottom.\nIf you use sort on an agentset of links, the result is a list of links,\nsorted in ascending order first by end1 then by end2 any remaining ties\nare resolved by breed in the order they are declared in the Code\ntab.\nIf you need descending order instead, you can combine reverse with sort,\nfor example reverse sort turtles.\nIf you want your agents to be ordered by some other criterion than the standard\nones sort uses, you\u2019ll need to use sort-by instead.\nHere\u2019s an example:\nsort-by [ [a b] -> [size] of a < [size] of b ] turtles\n\nThis returns a list of turtles sorted in ascending order by their turtle\nvariable size.\nThere\u2019s a common pattern to get a list of agents in a random order, using a\ncombination of of and self, in the rare case that you cannot just use\nask:\n[self] of my-agentset\n\nAsking a list of agents\nOnce you have a list of agents, you might want to ask them each to do something.\nTo do this, use the foreach and ask commands in combination, like this:\nforeach sort turtles [ the-turtle ->\n  ask the-turtle [\n    ...\n  ]\n]\n\nThis will ask each turtle in ascending order by who number. Substitute \u201cpatches\u201d\nfor \u201cturtles\u201d to ask patches in left-to-right, top-to-bottom order.\nNote that you can\u2019t use ask directly on a list of turtles. ask only\nworks with agentsets and single agents.\nPerformance of lists\nThe data structure underlying NetLogo\u2019s lists is a sophisticated tree-based data\nstructure on which most operations run in near-constant time. That includes\nfput, lput, butfirst, butlast, length, item, and replace-item.\nOne exception to the fast-performance rule is that concatenating two lists with\nsentence requires traversing and copying the whole second list. (This may be\nfixed in a future version.)\nTechnically, \u201cnear-constant time\u201d is actually logarithmic time, proportional to\nthe depth of the underlying tree, but these trees have large nodes and a high\nbranching factor, so they are never more than a few levels deep. This means that\nchanges can be made in at most a few steps. The trees are immutable, but they\nshare structure with each other, so the whole tree doesn\u2019t need to be copied to\nmake a changed version.\nThe actual data structure used is the immutable Vector class from the Scala\ncollections library. These are 32-wide\nhash array mapped tries,\nas implemented by Tiark Rompf, based in part on work by Phil Bagwell and Rich\nHickey.\n"
      ],
      "367": [
            "Represent this documentation section of Netlogo programmer's guide for retrieval:",
            "Here is a relevant example from the netlogo programmer's guide:\nSection Name: Math \n\nEntry Data: Math\nAll numbers in NetLogo are stored internally as double precision floating point\nnumbers, as defined in the IEEE 754 standard. They are 64 bit numbers consisting\nof one sign bit, an 11-bit exponent, and a 52-bit mantissa. See the IEEE 754\nstandard for details.\nAn \u201cinteger\u201d in NetLogo is simply a number that happens to have no fractional\npart. No distinction is made between 3 and 3.0; they are the same number. (This\nis the same as how most people use numbers in everyday contexts, but different\nfrom some programming languages. Some languages treat integers and floating\npoint numbers as distinct types.)\nIntegers are always printed by NetLogo without the trailing \u201c.0\u201d:\nshow 1.5 + 1.5\nobserver: 3\n\nIf a number with a fractional part is supplied in a context where an integer is\nexpected, the fractional part is simply discarded. So for example, crt 3.5\ncreates three turtles; the extra 0.5 is ignored.\nThe range of integers is +/-9007199254740992 (2^53, about 9 quadrillion).\nCalculations that exceed this range will not cause runtime errors, but precision\nwill be lost when the least significant (binary) digits are rounded off in order\nfit the number into 64 bits. With very large numbers, this rounding can result\nin imprecise answers which may be surprising:\nshow 2 ^ 60 + 1 = 2 ^ 60\n=> true\n\nCalculations with smaller numbers can also produce surprising results if they\ninvolve fractional quantities, since not all fractions can be precisely\nrepresented and roundoff may occur. For example:\nshow 1 / 6 + 1 / 6 + 1 / 6 + 1 / 6 + 1 / 6 + 1 / 6\n=> 0.9999999999999999\nshow 1 / 9 + 1 / 9 + 1 / 9 + 1 / 9 + 1 / 9 + 1 / 9 + 1 / 9 + 1 / 9 + 1 / 9\n=> 1.0000000000000002\n\nAny operation which produces the special quantities \u201cinfinity\u201d or \u201cnot a number\u201d\nwill cause a runtime error.\nScientific notation\nVery large or very small floating point numbers are displayed by NetLogo using\n\u201cscientific notation\u201d. Examples:\nshow 0.000000000001\n=> 1.0E-12\nshow 50000000000000000000\n=> 5.0E19\n\nNumbers in scientific notation are distinguished by the presence of the letter E\n(for \u201cexponent\u201d). It means \u201ctimes ten to the power of\u201d, so for example, 1.0E-12\nmeans 1.0 times 10 to the -12 power:\nshow 1.0 * 10 ^ -12\n=> 1.0E-12\n\nYou can also use scientific notation yourself in NetLogo code:\nshow 3.0E6\n=> 3000000\nshow 8.123456789E6\n=> 8123456.789\nshow 8.123456789E7\n=> 8.123456789E7\nshow 3.0E16\n=> 3.0E16\nshow 8.0E-3\n=> 0.0080\nshow 8.0E-4\n=> 8.0E-4\n\nThese examples show that numbers with fractional parts are displayed using\nscientific notation if the exponent is less than -3 or greater than 6. Numbers\noutside of NetLogo\u2019s integer range of -9007199254740992 to 9007199254740992\n(+/-2^53) are also always shown in scientific notation:\nshow 2 ^ 60\n=> 1.15292150460684698E18\n\nWhen entering a number, the letter E may be either upper or lowercase. When\nprinting a number, NetLogo always uses an uppercase E:\nshow 4.5e20\n=> 4.5E20\n\nFloating point accuracy\nBecause numbers in NetLogo are subject to the limitations of how floating point\nnumbers are represented in binary, you may get answers that are slightly\ninaccurate. For example:\nshow 0.1 + 0.1 + 0.1\n=> 0.30000000000000004\nshow cos 90\n=> 6.123233995736766E-17\n\nThis is an inherent issue with floating point arithmetic; it occurs in all\nprogramming languages that use floating point numbers.\nIf you are dealing with fixed precision quantities, for example dollars and\ncents, a common technique is to use only integers (cents) internally, then\ndivide by 100 to get a result in dollars for display.\nIf you must use floating point numbers, then in some situations you may need to\nreplace a straightforward equality test such as if x = 1 [ ... ] with a test\nthat tolerates slight imprecision, for example\nif abs (x - 1) < 0.0001 [ ... ].\nAlso, the precision primitive is handy for rounding off numbers for display\npurposes. NetLogo monitors round the numbers they display to a configurable\nnumber of decimal places, too.\n"
      ],
      "368": [
            "Represent this documentation section of Netlogo programmer's guide for retrieval:",
            "Here is a relevant example from the netlogo programmer's guide:\nSection Name: Random numbers \n\nEntry Data: Random numbers\nThe random numbers used by NetLogo are what is called \u201cpseudo-random\u201d. (This is\ntypical in computer programming.) That means they appear random, but are in fact\ngenerated by a deterministic process. \u201cDeterministic\u201d means that you get the\nsame results every time, if you start with the same random \u201cseed\u201d. We\u2019ll explain\nin a minute what we mean by \u201cseed\u201d.\nIn the context of scientific modeling, pseudo-random numbers are actually\ndesirable. That\u2019s because it\u2019s important that a scientific experiment be\nreproducible \u2013 so anyone can try it themselves and get the same result that you\ngot. Since NetLogo uses pseudo-random numbers, the \u201cexperiments\u201d that you do\nwith it can be reproduced by others.\nHere\u2019s how it works. NetLogo\u2019s random number generator can be started with a\ncertain seed value, which must be an integer in the range -2147483648 to\n2147483647. Once the generator has been \u201cseeded\u201d with the random-seed\ncommand, it always generates the same sequence of random numbers from then on.\nFor example, if you run these commands:\nrandom-seed 137\nshow random 100\nshow random 100\nshow random 100\n\nYou will always get the numbers 79, 89, and 61 in that order.\nNote, however, that you\u2019re only guaranteed to get those same numbers if you\u2019re\nusing the same version of NetLogo. Sometimes when we make a new version of\nNetLogo the random number generator changes. (Presently, we use a generator\nknown as the Mersenne Twister.)\nTo create a number suitable for seeding the random number generator, use the\nnew-seed reporter. new-seed creates a seed, evenly distributed over the\nspace of possible seeds, based on the current date and time. It never reports\nthe same seed twice in a row.\n\nCode Example: Random Seed Example\n\nIf you don\u2019t set the random seed yourself, NetLogo sets it to a value based on\nthe current date and time. There is no way to find out what random seed it\nchose, so if you want your model run to be reproducible, you must set the random\nseed yourself ahead of time.\nThe NetLogo primitives with \u201crandom\u201d in their names (random, random-float, and\nso on) aren\u2019t the only ones that use pseudo-random numbers. Many other\noperations also make random choices. For example, agentsets are always in random\norder, one-of and n-of choose agents randomly, the sprout command\ncreates turtles with random colors and headings, and the downhill reporter\nchooses a random patch when there\u2019s a tie. All of these random choices are\ngoverned by the random seed as well, so model runs can be reproducible.\nIn addition to the uniformly distributed random integers and floating point\nnumbers generated by random and random-float, NetLogo also offers\nseveral other random distributions. See the dictionary entries for\nrandom-normal, random-poisson,\nrandom-exponential, and random-gamma.\nAuxiliary generator\nCode run by buttons or from the command center uses the main random number\ngenerator.\nCode in monitors uses an auxiliary random generator, so even if a monitor does a\ncalculation that uses random numbers, the outcome of the model is not affected.\nThe same is true of code in sliders.\nLocal randomness\nYou may want to explicitly specify that a section of code does not affect the\nstate of the main random generator, so the outcome of the model is not affected.\nThe with-local-randomness command is provided for this purpose. See its\nentry in the NetLogo Dictionary for more information.\nSaving a Random Seed for a Run\nIf you want to know what the random seed used by a \u201crun\u201d of a model was, you can\nadd some simple code to track it.  Then if an interesting behavior emerges or\nan intermittent error condition occurs, you have a way to reproduce the run by\ngrabbing the seed and re-using it.\nAdd a starting-seed global variable, then use new-seed to give it a value\nafter you use clear-all in your setup procedure.  Then give that value\nto the random-seed command so it will be used for the rest of the run.\nglobals [starting-seed]\n\nto setup\n  clear-all\n  set starting-seed new-seed\n  random-seed starting-seed\n  ; ... rest of normal setup code\nend\n\nto go\n  ; ... the rest of normal model code will use the random seed set in `setup`\nend\n\nYou can then add a monitor for the starting-seed global or simply output it\nto the command center whenever you want to know its value.  If you are using\nBehaviorSpace to run experiments, you can also include it in the output to be\nable to later reproduce runs that it generates.\n"
      ],
      "369": [
            "Represent this documentation section of Netlogo programmer's guide for retrieval:",
            "Here is a relevant example from the netlogo programmer's guide:\nSection Name: Turtle shapes \n\nEntry Data: Turtle shapes\nIn NetLogo, turtle shapes are vector shapes. They are built up from basic\ngeometric shapes; squares, circles, and lines, rather than a grid of pixels.\nVector shapes are fully scalable and rotatable. NetLogo caches bitmap images of\nvector shapes size 1, 1.5, and 2 in order to speed up execution.\nA turtle\u2019s shape is stored in its shape variable and can be set using the\nset command.\nNew turtles have a shape of \u201cdefault\u201d. The set-default-shape primitive is\nuseful for changing the default turtle shape to a different shape, or having a\ndifferent default turtle shape for each breed of turtle.\nThe shapes primitive reports a list of currently available turtle shapes in\nthe model. This is useful if, for example, you want to assign a random shape to\na turtle:\nask turtles [ set shape one-of shapes ]\n\nUse the Turtle Shapes Editor to create your own turtle shapes, or to add shapes\nto your model from our shapes library, or to transfer shapes between models. For\nmore information, see the Shapes Editor section of this manual.\nThe thickness of the lines used to draw the vector shapes can be controlled by\nthe __set-line-thickness primitive.\n\nCode Examples: Breeds and Shapes Example, Shape Animation Example\n\n"
      ],
      "370": [
            "Represent this documentation section of Netlogo programmer's guide for retrieval:",
            "Here is a relevant example from the netlogo programmer's guide:\nSection Name: Link shapes \n\nEntry Data: Link shapes\nLink Shapes are similar to turtle shapes, only you use the Link Shape Editor to\ncreate and edit them. Link shapes consist of between 0 and 3 lines which can\nhave different patterns and a direction indicator that is composed of the same\nelements as turtle shapes. Links also have a shape variable that can be set\nto any link shape that is in the model. By default links have the \u201cdefault\u201d\nshape, though you can change that using set-default-shape. The\nlink-shapes reporter reports all the link shapes included in the current\nmodel.\nThe thickness of the lines in the link shape is controlled by the thickness\nlink variable.\n"
      ],
      "371": [
            "Represent this documentation section of Netlogo programmer's guide for retrieval:",
            "Here is a relevant example from the netlogo programmer's guide:\nSection Name: View updates \n\nEntry Data: View updates\nThe \u201cview\u201d in NetLogo lets you see the agents in your model on your computer\u2019s\nscreen. As your agents move and change, you see them moving and changing in the\nview.\nOf course, you can\u2019t really see your agents directly. The view is a picture that\nNetLogo paints, showing you how your agents look at a particular instant. Once\nthat instant passes and your agents move and change some more, that picture\nneeds to be repainted to reflect the new state of the world. Repainting the\npicture is called \u201cupdating\u201d the view.\nWhen does the view get updated? This section discusses how NetLogo decides when\nto update the view, and how you can influence when it gets updated.\nNetLogo offers two updates modes, \u201ccontinuous\u201d updates and \u201ctick-based\u201d updates.\nYou can switch between NetLogo\u2019s two view update modes using a popup menu at the\ntop of the Interface tab.\nContinuous updates are the default when you start up NetLogo or start a new\nmodel. Nearly every model in our Models Library, however, uses tick-based\nupdates.\nContinuous updates are simplest, but tick-based updates give you more control\nover when and how often updates happen.\nIt\u2019s important exactly when an update happens, because when updates happen\ndetermines what you see on the screen. If an update comes at an unexpected time,\nyou may see something unexpected \u2013 perhaps something confusing or misleading.\nIt\u2019s also important how often updates happen, because updates take time. The\nmore time NetLogo spends updating the view, the slower your model will run. With\nfewer updates, your model runs faster.\nContinuous updates\nContinuous updates are very simple. With continuous updates, NetLogo updates the\nview a certain number of times per second \u2013 by default, 30 times a second when\nthe speed slider is in the default, middle setting.\nIf you move the speed slider to a slower setting, NetLogo will update more than\n30 times a second, effectively slowing down the model. On a faster setting,\nNetLogo will update less than 30 times a second. On the fastest setting, updates\nwill be separated by several seconds.\nAt extremely slow settings, NetLogo will be updating so often that you will see\nyour agents moving (or changing color, etc.) one at a time.\nIf you need to temporarily shut off continuous updates, use the no-display\ncommand. The display command turns updates back on, and also forces an\nimmediate update (unless the user is fast-forwarding the model using the speed\nslider).\nTick-based updates\nAs discussed above in the Tick Counter section, in many NetLogo\nmodels, time passes in discrete steps, called \u201cticks\u201d. Typically, you want the\nview to update once per tick, between ticks. That\u2019s the default behavior with\ntick-based updates.\nIf you want additional view updates, you can force an update using the\ndisplay command. (The update may be skipped if the user is fast-forwarding\nthe model using the speed slider.)\nYou don\u2019t have to use the tick counter to use tick-based updates. If the tick\ncounter never advances, the view will update only when you use the display\ncommand.\nIf you move the speed slider to a fast enough setting, eventually NetLogo will\nskip some of the updates that would ordinarily have happened. Moving the speed\nslider to a slower setting doesn\u2019t cause additional updates; rather, it makes\nNetLogo pause after each update. The slower the setting, the longer the pause.\nEven under tick-based updates, the view also updates whenever a button in the\ninterface pops up (both once and forever buttons) and when a command entered in\nthe Command Center finishes. So it\u2019s not necessary to add the display\ncommand to once buttons that don\u2019t advance the tick counter. Many forever\nbuttons that don\u2019t advance the tick counter do need to use the display\ncommand. An example in the Models Library is the Life model (under\nComputer Science -> Cellular Automata). The forever buttons that let the user\ndraw in the view use the display command so the user can see what they are\ndrawing, even though the tick counter is not advancing.\nChoosing a mode\nAdvantages of tick-based updates over continuous updates include:\n\nConsistent, predictable view update behavior which does not vary from\ncomputer to computer or from run to run.\nContinuous updates can confuse the user of your model by letting them see\nmodel states they aren\u2019t supposed to see, which may be misleading.\nSince setup buttons don\u2019t advance the tick counter, they are unaffected by\nthe speed slider; this is normally the desired behavior.\n\nNearly every model in our Models Library uses tick-based updates.\nContinuous updates are occasionally useful for those rare models in which\nexecution is not divided into short, discrete phases. An example in the Models\nLibrary is Termites. (See also, however, the State Machine Example model, which\nshows how to re-code Termites using ticks.)\nEven for models that would normally be set to tick-based updates, it may be\nuseful to switch to continuous updates temporarily for debugging purposes.\nSeeing what\u2019s going on within a tick, instead of only seeing the end result of a\ntick, could help with troubleshooting. After switching to continuous updates,\nyou may want to use the speed slider to slow the model down until you see your\nagents moving one at a time. Don\u2019t forget to change back to tick-based updates\nwhen you are done, as the choice of update mode is saved with the model.\nChanging the update mode also affects model speed. Updating the view takes time;\noften enforcing a single update per tick (by using tick-based updates) will make\nyour model faster. On the other hand, continuous updates will be faster when\nrunning a single tick is faster than drawing a frame of the model. Most models\nrun faster under tick-based updates, but for an example of a model which is\nfaster with continuous updates see the \u201cHeroes and Cowards\u201d library model.\nFrame rate\nOne of the model settings in NetLogo\u2019s \u201cSettings\u2026\u201d dialog is \u201cFrame rate\u201d\nwhich defaults to 30 frames per second.\nThe frame rate setting affects both continuous updates and tick-based updates.\nWith continuous updates, the setting directly determines the frequency of\nupdates.\nWith tick-based updates, the setting is a ceiling on how many updates per\nsecond you get. If the frame rate is 30, then NetLogo will ensure that the model\nnever runs faster than that when the speed slider is in the default position. If\nany frame takes less than 1/30 of a second to compute and display, NetLogo will\npause and wait until the full 1/30 of a second has passed before continuing.\nThe frame rate settings lets you set what you consider to be a normal speed for\nyour model. Then you, or the user of your model, can use the speed slider to\ntemporarily get a faster or slower speed.\n"
      ],
      "372": [
            "Represent this documentation section of Netlogo programmer's guide for retrieval:",
            "Here is a relevant example from the netlogo programmer's guide:\nSection Name: Plotting \n\nEntry Data: Plotting\nNetLogo\u2019s plotting features let you create plots to help you understand what\u2019s\ngoing on in your model.\nBefore you can plot, you need to create one or more plots in the Interface tab.\nFor more information on using and editing plots in the Interface tab, see the\nInterface Guide.\nPlotting points\nThe two basic commands for actually plotting things are plot and plotxy.\nWith plot you need only specify the y value you want plotted. The x value will\nautomatically be 0 for the first point you plot, 1 for the second, and so on.\n(That\u2019s if the plot pen\u2019s \u201cinterval\u201d is the default value of 1; you can change\nthe interval.)\nThe plot command is especially handy when you want your model to plot a new\npoint at every time step. Example:\nplot count turtles\n\nIf you need to specify both the x and y values of the point you want plotted,\nthen use plotxy instead. This example assumes that a global variable called\ntime exists:\nplotxy time count-turtles\n\nPlot commands\nEach plot and its pens have setup and update code fields that may contain\ncommands (usually containing plot or plotxy). These commands are run\nautomatically triggered by other commands in NetLogo.\nPlot setup commands and pen setup commands are run when the either reset-ticks\nor setup-plots commands are run. If the stop command is run in the body of\nthe plot setup commands then the pen setup commands will not run.\nPlot update commands and pen update commands are run when the either\nreset-ticks, tick or update-plots commands are run. If the stop command\nis run in the body of the plot update commands then the pen update commands will\nnot run.\nHere are the four commands that trigger plotting explained in more detail.\n\nsetup-plots executes commands for one plot at a time. For each plot, the\nplot\u2019s setup commands are executed. If the stop command is not encountered\nwhile running those commands, then each of the plot\u2019s pens will have their\nsetup code executed.\nupdate-plots is very similar to setup-plots. For each plot, the plot\u2019s\nupdate commands are executed. If the stop command is not encountered while\nrunning those commands, then each of the plot\u2019s pens will have their update\ncode executed.\ntick is exactly the same as update-plots except that the tick counter is\nincremented before the plot commands are executed.\nreset-ticks first resets the tick counter to 0, and then does the equivalent\nof setup-plots followed by update-plots.\n\nA typical model will use reset-ticks and tick like so:\nto setup\n  clear-all\n  ...\n  reset-ticks\nend\n\nto go\n  ...\n  tick\nend\n\nNote that in this example we plot from both the setup and go procedures\n(because reset-ticks runs plot setup and plot update commands). We do this\nbecause we want our plot to include the initial state of the system at the end\nof setup. We plot at the end of the go procedure, not the beginning, because\nwe want the plot always to be up to date after the go button stops.\nModels that don\u2019t use ticks but still want to do plotting will instead use\nsetup-plots and update-plots. In the previous code, replace reset-ticks\nwith setup-plots update-plots and replace tick with update-plots.\n\nCode Example: Plotting Example\n\nOther kinds of plots\nBy default, NetLogo plot pens plot in line mode, so that the points you plot are\nconnected by a line.\nIf you want to move the pen without plotting, you can use the plot-pen-up\ncommand. After this command is issued, the plot and plotxy commands move the\npen but do not actually draw anything. Once the pen is where you want it, use\nplot-pen-down to put the pen back down.\nIf you want to plot individual points instead of lines, or you want to draw bars\ninstead of lines or points, you need to change the plot pen\u2019s \u201cmode\u201d. Three\nmodes are available: line, bar, and point. Line is the default mode.\nNormally, you change a pen\u2019s mode by editing the plot. This changes the pen\u2019s\ndefault mode. It\u2019s also possible to change the pen\u2019s mode temporarily using the\nset-plot-pen-mode command. That command takes a number as input: 0 for line, 1\nfor bar, 2 for point.\nHistograms\nA histogram is a special kind of plot that measures how frequently certain\nvalues, or values in certain ranges, occur in a collection of numbers that arise\nin your model.\nFor example, suppose the turtles in your model have an age variable. You could\ncreate a histogram of the distribution of ages among your turtles with the\nhistogram command, like this:\nhistogram [age] of turtles\n\nThe numbers you want to histogram don\u2019t have to come from an agentset; they\ncould be any list of numbers.\nNote that using the histogram command doesn\u2019t automatically switch the current\nplot pen to bar mode. If you want bars, you have to set the plot pen to bar mode\nyourself. (As we said before, you can change a pen\u2019s default mode by editing the\nplot in the Interface tab.)\nLike other types of plots, histograms can be set to auto scale. However, auto\nscaled histograms do not automatically resize themselves horizontally like other\nplot types do. To set the range programmatically, you can use the\nset-plot-x-range primitive.\nThe width of the bars in a histogram is controlled by the plot pen\u2019s interval.\nYou can set a plot pen\u2019s default interval by editing the plot in the Interface\ntab. You can also change the interval temporarily with the\nset-plot-pen-interval command or the set-histogram-num-bars. If you use the\nlatter command, NetLogo will set the interval appropriately so as to fit the\nspecified number of bars within the plot\u2019s current x range.\n\nCode Example: Histogram Example\n\nClearing and resetting\nYou can clear the current plot with the clear-plot command, or clear every\nplot in your model with clear-all-plots. The clear-all command also clears\nall plots, in addition to clearing everything else in your model.\nIf you want to remove only the points that a particular pen has drawn, use\nplot-pen-reset.\nWhen a whole plot is cleared, or when a pen is reset, that doesn\u2019t just remove\nthe data that has been plotted. It also restores the plot or pen to its default\nsettings, as they were specified in the Interface tab when the plot was created\nor last edited. Therefore, the effects of such commands as\nset-plot-background-color, set-plot-x-range and set-plot-pen-color are\nonly temporary.\nRanges and auto scaling\nThe default x and y ranges for a plot are fixed numbers, but they can be changed\nat setup time or as the model runs.\nTo change the ranges at any time, use set-plot-x-range and set-plot-y-range.\nOr, you can let the ranges grow automatically. Either way, when the plot is\ncleared the ranges will return to their default values.\nBy default, all NetLogo plots have the auto scaling feature enabled. This means\nthat if the model tries to plot a point which is outside the current displayed\nrange, the range of the plot will grow along one or both axes so that the new\npoint is visible. Histogram plots, however, do not auto scale horizontally.\nIn the hope that the ranges won\u2019t have to change every time a new point is\nadded, when the ranges grow they leave some extra room: 25% if growing\nhorizontally, 10% if growing vertically.\nIf you want to turn off this feature, edit the plot and uncheck the\n\u201cAuto Scale?\u201d checkbox. At present, it is not possible to enable or disable this\nfeature only on one axis; it always applies to both axes.\nUsing a Legend\nYou can show the legend of a plot by checking the \u201cShow legend\u201d checkbox in the\nedit dialog. If you don\u2019t want a particular pen to show up in the legend you can\nuncheck the \u201cShow in Legend\u201d checkbox for that pen also in the advanced plot pen\nsettings (the advanced plot pen settings can be opened by clicking the pencil\nbutton for that pen in the plot pens table in the plot edit dialog).\nTemporary plot pens\nMost plots can get along with a fixed number of pens. But some plots have more\ncomplex needs; they may need to have the number of pens vary depending on\nconditions. In such cases, you can make \u201ctemporary\u201d plot pens from code and then\nplot with them. These pens are called \u201ctemporary\u201d because they vanish when the\nplot is cleared (by the clear-plot, clear-all-plots, or clear-all\ncommands).\nTo create a temporary plot pen, use the create-temporary-plot-pen command.\nTypically, this would be done in the Code tab, but it is also possible to use\nthis command from plot setup or plot update code (in the edit dialog). By\ndefault, the new pen is down, is black in color, has an interval of 1, and plots\nin line mode. Commands are available to change all of these settings; see the\nPlotting section of the NetLogo Dictionary.\nBefore you can use the pen, you\u2019ll have to use the use the set-current-plot\nand set-current-plot-pen commands. These are explained in the next section.\nset-current-plot and set-current-plot-pen\nBefore NetLogo 5, it was not possible to put plot commands in the plot itself.\nAll of the plot code was written in the Code tab with the rest of the code. For\nbackwards compatibility, and for temporary plot pens, this is still supported.\nModels in previous versions of NetLogo (and those using temporary plot pens)\nhave to explicitly state which plot is the current plot with the\nset-current-plot command and which pen is the current pen with the\nset-current-plot-pen command.\nTo set the current plot use the set-current-plot command with the name of the\nplot enclosed in double quotes, like this:\nset-current-plot \"Distance vs. Time\"\n\nThe name of the plot must be exactly as you typed it when you created the plot.\nNote that later if you change the name of the plot, you\u2019ll also have to update\nthe set-current-plot calls in your model to use the new name. (Copy and paste\ncan be helpful here.)\nFor a plot with multiple pens, you can manually specify which pen you want to\nplot with. If you don\u2019t specify a pen, plotting will take place with the first\npen in the plot. To plot with a different pen, the set-current-plot-pen\ncommand was used with the name of the pen enclosed in double quotes, like this:\nset-current-plot-pen \"distance\"\n\nOnce the current pen is set, then commands like plot count turtles can be\nexecuted for that pen.\nOlder models with plots usually had their own do-plotting procedure that\nlooked something like this:\nto do-plotting\n  set-current-plot \"populations\"\n  set-current-plot-pen \"sheep\"\n  plot count sheep\n  set-current-plot-pen \"wolves\"\n  plot count wolves\n\n  set-current-plot \"next plot\"\n  ...\nend\n\nOnce again, this is no longer necessary in NetLogo 5, unless you are using\ntemporary plot pens.\nConclusion\nNot every aspect of NetLogo\u2019s plotting system has been explained here. See the\nPlotting section of the NetLogo Dictionary for information on additional\ncommands and reporters related to plotting.\nMany of the Sample Models in the Models Library illustrate various advanced\nplotting techniques. Also check out the following code examples:\n\nCode Examples: Plot Axis Example, Plot Smoothing Example, Rolling Plot Example\n\n"
      ],
      "373": [
            "Represent this documentation section of Netlogo programmer's guide for retrieval:",
            "Here is a relevant example from the netlogo programmer's guide:\nSection Name: Strings \n\nEntry Data: Strings\nStrings may contain any Unicode characters.\nTo input a constant string in NetLogo, surround it with double quotes.\nThe empty string is written by putting nothing between the quotes, like this:\n\"\".\nMost of the list primitives work on strings as well:\nbut-first \"string\" => \"tring\"\nbut-last \"string\" => \"strin\"\nempty? \"\" => true\nempty? \"string\" => false\nfirst \"string\" => \"s\"\nitem 2 \"string\" => \"r\"\nlast \"string\" => \"g\"\nlength \"string\" => 6\nmember? \"s\" \"string\" => true\nmember? \"rin\" \"string\" => true\nmember? \"ron\" \"string\" => false\nposition \"s\" \"string\" => 0\nposition \"rin\" \"string\" => 2\nposition \"ron\" \"string\" => false\nremove \"r\" \"string\" => \"sting\"\nremove \"s\" \"strings\" => \"tring\"\nreplace-item 3 \"string\" \"o\" => \"strong\"\nreverse \"string\" => \"gnirts\"\n\nA few primitives are specific to strings, such as\nis-string?, substring, and word:\nis-string? \"string\" => true\nis-string? 37 => false\nsubstring \"string\" 2 5 => \"rin\"\nword \"tur\" \"tle\" => \"turtle\"\n\nStrings can be compared using the =, !=, <, >, <=, and >= operators.\nIf you need to embed a special character in a string, use the following escape\nsequences:\n\n\\n = newline\n\\t = tab\n\\\" = double quote\n\\\\ = backslash\n\n"
      ],
      "374": [
            "Represent this documentation section of Netlogo programmer's guide for retrieval:",
            "Here is a relevant example from the netlogo programmer's guide:\nSection Name: Output \n\nEntry Data: Output\nThis section is about output to the screen. Output to the screen can also be\nlater saved to a file using the export-output command. If you\nneed a more flexible method of writing data to external files, see the next\nsection, File I/O.\nThe basic commands for generating output to the screen in NetLogo are\nprint, show, type, and write. These commands send their output\nto the Command Center.\nFor full details on these four commands, see their entries in the NetLogo\nDictionary. Here is how they are typically used:\n\nprint is useful in most situations.\nshow lets you see which agent is printing what.\ntype lets you print several things on the same line.\nwrite lets you print values in a format which can\nbe read back in using file-read.\n\nA NetLogo model may optionally have an \u201coutput area\u201d in its Interface tab,\nseparate from the Command Center. To send output there instead of the Command\nCenter, use the output-print, output-show,\noutput-type, and output-write commands.\nThe output area can be cleared with the clear-output command and saved to a\nfile with export-output. The contents of the output area will be\nsaved by the export-world command. The import-world command\nwill clear the output area and set its contents to the value in imported world\nfile. It should be noted that large amounts of data being sent to the output\narea can increase the size of your exported worlds.\nIf you use output-print, output-show,\noutput-type, output-write, clear-output, or\nexport-output in a model which does not have a separate output\narea, then the commands apply to the output portion of the Command Center.\nHow Output Primitives Differ\nThis information is a quick reference for more advanced users.\nThe print, show, type, and write primitives differ on the following facets:\n\nWhat types of values does the primitive accept?\nDoes the primitive output a newline at the end?\nAre strings output with quotes surrounding them?\nDoes the primitive output the agent which printed it?\n\nThe following table summarizes the behavior of each primitive.\n\n\nPrimitiveAcceptable valuesAdds newline?Strings quoted?Outputs self?\n\n\nprintany NetLogo valueyesnono\nshowany NetLogo valueyesyesyes\ntypeany NetLogo valuenonono\nwriteboolean, number, string, lists containing only these typesnoyesno\n\n\n"
      ],
      "375": [
            "Represent this documentation section of Netlogo programmer's guide for retrieval:",
            "Here is a relevant example from the netlogo programmer's guide:\nSection Name: File I/O \n\nEntry Data: File I/O\nIn NetLogo, there is a set of primitives that give you the power to interact\nwith outside files. They all begin with the prefix file-.\nThere are two main modes when dealing with files: reading and writing. The\ndifference is the direction of the flow of data. When you are reading in\ninformation from a file, data that is stored in the file flows into your model.\nOn the other hand, writing allows data to flow out of your model and into a\nfile.\nWhen working with files, always begin by using the primitive file-open. This\nspecifies which file you will be interacting with. None of the other primitives\nwork unless you open a file first.\nThe next file- primitive you use dictates which mode the file will be in\nuntil the file is closed, reading or writing. To switch modes, close and then\nreopen the file.\nThe reading primitives include file-read, file-read-line,\nfile-read-characters, and file-at-end?. Note that the file must exist\nalready before you can open it for reading.\n\nCode Examples: File Input Example\n\nThe primitives for writing are similar to the primitives that print things in\nthe Command Center, except that the output gets saved to a file. They include\nfile-print, file-show, file-type, and file-write. Note that you\ncan never \u201coverwrite\u201d data. In other words, if you attempt to write to a file\nwith existing data, all new data will be appended to the end of the file. (If\nyou want to overwrite a file, use file-delete to delete it, then open it for\nwriting.)\n\nCode Examples: File Output Example\n\nWhen you are finished using a file, you can use the command file-close to\nend your session with the file. If you wish to remove the file afterwards, use\nthe primitive file-delete to delete it. To close multiple opened files, one\nneeds to first select the file by using file-open before closing it.\n;; Open 3 files\nfile-open \"myfile1.txt\"\nfile-open \"myfile2.txt\"\nfile-open \"myfile3.txt\"\n\n;; Now close the 3 files\nfile-close\nfile-open \"myfile2.txt\"\nfile-close\nfile-open \"myfile1.txt\"\nfile-close\n\nOr, if you know you just want to close every file, you can use\nfile-close-all.\nTwo primitives worth noting are file-write and file-read . These\nprimitives are designed to easily save and retrieve NetLogo constants such as\nnumbers, lists, booleans, and strings. file-write will always output the\nvariable in such a manner that file-read will be able to interpret it correctly.\nfile-open \"myfile.txt\"  ;; Opening file for writing\nask turtles\n  [ file-write xcor file-write ycor ]\nfile-close\n\nfile-open \"myfile.txt\"  ;; Opening file for reading\nask turtles\n  [ setxy file-read file-read ]\nfile-close\n\n\nCode Examples: File Input Example and File Output Example\n\nLetting the user choose\nThe user-directory, user-file, and user-new-file primitives are\nuseful when you want the user to choose a file or directory for your code to\noperate on.\n"
      ],
      "376": [
            "Represent this documentation section of Netlogo programmer's guide for retrieval:",
            "Here is a relevant example from the netlogo programmer's guide:\nSection Name: Movies \n\nEntry Data: Movies\nThis section describes how to capture an \u201c.mp4\u201d movie of a NetLogo model.\nFirst, use the vid:start-recorder command to\nstart the video recorder.\nTo add a frame to your movie, use either\nvid:record-view or\nvid:record-interface, depending on whether you\nwant the movie to show just the current view, or the entire Interface tab. In a\nsingle movie, the resolution will be one of the following:\n\nThe resolution specified in the call to vid:start-recorder width height\nif you specified the resolution. These are optional parameters.\nThe resolution of the view if you did not specify a resolution in the call to\nvid:start-recorder and call vid:record-view before calling\nvid:record-interface\nThe resolution of the interface if you did not specify a resolution in the\ncall to vid:start-recorder and call vid:record-interface before calling\nvid:record-view\n\nNote that if the resolution of a recorded image doesn\u2019t match the resolution of\nthe recording it will be scaled to fit which can result in images which look\nblurry or out-of-focus.\nWhen you\u2019re done adding frames, use\nvid:save-recording. The filename you provide\nshould end with .mp4, the extension for MP4-encoded movies (playable in\nQuickTime and other programs).\n;; export a 30 frame movie of the view\nextensions [vid]\n\n;...\n\nsetup\nvid:start-recorder\nvid:record-view ;; show the initial state\nrepeat 30\n[ go\n  vid:record-view ]\nvid:save-recording \"out.mp4\"\n\nA movie will play back at 25 frames per second. To make the movie playback\nfaster or slower, consider using a video postprocessing tool.\nTo check whether or not you are recording, call\nvid:recorder-status, which reports a string\nthat describes the state of the current recorder.\nTo throw away the movie currently being recorded, call\nvid:reset-recorder.\n\nCode Example: Movie Example\n\nMovies generated when running headless, or by background runs in a parallel\nBehaviorSpace experiment may use only vid:record-view primitive. Movies\ngenerated in NetLogo GUI may also use vid:record-interface and\nvid:record-source.\nNetLogo movies are exported as H.264-encoded MP4 files. To play an MP4 movie,\nyou can use the VLC Player, a free\ndownload from the VideoLAN organization.\nMovies can take up a lot of disk space. You will probably want to compress your\nmovies with third-party software. The software may give you a choice of\ndifferent kinds of compression. Some kinds of compression are lossless, while\nothers are lossy. \u201cLossy\u201d means that in order to make the files smaller, some of\nthe detail in the movie is lost. Depending on the nature of your model, you may\nwant to avoid using lossy compression, for example if the view contains fine\npixel-level detail.\n"
      ],
      "377": [
            "Represent this documentation section of Netlogo programmer's guide for retrieval:",
            "Here is a relevant example from the netlogo programmer's guide:\nSection Name: Perspective \n\nEntry Data: Perspective\nThe 2D and the 3D view show the world from the perspective of the observer. By\ndefault the observer is looking down on the world from the positive z-axis at\nthe origin. You can change the perspective of the observer by using the\nfollow, ride and watch observer commands and follow-me,\nride-me and watch-me turtle commands. watch-me is also a patch or\nlink command. When in follow or ride mode the observer moves with the subject\nagent around the world. The difference between follow and ride is only visible\nin the 3D view. In the 3D view the user can change the distance behind the agent\nusing the mouse. When the observer is following at zero distance from the agent\nit is actually riding the agent. When the observer is in watch mode it tracks\nthe movements of one turtle (or patch or link) without moving. In both views you\nwill see a spotlight appear on the subject and in the 3D view the observer will\nturn to face the subject. To determine which agent is the focus you can use the\nsubject reporter.\n\nCode Example: Perspective Example\n\n"
      ],
      "378": [
            "Represent this documentation section of Netlogo programmer's guide for retrieval:",
            "Here is a relevant example from the netlogo programmer's guide:\nSection Name: Drawing \n\nEntry Data: Drawing\nThe drawing is a layer where turtles can make visible marks.\nIn the view, the drawing appears on top of the patches but underneath the\nturtles. Initially, the drawing is empty and transparent.\nYou can see the drawing, but the turtles (and patches) can\u2019t. They can\u2019t sense\nthe drawing or react to it. The drawing is just for people to look at.\nTurtles can draw and erase lines in the drawing using the\npen-down and pen-erase commands.\nWhen a turtle\u2019s pen is down (or erasing), the turtle draws (or erases) a line\nbehind it whenever it moves. The lines are the same color as the turtle. To stop\ndrawing (or erasing), use pen-up.\nLines drawn by turtles are normally one pixel thick. If you want a different\nthickness, set the pen-size turtle variable to a different number before\ndrawing (or erasing). In new turtles, the variable is set to 1.\nLines made when a turtle moves in a way that doesn\u2019t fix a direction, such as\nwith setxy or move-to, the shortest path line that obeys the topology\nwill be drawn.\nHere\u2019s some turtles which have made a drawing over a grid of randomly shaded\npatches. Notice how the turtles cover the lines and the lines cover the patch\ncolors. The pen-size used here was 2:\n\nThe stamp command lets a turtle leave an image of itself behind in the\ndrawing and stamp-erase lets it remove the pixels below it in the drawing.\nTo erase the whole drawing, use the observer commmand clear-drawing. (You\ncan also use clear-all, which clears everything else too.)\nImporting an image\nThe observer command import-drawing command allows you to import an image\nfile from disk into the drawing.\nimport-drawing is useful only for providing a backdrop for people to look\nat. If you want turtles and patches to react to the image, you should use\nimport-pcolors or import-pcolors-rgb instead.\nComparison to other Logos\nDrawing works somewhat differently in NetLogo than some other Logos.\nNotable differences include:\n\nNew turtles\u2019 pens are up, not down.\nInstead of using a fence command to confine the turtle inside boundaries, in\nNetLogo you edit the world and turn wrapping off.\nThere is no screen-color, bgcolor, or setbg. You can make a solid\nbackground by coloring the patches, e.g. ask patches [ set pcolor blue ].\n\nDrawing features not supported by NetLogo:\n\nThere is no window command. This is used in some other Logos to let the\nturtle roam over an infinite plane.\nThere is no flood or fill command to fill an enclosed area with color.\n\n"
      ],
      "379": [
            "Represent this documentation section of Netlogo programmer's guide for retrieval:",
            "Here is a relevant example from the netlogo programmer's guide:\nSection Name: Topology \n\nEntry Data: Topology\nThe way the world of patches is connected can change. By default the world is a\ntorus which means it isn\u2019t bounded, but \u201cwraps\u201d \u2013 so when a turtle moves past\nthe edge of the world, it disappears and reappears on the opposite edge and\nevery patch has the same number of \u201cneighbor\u201d patches. If you\u2019re a patch on the\nedge of the world, some of your \u201cneighbors\u201d are on the opposite edge.\nHowever, you can change the wrap settings with the Settings button. If wrapping\nis not allowed in a given direction then in that direction (x or y) the world is\nbounded. Patches along that boundary will have fewer than 8 neighbors and\nturtles will not move beyond the edge of the world.\nThe topology of the NetLogo world has four potential values, torus, box,\nvertical cylinder, or horizontal cylinder. The topology is controlled by\nenabling or disabling wrapping in the x or y directions. The default world is a\ntorus.\nA torus wraps in both directions, meaning that the top and bottom edges of the\nworld are connected and the left and right edges are connected. So if a turtle\nmoves beyond the right edge of the world it appears again on the left and the\nsame for the top and bottom.\nA box does not wrap in either direction. The world is bounded so turtles that\ntry to move off the edge of the world cannot. Note that the patches around edge\nof the world have fewer than eight neighbors; the corners have three and the\nrest have five.\nHorizontal and vertical cylinders wrap in one direction but not the other. A\nhorizontal cylinder wraps vertically, so the top of the world is connected to\nthe bottom. but the left and right edges are bounded. A vertical cylinder is the\nopposite; it wraps horizontally so the left and right edges are connected, but\nthe top and bottom edges are bounded.\n\nCode Example: Neighbors Example\n\nWhen coordinates wrap, turtles and links wrap visually in the view, too. If a\nturtle shape or link extends past an edge, part of it will appear at the other\nedge. (Turtles themselves are points that take up no space, so they cannot be on\nboth sides of the world at once, but in the view, they appear to take up space\nbecause they have a shape.)\nWrapping also affects how the view looks when you are following a turtle. On a\ntorus, wherever the turtle goes, you will always see the whole world around it:\n\nWhereas in a box or cylinder the world has edges, so the areas past those edges\nshow up in the view as gray:\n\n\nCode Example: Termites Perspective Demo (torus), Ants Perspective Demo\n(box)\n\nThe topology settings also control the behavior of the distance(xy), in-radius,\nin-cone, face(xy), and towards(xy) primitives. The topology controls whether the\nprimitives wrap or not. They always use the shortest path allowed by the\ntopology. For example, the distance from the center of the patches in the bottom\nleft corner (min-pxcor, min-pycor) and the upper right corner (max-pxcor,\nmax-pycor) will be as follows for each topology given that the min and max pxcor\nand pycor are +/-2:\n\nTorus - sqrt(2) ~ 1.414 (this will be the same for all world sizes since the\npatches are directly diagonal to each other in a torus.)\nBox - sqrt(world-width^2 + world-height^2) ~ 7.07\nVertical Cylinder - sqrt(world-height^2 + 1) ~ 5.099\nHorizontal Cylinder - sqrt(world-width^2 + 1) ~ 5.099\n\nAll the other primitives will act similarly to distance. If you formerly used\n-nowrap primitives in your model we recommend removing them and changing the\ntopology of the world instead.\nIf your model has turtles that move around you\u2019ll need to think about what\nhappens to them when they reach the edge of the world, if the topology you\u2019re\nusing has some non-wrapping edges. There are a few common options: the turtle is\nreflected back into the world (either systematically or randomly), the turtle\nexits the system (dies), or the turtle is hidden. It is no longer necessary to\ncheck the bounds using turtle coordinates, instead we can just ask NetLogo if a\nturtle is at the edge of the world. There are a couple ways of doing this, the\nsimplest is to use the can-move? primitive.\nif not can-move? distance [ rt 180 ]\n\ncan-move? merely returns true if the position distance in front of the turtle\nis inside the NetLogo world, false otherwise. In this case, if the turtle is at\nthe edge of the world it simple goes back the way it came. You can also use\npatch-ahead 1 != nobody in place of can-move?. If you need to do something\nsmarter that simply turning around it may be useful to use patch-at with\ndx and dy.\nif patch-at dx 0 = nobody [\n  set heading (- heading)\n]\nif patch-at 0 dy = nobody [\n  set heading (180 - heading)\n]\n\nThis tests whether the turtle is hitting a horizontal or vertical wall and\nbounces off that wall.\nIn some models if a turtle can\u2019t move forward it simply dies (exits the system,\nlike in Conductor or Mousetraps).\nif not can-move? distance[ die ]\n\nIf you are moving turtles using setxy rather than forward you should test to\nmake sure the patch you are about to move to exists since setxy throws a\nruntime error if it is given coordinates outside the world. This is a common\nsituation when the model is simulating an infinite plane and turtles outside the\nview should simply be hidden.\nlet new-x new-value-of-xcor\nlet new-y new-value-of-ycor\n\nifelse patch-at (new-x - xcor) (new-y - ycor) = nobody\n  [ hide-turtle ]\n  [ setxy new-x new-y\n    show-turtle ]\n\nSeveral models in the Models Library use this technique, Gravitation, N-Bodies,\nand Electrostatics are good examples.\nThe diffuse and diffuse4 commands behave correctly in all topologies. Each\npatch diffuses and equal amount of the diffuse variable to each of its\nneighbors, if it has fewer than 8 neighbors (or 4 if you are using diffuse4),\nthe remainder stays on the diffusing patch. This means that the overall sum of\npatch-variable across the world remains constant. However, if you want the\ndiffuse matter to still fall off the edges of the world as it would on an\ninfinite plane you still need to clear the edges each step as in the Diffuse Off\nEdges Example.\n"
      ],
      "380": [
            "Represent this documentation section of Netlogo programmer's guide for retrieval:",
            "Here is a relevant example from the netlogo programmer's guide:\nSection Name: Links \n\nEntry Data: Links\nA link is an agent that connects two turtles. These turtles are sometimes also\ncalled nodes.\nThe link is always drawn as a line between the two turtles. Links do not have a\nlocation as turtles do, they are not considered to be on any patch and you\ncannot find the distance from a link to another point.\nThere are two link designations: undirected and directed. A directed link is\nout of, or from, one node and into, or to, another node. The\nrelationship of a parent to a child could be modeled as a directed link. An\nundirected link appears the same to both nodes, each node has a link with\nanother node. The relationship between spouses, or siblings, could be modeled as\nan undirected link.\nThere is a global agentset of all links, just as with turtles and patches. You\ncan create undirected links using the create-link-with and\ncreate-links-with commands; and directed links using the\ncreate-link-to, create-links-to,\ncreate-link-from, and create-links-from\ncommands. Once the first link has been created directed or undirected, all\nunbreeded links must match (links also support breeds, much like turtles, which\nwill be discussed shortly); it\u2019s impossible to have two unbreeded links where\none is directed and the other is undirected. A runtime error occurs if you try\nto do it. (If all unbreeded links die, then you can create links of that breed\nthat are different in designation from the previous links.)\nIn general, link primitive names indicate what kind of links they deal with:\n\nPrimitives that have \u201cout\u201d in their name utilize outgoing and undirected\nlinks. You can think of these as \u201cthe links I can use to get from the\ncurrent node to other nodes.\u201d In general, these are probably the primitives\nyou want to use.\nPrimitives that have \u201cin\u201d in their name utilize incoming and undirected links.\nYou can think of these as \u201cthe links I can use to get to the current node\nfrom other nodes.\u201d\nPrimtives that do not specify \u201cin\u201d or \u201cout\u201d, or have \u201cwith\u201d in their name\nutilize all links, both undirected and directed, incoming and outgoing.\n\nA link\u2019s end1 and end2 variables contain the two turtles the link connects.\nIf the link is directed, it goes from end1 to end2. If the link is undirected,\nend1 is always the older of the two turtles, that is, the turtle with the\nsmaller who number.\nLink breeds, like turtle breeds, allow you to define different types of links in\nyour model. Link breeds must either be directed or undirected, unlike unbreeded\nlinks this is defined at compile time rather than run time. You declare link\nbreeds using the keywords\nundirected-link-breed and directed-link-breed. Breeded links can be\ncreated using the commands create-<breed>-with and\ncreate-<breeds>-with for undirected breeds and the commands\ncreate-<breed>-to, create-<breeds>-to,\ncreate-<breed>-from, and create-<breeds>-from\nfor directed links.\nThere cannot be more than one undirected link of the same breed (or more than\none unbreeded undirected link) between a pair of agents, nor more than one\ndirected link of the same breed in the same direction between a pair of agents.\nYou can have two directed links of the same breed (or two unbreeded directed\nlinks) between a pair if they are in opposite directions.\nLayouts\nAs part of our network support we have also added several different primitives\nthat will help you to visualize the networks. The simplest is layout-circle\nwhich evenly spaces the agents around the center of the world given a radius.\n\nlayout-radial is a good layout if you have something like a tree structure,\nthough even if there are some cycles in the tree it will still work, though as\nthere are more and more cycles it will probably not look as good.\nlayout-radial takes a root agent to be the central node places it at (0,0)\nand arranges the nodes connected to it in a concentric pattern. Nodes one degree\naway from the root will be arranged in a circular pattern around the central\nnode and the next level around those nodes and so on. layout-radial will\nattempt to account for asymmetrical graphs and give more space to branches that\nare wider. layout-radial also takes a breed as an input so you use one breed\nof links to layout the network and not another.\n\nGiven a set of anchor nodes layout-tutte places all the other nodes at the\ncenter of mass of the nodes it is linked to. The anchor set is automatically\narranged in a circle layout with a user defined radius and the other nodes will\nconverge into place (this of course means that you may have to run it several\ntimes before the layout is stable.)\n\nlayout-spring is useful for many kinds of networks. The drawback is that is\nrelatively slow since it takes many iterations to converge. In this layout the\nlinks act as springs that pull the nodes they connect toward each other and the\nnodes repel each other. The strength of the forces is controlled by inputs to\nthe primitives. These inputs will always have a value between 0 and 1; keep in\nmind that very small changes can still affect the appearance of the network. The\nsprings also have a length (in patch units), however, because of all the forces\ninvolved the nodes will not end up exactly that distance from each other.\n\n**Code Examples:**Network Example, Network Import Example, Giant Component,\nSmall Worlds, Preferential Attachment\n\n"
      ],
      "381": [
            "Represent this documentation section of Netlogo programmer's guide for retrieval:",
            "Here is a relevant example from the netlogo programmer's guide:\nSection Name: Anonymous procedures \n\nEntry Data: Anonymous procedures\nAnonymous procedures let you store code to be run later. Just like regular\nNetLogo procedures, an anonymous procedures can be either a command (anonymous\ncommand) or a reporter (anonymous reporter).\nAnonymous procedures are values, which means they may be passed as input,\nreported as a result, or stored in a variable.\nAn anonymous procedure might be run once, multiple times, or not at all.\nIn other programming languages anonymous procedures are known as first-class\nfunctions, closures, or lambda.\nAnonymous procedure primitives\nPrimitives specific to anonymous procedures are ->, is-anonymous-command?,\nand is-anonymous-reporter?.\nThe -> creates an anonymous procedure. The anonymous procedure it reports\nmight be a command or a reporter, depending on what kind of block you pass it.\nFor example [ -> fd 1 ] reports an anonymous command, because fd is a\ncommand, while [ -> count turtles ] reports an anonymous reporter, because\ncount is a reporter.\nThese primitives require anonymous procedures as input: foreach, map,\nreduce, filter, n-values, sort-by. When calling these primitives, using\nan -> is optional if your anonymous procedure contains a single primitive\nwhich has requires no more inputs than are are provided by the primitive. For\nexample one may write simply foreach mylist print instead of\nforeach mylist [ [x] -> print x ], though the latter is also accepted.\nDepending on the anonymous procedure, various parts of the anonymous procedure\nsyntax can be omitted. For a summary of optional syntax, see\nthe table below.\nThe run command accepts anonymous commands as well as strings.\nThe runresult reporter accepts anonymous reporters as well as strings.\nrun and runresult allow passing inputs to an anonymous procedure. As with\nall primitives accepting varying number of inputs, the whole call must be\nsurrounded with parentheses, so for example (run my-anonymous-command 5) or\n(runresult my-anonymous-reporter \"foo\" 2). When not passing input, no\nparentheses are required.\nAnonymous procedure inputs\nAn anonymous procedure may take zero or more inputs. The inputs are referenced\nthe variables declared before the arrow. For instance, in the anonymous reporter\n[ [a b] -> a + b ], a and b are inputs.\nAnonymous procedures and strings\nCreating and running anonymous procedures is fast. To use run or runresult\non a new string for the first time is about 100x slower than running an\nanonymous procedure. Modelers should normally use anonymous procedures instead\nof running strings, except when running strings entered by the user.\nConcise syntax\nSimple uses of foreach, map, reduce, filter, n-values, and sort-by\ncan be written with an especially concise syntax. You can write:\nmap abs [1 -2 3 -4]\n;; => [1 2 3 4]\nreduce + [1 2 3 4]\n;; => 10\nfilter is-number? [1 \"x\" 3]\n;; => [1 3]\nforeach [1 2 3 4] print\n;; prints 1 through 4\n\nIn older NetLogo versions (4 and earlier), these had to be written:\nmap [abs ?] [1 -2 3 -4]\n;; => [1 2 3 4]\nreduce [?1 + ?2] [1 2 3 4]\n;; => 10\nfilter [is-number? ?] [1 \"x\" 3]\n;; => [1 3]\nforeach [1 2 3 4] [ print ? ]\n;; prints 1 through 4\n\nAnonymous procedures as closures\nAnonymous procedures are \u201cclosures\u201d; that means they capture or \u201cclose over\u201d the\nbindings (not just the current values) of local variables and procedure inputs.\nThey do not capture agent variables and do not capture the identity (or even the\nagent type) of the current agent.\nNonlocal exits\nThe stop and report commands exit from the dynamically enclosing procedure,\nnot the enclosing anonymous procedure. (This is backward-compatible with older\nNetLogo versions.)\nAnonymous procedures and extensions\nThe extensions API supports writing primitives that accept anonymous procedures\nas input. Write us for sample code.\nLimitations\nWe hope to address at least some of the following limitations in future NetLogo\nversions:\n\nimport-world does not support anonymous procedures.\nAnonymous procedures can\u2019t be variadic (accept a varying number of inputs).\nAnonymous reporters can\u2019t contain commands, only a single reporter\nexpression. So for example you must use ifelse-value not if, and you don\u2019t\nuse report at all. If your code is too complex to be written as one\nreporter, you\u2019ll need to move the code to a separate reporter procedure, and\nthen call that procedure from your anonymous reporter, passing it any needed\ninputs.\nAnonymous procedures are not interchangeable with command blocks and reporter\nblocks. Only the primitives listed above accept anonymous procedures as input.\nControl primitives such as ifelse and while and agent primitives such as\nof and with don\u2019t accept anonymous procedures. So for example if I have an\nanonymous reporter let r [ -> if random 2 == 0 ] and two anonymous commands\nlet c1 [ -> tick ] and let c2 [ -> stop ], I can\u2019t write ifelse r c1 c2,\nI must write ifelse runresult r [ run c1 ] [ run c2 ].\nThe concise syntax where -> may be omitted is only available to primitives\nand extension primitives, not ordinary procedures. So for example if I have a\nprocedure p that accepts an anonymous procedure as input, it must be called\nas e.g. p [ -> ... ] not p [ ... ].\n\nWhat is Optional?\nThere are several different ways of writing anonymous procedures which allow\nusers to omit part or all of the anonymous procedure syntax. These are\nsummarized in the table below.\n\n\n\n  What is the anonymous procedure like?\n  What can be left out?\n  Examples\n\n\n\n  \n    The anonymous procedure is a single primitive\n    \n      \n        input names\n        arrow\n        block brackets\n      \n    \n    \n      \n        foreach mylist stamp  ; no inputs\n        foreach mylist print  ; single input\n        (foreach xs ys setxy) ; multiple inputs\n        map round [1.3 2.4 3.5] ; reporter, single input\n        (map + [1 2 3] [4 5 6]) ; reporter, multiple inputs\n      \n    \n  \n  \n    The anonymous procedure takes no inputs\n    \n      \n        input names\n        arrow\n      \n    \n    \n      \n        foreach mylist [ print \"abc\" ]\n        map [ 4 ] mylist\n      \n    \n  \n  \n    The anonymous procedure has zero or one input(s)\n    \n      \n        brackets around input names\n      \n    \n    \n      \n        foreach mylist [ -> stamp ] ; no inputs\n        foreach mylist [ x -> print x ] ; single input\n        foreach mylist [ x -> rt x fd x ] ; multiple primitives, single input\n        map [ -> world-width ] mylist ; reporter, no inputs\n        map [ x -> x ^ 2 ] mylist ; reporter, single input \n    \n  \n  \n    Anonymous procedure takes more than one input\n    \n      \n        nothing\n      \n    \n    \n      \n        (foreach xs ys [ [ x y ] -> setx x + y ])\n        (map [ [ x y ] -> x mod round y ] xs ys)\n      \n    \n  \n\n\nNote: brackets around input names were always required in NetLogo 6.0.0.\nIf you copy and paste code into NetLogo 6.0.0 using anonymous procedures with\nunbracketed input names, the code will not compile until you add the brackets.\nCode example\n\nCode Example: State Machine Example\n\n"
      ],
      "382": [
            "Represent this documentation section of Netlogo programmer's guide for retrieval:",
            "Here is a relevant example from the netlogo programmer's guide:\nSection Name: Ask-Concurrent \n\nEntry Data: Ask-Concurrent\nNOTE: The following information is included only for backwards\ncompatibility. We don\u2019t recommend using the ask-concurrent primitive at all in\nnew models.\nIn very old versions of NetLogo, ask had simulated concurrent behavior by\ndefault. Since NetLogo 4.0 (2007), ask is serial, that is, the agents run\nthe commands inside the ask one at a time.\nThe following information describes the behavior of the ask-concurrent\ncommand, which behaves the way the old ask behaved.\nask-concurrent produces simulated concurrency via a mechanism of\nturn-taking. The first agent takes a turn, then the second agent takes a turn,\nand so on until every agent in the asked agentset has had a turn. Then we go\nback to the first agent. This continues until all of the agents have finished\nrunning all of the commands.\nAn agent\u2019s \u201cturn\u201d ends when it performs an action that affects the state of the\nworld, such as moving, or creating a turtle, or changing the value of a global,\nturtle, patch, or link variable. (Setting a local variable doesn\u2019t count.)\nThe forward (fd) and back (bk) commands are treated\nspecially. When used inside ask-concurrent, these commands can take multiple\nturns to execute. During its turn, the turtle can only move by one step. Thus,\nfor example, fd 20 is equivalent to repeat 20 [ fd 1 ], where the turtle\u2019s\nturn ends after each run of fd. If the distance specified isn\u2019t an integer,\nthe last fraction of step takes a full turn. So for example fd 20.3 is\nequivalent to repeat 20 [ fd 1 ] fd 0.3.\nThe jump command always takes exactly one turn, regardless of distance.\nTo understand the difference between ask and ask-concurrent, consider\nthe following two commands:\nask turtles [ fd 5 ]\nask-concurrent turtles [ fd 5 ]\n\nWith ask, the first turtle takes five steps forward, then the second turtle\ntakes five steps forward, and so on.\nWith ask-concurrent, all of the turtles take one step forward. Then they all\ntake a second step, and so on. Thus, the latter command is equivalent to:\nrepeat 5 [ ask turtles [ fd 1 ] ]\n\n\nCode Example: Ask-Concurrent Example shows the difference between ask\nand ask-concurrent.\n\nThe behavior of ask-concurrent cannot always be so simply reproduced using\nask, as in this example. Consider this command:\nask-concurrent turtles [ fd random 10 ]\n\nIn order to get the same behavior using ask, we would have to write:\nturtles-own [steps]\nask turtles [ set steps random 10 ]\nwhile [any? turtles with [steps > 0]] [\n  ask turtles with [steps > 0] [\n    fd 1\n    set steps steps - 1\n  ]\n]\n\nTo prolong an agent\u2019s \u201cturn\u201d, use the without-interruption command. (The\ncommand blocks inside some commands, such as create-turtles and hatch,\nhave an implied without-interruption around them.)\nNote that the behavior of ask-concurrent is completely deterministic. Given\nthe same code and the same initial conditions, the same thing will always happen\n(if you are using the same version of NetLogo and begin your model run with the\nsame random seed).\nIn general, we suggest you not use ask-concurrent at all. If you do, we\nsuggest you write your model so that it does not depend on the exact details of\nhow ask-concurrent works. We make no guarantees that its semantics will remain\nthe same in future versions of NetLogo, or that it will continue to be supported\nat all.\n"
      ],
      "383": [
            "Represent this documentation section of Netlogo programmer's guide for retrieval:",
            "Here is a relevant example from the netlogo programmer's guide:\nSection Name: User Interaction Primitives \n\nEntry Data: User Interaction Primitives\nNetLogo features several primitives which allow a model to interact with the\nuser. These primitives include user-directory,\nuser-file,\nuser-new-file,\nuser-input,\nuser-message,\nuser-one-of, and\nuser-yes-or-no?.\nThese primitives differ in precisely what interaction they take with the user.\nuser-directory, user-file, and user-new-file are all reporters which\nprompt the user to select an item from the file system and report the path of\nthe selected item to NetLogo. user-yes-or-no?, user-one-of, and user-input\nall prompt the user to provide input in the form of text or a selection.\nuser-message simply presents a message to the user.\nNote that all active forever buttons will pause when one of these primitives is\nused and will resume only when the user completes the interaction with the\nbutton.\nWhat does \u201cHalt\u201d mean?\nThe primitives which prompt the user for input, as well as user-message all\nprovide a \u201cHalt\u201d button. The effect of this button is the same for all of these\nprimitives - it halts the model. When the model is halted all running code is\nstopped, including buttons and the command center. Since halting stops code in\nthe middle of whatever it happened to be doing at the time it was halted, you\nmay see strange results if you continue to run the model after a halt without\nsetting it up again.\n"
      ],
      "384": [
            "Represent this documentation section of Netlogo programmer's guide for retrieval:",
            "Here is a relevant example from the netlogo programmer's guide:\nSection Name: Tie \n\nEntry Data: Tie\nTie connects two turtles so that the movement of one turtles affects the\nlocation and heading of another. Tie is a property of links so there must be a\nlink between two turtles to create a tie relationship.\nWhen a link\u2019s tie-mode is set to \u201cfixed\u201d or \u201cfree\u201d end1 and end2 are\ntied together. If the link is directed end1 is the \u201croot agent\u201d and end2\nis the \u201cleaf agent\u201d. That is when end1 moves (using fd,\njump, setxy, etc.) end2 also moves the same distance and direction.\nHowever when end2 moves it does not affect end1.\nIf the link is undirected it is a reciprocal tie relationship, meaning, if\neither turtle moves the other turtle will also move. So depending on which\nturtle is moving either turtle can be considered the root or the leaf. The root\nturtle is always the turtle that initiates the movement.\nWhen the root turtle turns right or left, the leaf turtle rotates around the\nroot turtle the same amount as if a stiff were attaching the turtles. When\ntie-mode is set to \u201cfixed\u201d the heading of the leaf turtle changes by the\nsame amount. If the tie-mode is set to \u201cfree\u201d the heading of the leaf turtle\nis unchanged.\nThe tie-mode of a link can be set to \u201cfixed\u201d using the tie command and\nset to \u201cnone\u201d (meaning the turtles are no longer tied) using untie to set\nthe mode to \u201cfree\u201d you need to: set tie-mode \"free\".\n\nCode Example: Tie System Example\n\n"
      ],
      "385": [
            "Represent this documentation section of Netlogo programmer's guide for retrieval:",
            "Here is a relevant example from the netlogo programmer's guide:\nSection Name: Multiple source files \n\nEntry Data: Multiple source files\nThe __includes keyword allows you to use multiple source files in a single\nNetLogo model.\nThe keyword begins with two underscores to indicate that the feature is\nexperimental and may change in future NetLogo releases.\nWhen you open a model that uses the __includes keyword, or if you add it to\nthe top of a model and hit the Check button, the includes menu will appear in\nthe toolbar. From the includes menu you can select from the files included in\nthis model.\nWhen you open included files they appear in additional tabs. See the\nInterface Guide for more details.\nYou can have anything in external source files (.nls) that you would normally\nput in the Code tab: globals, breed, turtles-own, patches-own,\nbreeds-own, procedure definitions, etc. Note though that these\ndeclarations all share the same namespace. That is, if you declare a global\nmy-global in the Code tab you cannot declare a global (or anything else) with\nthe name my-global in any file that is included in the model. my-global will\nbe accessible from all the included files. The same would be true if my-global\nwere declared in one of the included files.\n"
      ],
      "386": [
            "Represent this header file from a custom port of netlogo to C++ for retrieval:",
            "Here is a block of relevant header file code:\nSection Name: WORLD_H \n\nEntry Data: \n// world.h\n#ifndef WORLD_H\n#define WORLD_H\n\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <vector>\n#include <stdlib.h>\n#include <memory>\n#include <algorithm>\n#include <random>\n\n\n#include 'parameters.h'\n#include 'agent.h'\n#include 'patch.h'\n#include 'turtle.h'\n#include 'bacteria.h'\n#include 'antibodies.h'\n#include 'fdcs.h'\n#include 'naive_b_cell.h'\n#include 'activated_b_cell.h'\n#include 'gc_b_cell.h'\n#include 'sl_plasma_cell.h'\n#include 'll_plasma_cell.h'\n#include 'mem_b_cell.h'\n#include 'breg_cell.h'\n#include 'tfh_cell.h'\n#include 'th0_cell.h'\n#include 'th1_cell.h'\n#include 'th2_cell.h'\n\nclass World {\nprivate:\n  std::mt19937 RNG_Engine;\n  int global_ID_counter;  //ID counter for creating new turtles to make sure each has a unique ID\n  int step;\n  int time;\n  int loop_run;\n\n  // NetLogo global variables\n  int days_passed;\n  double average_cd21_expression;\n  int total_num_of_apoptosed_cells;\n\n  Patch all_patches[WORLD_WIDTH][WORLD_HEIGHT];\n\n  // Vectors of shared pointers to different turtle subclasses\n  std::vector<std::shared_ptr<Bacteria>> all_bacterias;\n  std::vector<std::shared_ptr<Antibodies>> all_antibodies;\n  std::vector<std::shared_ptr<FDCs>> all_fdcs;\n  std::vector<std::shared_ptr<NaiveBCell>> all_naive_b_cells;\n  std::vector<std::shared_ptr<ActivatedBCell>> all_activated_b_cells;\n  std::vector<std::shared_ptr<GCBCell>> all_gcb_cells;\n  std::vector<std::shared_ptr<SLPlasmaCell>> all_sl_plasma_cells;\n  std::vector<std::shared_ptr<LLPlasmaCell>> all_ll_plasma_cells;\n  std::vector<std::shared_ptr<MemBCell>> all_mem_b_cells;\n  std::vector<std::shared_ptr<BregCell>> all_breg_cells;\n  std::vector<std::shared_ptr<TfhCell>> all_tfh_cells;\n  std::vector<std::shared_ptr<Th0Cell>> all_th0_cells;\n  std::vector<std::shared_ptr<Th1Cell>> all_th1_cells;\n  std::vector<std::shared_ptr<Th2Cell>> all_th2_cells;\n  std::vector<std::shared_ptr<Turtle>> all_turtles_to_kill;\n\n  void set_rng_seed(int newSeed){RNG_Engine.seed(newSeed);}\n  void add_patch(int x, int y);\n\npublic:\n  std::vector<std::weak_ptr<Turtle>> all_turtles;\n\n  World(){};\n\n  Patch& get_patch(double x_arg, double y_arg);\n  Patch& get_patch_ahead(std::shared_ptr<Turtle> turtle, float distance=1);\n  Patch& get_patch_ahead_right(std::shared_ptr<Turtle> turtle, float distance=1);\n  Patch& get_patch_ahead_left(std::shared_ptr<Turtle> turtle, float distance=1);\n\n  void setup_patches();\n  void display_patches();\n\n  void add_turtle(int x, int y, int id, int heading=0);\n  void place_turtle(double x, double y, std::shared_ptr<Turtle> turtle);\n  void move_turtle(std::shared_ptr<Turtle> turtle, float distance=1);\n  void move_turtle_random_jump(std::shared_ptr<Turtle> turtle);\n  void turtle_wiggle(std::shared_ptr<Turtle> turtle);\n\n  void kill_turtle(std::shared_ptr<Turtle> turtle);\n\n  // templated function to kill any turtle or agent\n  template <typename T>\n  void kill(std::shared_ptr<T> &ptr){\n    // std::cout<<'Killing turtle with ID '<<ptr->getID()<<std::endl;\n    ptr->removeLinkedTurtle();\n    all_turtles_to_kill.push_back(ptr);\n    kill_turtle(ptr);\n  }\n\n  void updateTurtleVectors();\n\n  void setup();\n  void go();\n\n  void check_overall_cd21_expression();\n  void calculateIncomingTNFaIL6Level();\n  void simulateBackgroundInflammation();\n  void update_chemokine_gradient();\n  void auto_inoculate(int numBac);\n\n  void diffuse();\n  void evaporate();\n\n  void spawnTh0Cell();\n  void spawnBCell();\n\n  void fdcFunction(std::shared_ptr<FDCs> fdc);\n  void antibodiesFunction(std::shared_ptr<Antibodies> antibody);\n  void naiveBCellFunction(std::shared_ptr<NaiveBCell> naive_b_cell);\n  void bregFunction(std::shared_ptr<BregCell> breg_cell);\n  void activatedBCellFunction(std::shared_ptr<ActivatedBCell> activated_b_cell);\n  void tdResponse(std::shared_ptr<ActivatedBCell> activated_b_cell);\n  void tiResponse(std::shared_ptr<ActivatedBCell> activated_b_cell);\n  void gc_b_cell_function(std::shared_ptr<GCBCell> gc_b_cell);\n  void ll_plasma_cell_function(std::shared_ptr<LLPlasmaCell> ll_plasma_cell);\n  void sl_plasma_cell_function(std::shared_ptr<SLPlasmaCell> sl_plasma_cell);\n  void memBCellFunction(std::shared_ptr<MemBCell> naive_b_cell);\n  void th0CellFunction(std::shared_ptr<Th0Cell> th0_cell);\n  void tfhCellFunction(std::shared_ptr<TfhCell> tfh_cell);\n  void th1CellFunction(std::shared_ptr<Th1Cell> th1_cell);\n  void th2CellFunction(std::shared_ptr<Th2Cell> th2_cell);\n  void bacteriaFunction(std::shared_ptr<Bacteria> bacteria);\n\n  std::shared_ptr<Antibodies> getOneAntibodyHere(int xPos, int yPos);\n  std::shared_ptr<FDCs> getOneFDCHere(int patchX, int patchY);\n  std::shared_ptr<Bacteria> getOneBacteriaHere(int patchX, int patchY);\n  std::shared_ptr<Th2Cell> getOneTh2Here(int patchX, int patchY);\n  std::shared_ptr<TfhCell> getOneTfhHere(int patchX, int patchY);\n  std::shared_ptr<ActivatedBCell> getOneActivatedBCellHere(int patchX, int patchY);\n  std::vector<std::shared_ptr<FDCs>> get_fdcs_with_no_presented_antigen();\n\n  // void checkTNFStatus(std::shared_ptr<T> cell) lives at bottom because of template declaration restrictions\n  void isotypeSwitch(std::shared_ptr<ActivatedBCell> activated_b_cell);\n  // Getters and setters for global variables\n  int getDaysPassed() const { return days_passed; }\n  void setDaysPassed(int days) { days_passed = days; }\n\n  double getAverageCD21Expression() const { return average_cd21_expression; }\n  void setAverageCD21Expression(double expr) { average_cd21_expression = expr; }\n\n  int getTotalNumOfApoptosedCells() const { return total_num_of_apoptosed_cells; }\n  void setTotalNumOfApoptosedCells(int num) { total_num_of_apoptosed_cells = num; }\n\n\n};\n\n\n#endif\n"
      ],
      "387": [
            "Represent this header file from a custom port of netlogo to C++ for retrieval:",
            "Here is a block of relevant header file code:\nSection Name: ACTIVATED_B_CELL_H \n\nEntry Data: \n#ifndef ACTIVATED_B_CELL_H\n#define ACTIVATED_B_CELL_H\n\n#include 'turtle.h'\n\nclass ActivatedBCell : public Turtle {\nprivate:\n    // Response type for activated B cells\n    int response_type;\n\npublic:\n    // You can add specific methods and properties for this subclass\n    ActivatedBCell(int x, int y, int id, int heading);\n\n    // Override Turtle methods if needed\n\n    // Getter for response type\n    int getResponseType() const { return response_type; }\n\n    // Setter for response type\n    void setResponseType(int response_type) { this->response_type = response_type; }\n\n};\n\n#endif\n"
      ],
      "388": [
            "Represent this header file from a custom port of netlogo to C++ for retrieval:",
            "Here is a block of relevant header file code:\nSection Name:     template <typename agent>\n    double angle_to(agent& target) \n\nEntry Data:     template <typename agent>\n    double angle_to(agent& target){\n      int targetx = target.getX();\n      int targety = target.getY();\n\n      int delta_x = targetx - x;\n      int delta_y = y - targety; //do this opposite to X because the origin is in the top left corner\n\n      // dealing with when the world wraps and target is all the way on the left, and from is all the way on the right\n      // it would give a delta_x close to -WORLD_WIDTH,\n      if ((delta_x + WORLD_WIDTH) < abs(delta_x)){\n        delta_x = (delta_x + WORLD_WIDTH)% WORLD_WIDTH;\n      }\n      if ((delta_y + WORLD_HEIGHT) < abs(delta_y)){\n        delta_y = (delta_y + WORLD_HEIGHT)% WORLD_HEIGHT;\n      }\n      // opposite case as above\n      if ((abs(delta_x - WORLD_WIDTH)) < abs(delta_x)){\n        delta_x -= WORLD_WIDTH;\n      }\n      if ((abs(delta_y - WORLD_WIDTH)) < abs(delta_y)){\n        delta_y -= WORLD_HEIGHT;\n      }\n\n      // std::cout<<'Angle To neighbor 0-TL(degrees)'<<atan2(1,-1) * 180/M_PI<<std::endl;\n      // std::cout<<'Angle To neighbor 1-T(degrees)'<<atan2(1,0) * 180/M_PI<<std::endl;\n      // std::cout<<'Angle To neighbor 2-TR(degrees)'<<atan2(1,1) * 180/M_PI<<std::endl;\n      // std::cout<<'Angle To neighbor 3-L(degrees)'<<atan2(0,-1) * 180/M_PI<<std::endl;\n      // std::cout<<'Angle To neighbor 4-R(degrees)'<<atan2(0,1) * 180/M_PI<<std::endl;\n      // std::cout<<'Angle To neighbor 5-BL(degrees)'<<atan2(-1,-1) * 180/M_PI<<std::endl;\n      // std::cout<<'Angle To neighbor 6-B(degrees)'<<atan2(-1,0) * 180/M_PI<<std::endl;\n      // std::cout<<'Angle To neighbor 7-BR(degrees)'<<atan2(-1,1) * 180/M_PI<<std::endl;\n\n      double angle_radian = atan2(delta_y, delta_x);\n      while (angle_radian<0){angle_radian+=2*M_PI;}\n\n      return angle_radian *  180/M_PI;\n    }\n"
      ],
      "389": [
            "Represent this header file from a custom port of netlogo to C++ for retrieval:",
            "Here is a block of relevant header file code:\nSection Name: AGENT_H \n\nEntry Data: \n// agent.h\n#ifndef AGENT_H\n#define AGENT_H\n\n#include <memory>\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <algorithm>\n#include <random>\n#include 'parameters.h'\n\nclass Agent: public std::enable_shared_from_this<Agent> {\n  protected:\n    Agent(int x, int y) : x(x), y(y) {}\n  private:\n    std::string color = '';\n    std::string secondaryColor = '';\n    std::string shape = '';\n    int size=1;\n    int alpha = 255;\n    int x;\n    int y;\n    bool visible = true;\n  public:\n    virtual double getX() const {return x;};\n    virtual double getY() const {return y;};\n    virtual void setX(int newX){x=newX;};\n    virtual void setY(int newY){y=newY;};\n    void setColor(std::string newColor){color = newColor;};\n    std::string getColor() const {return color;};\n    void setSecondaryColor(std::string newColor){secondaryColor = newColor;};\n    std::string getSecondaryColor() const {return secondaryColor;};\n    void setShape(std::string newShape){shape = newShape;};\n    std::string getShape() const {return shape;};\n    void setOpacity(int newAlpha){alpha = newAlpha;};\n    int getOpacity() const {return alpha;};\n\n    void setSize(int newSize){size = newSize;};\n    int getSize() const {return size;};\n\n    void setVisible(bool status){visible = status;}\n    bool getVisible() const {return visible;}\n\n    std::weak_ptr<Agent> createWeakPtr() {std::cout<<'getting pointer from this in agent' <<std::endl; return shared_from_this();}\n\n\n};\n\n\n#endif"
      ],
      "390": [
            "Represent this header file from a custom port of netlogo to C++ for retrieval:",
            "Here is a block of relevant header file code:\nSection Name: ANTIBODIES_H \n\nEntry Data: \n#ifndef ANTIBODIES_H\n#define ANTIBODIES_H\n\n#include 'turtle.h'\n#include <string>\n\nclass Antibodies : public Turtle {\nprivate:\n    // Type of the antibody\n    std::string antibody_type;\n\npublic:\n    // You can add specific methods and properties for this subclass\n    Antibodies(int x, int y, int id, int heading=90);\n\n    // Override Turtle methods if needed\n\n    // Getter for antibody type\n    std::string getAntibodyType() const { return antibody_type; }\n\n    // Setter for antibody type\n    void setAntibodyType(const std::string& antibody_type) { this->antibody_type = antibody_type; }\n};\n\n#endif\n"
      ],
      "391": [
            "Represent this header file from a custom port of netlogo to C++ for retrieval:",
            "Here is a block of relevant header file code:\nSection Name: BACTERIA_H \n\nEntry Data: \n#ifndef BACTERIA_H\n#define BACTERIA_H\n\n#include 'turtle.h'\n#include <string>\n\nclass Bacteria : public Turtle {\nprivate:\n    // Type of the epitope\n    int epitope_type;\n    // Number of TI-ep\n    int num_TI_ep;\n    // Number of TD-ep\n    int num_TD_ep;\n\npublic:\n    // You can add specific methods and properties for this subclass\n    Bacteria(int x, int y, int id, int heading=90);\n\n    // Override Turtle methods if needed\n\n    // Getter for epitope type\n    int getEpitopeType() const { return epitope_type; }\n\n    // Setter for epitope type\n    void setEpitopeType(const int epitope_type) { this->epitope_type = epitope_type; }\n\n    // Getter for num_TI_ep\n    int getNumTIep() const { return num_TI_ep; }\n\n    // Setter for num_TI_ep\n    void setNumTIep(int num_TI_ep) { this->num_TI_ep = num_TI_ep; }\n\n    // Getter for num_TD_ep\n    int getNumTDep() const { return num_TD_ep; }\n\n    // Setter for num_TD_ep\n    void setNumTDep(int num_TD_ep) { this->num_TD_ep = num_TD_ep; }\n};\n\n#endif\n"
      ],
      "392": [
            "Represent this header file from a custom port of netlogo to C++ for retrieval:",
            "Here is a block of relevant header file code:\nSection Name: BREG_CELL_H \n\nEntry Data: \n#ifndef BREG_CELL_H\n#define BREG_CELL_H\n\n#include 'turtle.h'\n\nclass BregCell : public Turtle {\npublic:\n    // You can add specific methods and properties for this subclass\n    BregCell(int x, int y, int id, int heading=0);\n\n    // Override Turtle methods if needed\n};\n\n#endif\n"
      ],
      "393": [
            "Represent this header file from a custom port of netlogo to C++ for retrieval:",
            "Here is a block of relevant header file code:\nSection Name: FDCS_H \n\nEntry Data: \n#ifndef FDCS_H\n#define FDCS_H\n\n#include 'turtle.h'\n#include <string>\n\nclass FDCs : public Turtle {\nprivate:\n    // Presented antigen\n    int presented_antigen;\n    // Time presenting\n    int time_presenting;\n    // Type of presented antigen\n    int presented_antigen_type;\n    // Responsiveness\n    int responsiveness;\n\npublic:\n    // You can add specific methods and properties for this subclass\n    FDCs(int x, int y, int id, int heading=90);\n\n    // Override Turtle methods if needed\n\n    // Getter for presented antigen\n    int getPresentedAntigen() const { return presented_antigen; }\n\n    // Setter for presented antigen\n    void setPresentedAntigen(int new_presented_antigen) { this->presented_antigen = new_presented_antigen; }\n\n    // Getter for time presenting\n    int getTimePresenting() const { return time_presenting; }\n\n    // Setter for time presenting\n    void setTimePresenting(int time_presenting) { this->time_presenting = time_presenting; }\n\n    // Getter for presented antigen type\n    int getPresentedAntigenType() const { return presented_antigen_type; }\n\n    // Setter for presented antigen type\n    void setPresentedAntigenType(int presented_antigen_type) { this->presented_antigen_type = presented_antigen_type; }\n\n    // Getter for responsiveness\n    int getResponsiveness() const { return responsiveness; }\n\n    // Setter for responsiveness\n    void setResponsiveness(int responsiveness) { this->responsiveness = responsiveness; }\n\n    void calculate_responsiveness();\n};\n\n#endif\n"
      ],
      "394": [
            "Represent this header file from a custom port of netlogo to C++ for retrieval:",
            "Here is a block of relevant header file code:\nSection Name: GC_B_CELL_H \n\nEntry Data: \n#ifndef GC_B_CELL_H\n#define GC_B_CELL_H\n\n#include 'turtle.h'\n\nclass GCBCell : public Turtle {\npublic:\n    // You can add specific methods and properties for this subclass\n    GCBCell(int x, int y, int id, int heading=90);\n\n    // Override Turtle methods if needed\n};\n\n#endif\n"
      ],
      "395": [
            "Represent this header file from a custom port of netlogo to C++ for retrieval:",
            "Here is a block of relevant header file code:\nSection Name: HELPER_FUNCTIONS_H \n\nEntry Data: \n\n#ifndef HELPER_FUNCTIONS_H\n#define HELPER_FUNCTIONS_H\n\n#include <iostream>\n#include <vector>\n#include <cmath>\n\n\ndouble calculateDistance(int x1, int y1, int x2, int y2);\nstd::vector<std::pair<int, int>> generateCoordinates(int number_to_generate, int center_x, int center_y, int radius_from_center, int buffer_zone_between_points);\n\n#endif"
      ],
      "396": [
            "Represent this header file from a custom port of netlogo to C++ for retrieval:",
            "Here is a block of relevant header file code:\nSection Name: LL_PLASMA_CELL_H \n\nEntry Data: \n#ifndef LL_PLASMA_CELL_H\n#define LL_PLASMA_CELL_H\n\n#include 'turtle.h'\n\nclass LLPlasmaCell : public Turtle {\npublic:\n    // You can add specific methods and properties for this subclass\n    LLPlasmaCell(int x, int y, int id, int heading=90);\n\n    // Override Turtle methods if needed\n};\n\n#endif\n"
      ],
      "397": [
            "Represent this header file from a custom port of netlogo to C++ for retrieval:",
            "Here is a block of relevant header file code:\nSection Name: MEM_B_CELL_H \n\nEntry Data: \n#ifndef MEM_B_CELL_H\n#define MEM_B_CELL_H\n\n#include 'turtle.h'\n\nclass MemBCell : public Turtle {\nprivate:\n    // Time in follicle for memory B cells\n    int time_in_follicle;\n\npublic:\n    // You can add specific methods and properties for this subclass\n    MemBCell(int x, int y, int id, int heading=90);\n\n    // Override Turtle methods if needed\n\n    // Getter for time in follicle\n    int getTimeInFollicle() const { return time_in_follicle; }\n\n    // Setter for time in follicle\n    void setTimeInFollicle(int time_in_follicle) { this->time_in_follicle = time_in_follicle; }\n};\n\n#endif\n"
      ],
      "398": [
            "Represent this header file from a custom port of netlogo to C++ for retrieval:",
            "Here is a block of relevant header file code:\nSection Name: NAIVE_B_CELL_H \n\nEntry Data: \n#ifndef NAIVE_B_CELL_H\n#define NAIVE_B_CELL_H\n\n#include 'turtle.h'\n\nclass NaiveBCell : public Turtle {\nprivate:\n\npublic:\n    // You can add specific methods and properties for this subclass\n    NaiveBCell(int x, int y, int id, int heading=90);\n\n    // Override Turtle methods if needed\n};\n\n#endif\n"
      ],
      "399": [
            "Represent this header file from a custom port of netlogo to C++ for retrieval:",
            "Here is a block of relevant header file code:\nSection Name: PARAMETERS_H \n\nEntry Data: \n// parameters.h\n#ifndef PARAMETERS_H\n#define PARAMETERS_H\n\nconst bool RENDERING = true;\nconst bool SAVING_DATA = false;\nconst bool TURTLE_CONTINOUS_MOVEMENT = true;\nconst bool TOROIDAL_WORLD = false;\n\nconst int RNG_SEED=108;\nconst int NUM_STEPS = 10000;\n\n\nconst static int WORLD_WIDTH = 101;\nconst static int WORLD_HEIGHT = 101;\nconst int PATCH_MAX_CAPACITY = 10000;\nconst int MAX_RANDOM_DISTANCE = 100;\n\n// this netlgoo implementation specific variables\nconst bool RandomRuns = false;\nconst bool AUTOINOCULATE = true;\nconst int AUTOINOCULATE_FIRST_TIME = 480;\nconst int AUTOINOCULATE_SECOND_TIME = 2880;\nconst int STOP_EXPOSURE_TIME = 4800;\nconst int FIRST_EXPOSURE_AMOUNT = 50;\nconst int SECOND_EXPOSURE_AMOUNT = 50;\nconst int BACTERIA_SIZE = 2;\n\nconst int BACTERIA_EPITOPE_TYPE = 30;\nconst int NUMBER_OF_TI_EPITOPES = 10;\nconst int NUMBER_OF_TD_EPITOPES = 10;\n\nconst int BCELL_CD21_ACTIVATION_THRESHOLD =101;\nconst int BCELL_TNFA_APOP_THRESHOLD = 277;\nconst int BCELL_BREG_DIFF_THRESHOLD = 181;\n\nconst int PHAG_IL6_BURST=0;\n\nconst int BACKGROUND_TNFA = 0;\nconst int BACKGROUND_IL6 = 0;\n\nstatic const int CXCL13_LEVEL_DIFFUSION_FACTOR = 1.0;\nstatic const int S1P_LEVEL_DIFFUSION_FACTOR = 1.0;\nstatic const int CCL19_LEVEL_DIFFUSION_FACTOR = 1.0;\nstatic const int EBI2_LEVEL_DIFFUSION_FACTOR = 1.0;\nstatic const int IL2_DIFFUSION_FACTOR = 1.0;\nstatic const int IL4_DIFFUSION_FACTOR = 1.0;\nstatic const int IL6_DIFFUSION_FACTOR = 1.0;\nstatic const int IL10_DIFFUSION_FACTOR = 1.0;\nstatic const int IL12_DIFFUSION_FACTOR = 1.0;\nstatic const int IL15_DIFFUSION_FACTOR = 1.0;\nstatic const int IL21_DIFFUSION_FACTOR = 1.0;\nstatic const int IF_G_DIFFUSION_FACTOR = 1.0;\nstatic const int IF_A_DIFFUSION_FACTOR = 1.0;\nstatic const int TNF_A_DIFFUSION_FACTOR = 1.0;\nstatic const int TGF_B_DIFFUSION_FACTOR = 1.0;\n\nstatic const double CXCL13_EVAPORATION_FACTOR = 0.9;\nstatic const double S1P_EVAPORATION_FACTOR = 0.9;\nstatic const double CCL19_EVAPORATION_FACTOR = 0.9;\nstatic const double EBI2_EVAPORATION_FACTOR = 0.9;\nstatic const double IL2_EVAPORATION_FACTOR = 0.9;\nstatic const double IL4_EVAPORATION_FACTOR = 0.9;\nstatic const double IL6_EVAPORATION_FACTOR = 0.95;\nstatic const double IL10_EVAPORATION_FACTOR = 0.95;\nstatic const double IL12_EVAPORATION_FACTOR = 0.9;\nstatic const double IL15_EVAPORATION_FACTOR = 0.9;\nstatic const double IL21_EVAPORATION_FACTOR = 0.9;\nstatic const double IF_G_EVAPORATION_FACTOR = 0.9;\nstatic const double IF_A_EVAPORATION_FACTOR = 0.9;\nstatic const double TNF_A_EVAPORATION_FACTOR = 0.9;\nstatic const double TGF_B_EVAPORATION_FACTOR = 0.9;\n\n#endif\n"
      ],
      "400": [
            "Represent this header file from a custom port of netlogo to C++ for retrieval:",
            "Here is a block of relevant header file code:\nSection Name: PATCH_H \n\nEntry Data: \n// patch.h\n#ifndef PATCH_H\n#define PATCH_H\n\n#include 'parameters.h'\n#include 'agent.h'\n#include 'turtle.h'\n#include <memory>\n#include <vector>\n\nclass Patch : public Agent{\nprivate:\n    std::vector<std::shared_ptr<Turtle>> turtles_here;\n\n    int patch_type;\n    double s1p_level, cxcl13_level, ccl19_level, ebi2_level;\n    double il2, il4, il6, il10, il12, il15, il21;\n    double if_g, if_a, tnf_a, tgf_b;\n\n    double temp_var; // placeholder for diffusion totals before updating\n    double temp_s1p_level, temp_cxcl13_level, temp_ccl19_level, temp_ebi2_level;\n    double temp_il2, temp_il4, temp_il6, temp_il10, temp_il12, temp_il15, temp_il21;\n    double temp_if_g, temp_if_a, temp_tnf_a, temp_tgf_b;\n\npublic:\n    virtual ~Patch() = default;\n    Patch():Agent(0,0){setColor('red');setModeColor('green');}; // base patch color is red\n    Patch(int xCoord, int yCoord) : Agent(xCoord, yCoord) {setColor('red');setModeColor('green');};\n\n    void setModeColor(std::string newColor){setSecondaryColor(newColor);}\n    std::string getModeColor(){return getSecondaryColor();}\n\n// In order to view a cytokine layer on top of everything,\n// specify what mode to view here by putting a patch variable, otherwise return 0\n    double getModeOpacity(){return il21;}\n\n    void add_turtle(std::shared_ptr<Turtle> turtle_to_add);\n    void remove_turtle(std::shared_ptr<Turtle> turtle_to_remove);\n    const std::vector<std::shared_ptr<Turtle>>& getTurtlesHere() const {return turtles_here;}\n    void display();\n    bool is_at_capacity();\n\n    void setTempVar(double newVal){temp_var=newVal;};\n    double getTempVar() const {return temp_var;};\n\n    void setPatchType(int type) { patch_type = type; }\n    int getPatchType() const { return patch_type; }\n\n    // Getter and setter for each new variable\n    // s1p_level\n    void setS1pLevel(double level) { s1p_level = level; }\n    double getS1pLevel() const { return s1p_level; }\n\n    // cxcl13_level\n    void setCxcl13Level(double level) { cxcl13_level = level; }\n    double getCxcl13Level() const { return cxcl13_level; }\n\n    // ccl19_level\n    void setCcl19Level(double level) { ccl19_level = level; }\n    double getCcl19Level() const { return ccl19_level; }\n\n    // ebi2_level\n    void setEbi2Level(double level) { ebi2_level = level; }\n    double getEbi2Level() const { return ebi2_level; }\n\n    // il2\n    void setIl2(double value) { il2 = value; }\n    double getIl2() const { return il2; }\n\n    // il4\n    void setIl4(double value) { il4 = value; }\n    double getIl4() const { return il4; }\n\n    // il6\n    void setIl6(double value) { il6 = value; }\n    double getIl6() const { return il6; }\n\n    // il10\n    void setIl10(double value) { il10 = value; }\n    double getIl10() const { return il10; }\n\n    // il12\n    void setIl12(double value) { il12 = value; }\n    double getIl12() const { return il12; }\n\n    // il15\n    void setIl15(double value) { il15 = value; }\n    double getIl15() const { return il15; }\n\n    // il21\n    void setIl21(double value) { il21 = value; }\n    double getIl21() const { return il21; }\n\n    // if_g\n    void setIfG(double value) { if_g = value; }\n    double getIfG() const { return if_g; }\n\n    // if_a\n    void setIfA(double value) { if_a = value; }\n    double getIfA() const { return if_a; }\n\n    // tnf_a\n    void setTnfA(double value) { tnf_a = value; }\n    double getTnfA() const { return tnf_a; }\n\n    // tgf_b\n    void setTgfB(double value) { tgf_b = value; }\n    double getTgfB() const { return tgf_b; }\n\n    // Getter and setter functions for temp_s1p_level\n    void setTempS1pLevel(double value) { temp_s1p_level = value; }\n    double getTempS1pLevel() const { return temp_s1p_level; }\n\n    // Getter and setter functions for temp_cxcl13_level\n    void setTempCxcl13Level(double value) { temp_cxcl13_level = value; }\n    double getTempCxcl13Level() const { return temp_cxcl13_level; }\n\n    // Getter and setter functions for temp_ccl19_level\n    void setTempCcl19Level(double value) { temp_ccl19_level = value; }\n    double getTempCcl19Level() const { return temp_ccl19_level; }\n\n    // Getter and setter functions for temp_ebi2_level\n    void setTempEbi2Level(double value) { temp_ebi2_level = value; }\n    double getTempEbi2Level() const { return temp_ebi2_level; }\n\n    // Getter and setter functions for temp_il2\n    void setTempIl2(double value) { temp_il2 = value; }\n    double getTempIl2() const { return temp_il2; }\n\n    // Getter and setter functions for temp_il4\n    void setTempIl4(double value) { temp_il4 = value; }\n    double getTempIl4() const { return temp_il4; }\n\n    // Getter and setter functions for temp_il6\n    void setTempIl6(double value) { temp_il6 = value; }\n    double getTempIl6() const { return temp_il6; }\n\n    // Getter and setter functions for temp_il10\n    void setTempIl10(double value) { temp_il10 = value; }\n    double getTempIl10() const { return temp_il10; }\n\n    // Getter and setter functions for temp_il12\n    void setTempIl12(double value) { temp_il12 = value; }\n    double getTempIl12() const { return temp_il12; }\n\n    // Getter and setter functions for temp_il15\n    void setTempIl15(double value) { temp_il15 = value; }\n    double getTempIl15() const { return temp_il15; }\n\n    // Getter and setter functions for temp_il21\n    void setTempIl21(double value) { temp_il21 = value; }\n    double getTempIl21() const { return temp_il21; }\n\n    // Getter and setter functions for temp_if_g\n    void setTempIfG(double value) { temp_if_g = value; }\n    double getTempIfG() const { return temp_if_g; }\n\n    // Getter and setter functions for temp_if_a\n    void setTempIfA(double value) { temp_if_a = value; }\n    double getTempIfA() const { return temp_if_a; }\n\n    // Getter and setter functions for temp_tnf_a\n    void setTempTnfA(double value) { temp_tnf_a = value; }\n    double getTempTnfA() const { return temp_tnf_a; }\n\n    // Getter and setter functions for temp_tgf_b\n    void setTempTgfB(double value) { temp_tgf_b = value; }\n    double getTempTgfB() const { return temp_tgf_b; }\n\n    // patch is the same iff the x and y positions are equal\n    bool operator== (Patch& that){return (this->getX()==that.getX() && this->getY()==that.getY());};\n\n    // Add more patch specific functions below for the particular implementation of a net logo model being ported\n};\n\n#endif\n"
      ],
      "401": [
            "Represent this header file from a custom port of netlogo to C++ for retrieval:",
            "Here is a block of relevant header file code:\nSection Name: RENDERING_H \n\nEntry Data: \n// rendering.h\n#ifndef RENDERING_H\n#define RENDERING_H\n\n//Using SDL and standard IO\n#include <SDL2/SDL.h>\n#include <stdlib.h>\n#include <string>\n#include <stdio.h>\n#include <tuple>\n#include 'world.h'\n\n#include 'parameters.h'\n\nclass RenderingEngine {\nprivate:\n  /* data */\n  SDL_Window* window;\n  SDL_Renderer* renderer;\n  World* myWorld;\n\n\npublic:\n  const static int GRID_SIZE = 10;\n  const static int SCREEN_WIDTH = WORLD_WIDTH * GRID_SIZE;\n  const static int SCREEN_HEIGHT = WORLD_WIDTH * GRID_SIZE;\n  RenderingEngine();\n  RenderingEngine(World *world);\n  ~RenderingEngine ();\n\n  std::tuple<int, int, int> getColor(const std::string& color);\n  void drawCircle(double centerX, double centerY, double radius=GRID_SIZE/2, const std::string& color='red', int alpha=SDL_ALPHA_OPAQUE);\n  void drawSquare(int x, int y, int size=GRID_SIZE, const std::string& color='red', int alpha=SDL_ALPHA_OPAQUE);\n  void drawLine(double startX, double startY, double endX, double endY, const std::string& color='black', int alpha=SDL_ALPHA_OPAQUE);\n  void drawFilledEllipse(int centerX, int centerY, int radiusX, int radiusY, const std::string& color='black', int alpha=SDL_ALPHA_OPAQUE, int angleDegrees=0);\n  void setBackgroundColor(const std::string& color='red');\n  void render();\n\n  void renderAllPatches();\n  void renderAllTurtles();\n  void renderPatchMode();\n};\n\n\n#endif\n"
      ],
      "402": [
            "Represent this header file from a custom port of netlogo to C++ for retrieval:",
            "Here is a block of relevant header file code:\nSection Name: SL_PLASMA_CELL_H \n\nEntry Data: \n#ifndef SL_PLASMA_CELL_H\n#define SL_PLASMA_CELL_H\n\n#include 'turtle.h'\n\nclass SLPlasmaCell : public Turtle {\npublic:\n    // You can add specific methods and properties for this subclass\n    SLPlasmaCell(int x, int y, int id, int heading=90);\n\n    // Override Turtle methods if needed\n};\n\n#endif\n"
      ],
      "403": [
            "Represent this header file from a custom port of netlogo to C++ for retrieval:",
            "Here is a block of relevant header file code:\nSection Name: TFH_CELL_H \n\nEntry Data: \n#ifndef TFH_CELL_H\n#define TFH_CELL_H\n\n#include 'turtle.h'\n\nclass TfhCell : public Turtle {\nprivate:\n    // Variables specific to TfhCell\n    bool bcell_binding_status; // Assuming it's a boolean status, adjust type as needed\n\npublic:\n    // You can add specific methods and properties for this subclass\n    TfhCell(int x, int y, int id, int heading=90);\n\n    // Override Turtle methods if needed\n\n    // Getter for bcell_binding_status\n    bool getBcellBindingStatus() const { return bcell_binding_status; }\n\n    // Setter for bcell_binding_status\n    void setBcellBindingStatus(bool status) { this->bcell_binding_status = status; }\n};\n\n#endif\n"
      ],
      "404": [
            "Represent this header file from a custom port of netlogo to C++ for retrieval:",
            "Here is a block of relevant header file code:\nSection Name: TH0_CELL_H \n\nEntry Data: \n#ifndef TH0_CELL_H\n#define TH0_CELL_H\n\n#include 'turtle.h'\n\nclass Th0Cell : public Turtle {\nprivate:\n    // Variables specific to Th0Cell\n    float r1;\n    float r2;\n    float rf;\n    float th1_activation;\n    float th2_activation;\n    float tfh_activation;\n\npublic:\n    // You can add specific methods and properties for this subclass\n    Th0Cell(int x, int y, int id, int heading=90);\n\n    // Override Turtle methods if needed\n\n    // Getter for r1\n    float getR1() const { return r1; }\n\n    // Setter for r1\n    void setR1(float r1) { this->r1 = r1; }\n\n    // Getter for r2\n    float getR2() const { return r2; }\n\n    // Setter for r2\n    void setR2(float r2) { this->r2 = r2; }\n\n    // Getter for rf\n    float getRf() const { return rf; }\n\n    // Setter for rf\n    void setRf(float rf) { this->rf = rf; }\n\n    // Getter for th1_activation\n    float getTh1Activation() const { return th1_activation; }\n\n    // Setter for th1_activation\n    void setTh1Activation(float th1_activation) { this->th1_activation = th1_activation; }\n\n    // Getter for th2_activation\n    float getTh2Activation() const { return th2_activation; }\n\n    // Setter for th2_activation\n    void setTh2Activation(float th2_activation) { this->th2_activation = th2_activation; }\n\n    // Getter for tfh_activation\n    float getTfhActivation() const { return tfh_activation; }\n\n    // Setter for tfh_activation\n    void setTfhActivation(float tfh_activation) { this->tfh_activation = tfh_activation; }\n};\n\n#endif\n"
      ],
      "405": [
            "Represent this header file from a custom port of netlogo to C++ for retrieval:",
            "Here is a block of relevant header file code:\nSection Name: TH1_CELL_H \n\nEntry Data: \n#ifndef TH1_CELL_H\n#define TH1_CELL_H\n\n#include 'turtle.h'\n\nclass Th1Cell : public Turtle {\nprivate:\n    // Variables specific to Th1Cell\n    bool bcell_binding_status; // Assuming it's a boolean status, adjust type as needed\n\npublic:\n    // You can add specific methods and properties for this subclass\n    Th1Cell(int x, int y, int id, int heading=0);\n\n    // Override Turtle methods if needed\n\n    // Getter for bcell_binding_status\n    bool getBcellBindingStatus() const { return bcell_binding_status; }\n\n    // Setter for bcell_binding_status\n    void setBcellBindingStatus(bool status) { this->bcell_binding_status = status; }\n};\n\n#endif\n"
      ],
      "406": [
            "Represent this header file from a custom port of netlogo to C++ for retrieval:",
            "Here is a block of relevant header file code:\nSection Name: TH2_CELL_H \n\nEntry Data: \n#ifndef TH2_CELL_H\n#define TH2_CELL_H\n\n#include 'turtle.h'\n\nclass Th2Cell : public Turtle {\nprivate:\n    // Variables specific to Th2Cell\n    bool bcell_binding_status; // Assuming it's a boolean status, adjust type as needed\n\npublic:\n    // You can add specific methods and properties for this subclass\n    Th2Cell(int x, int y, int id, int heading=0);\n\n    // Override Turtle methods if needed\n\n    // Getter for bcell_binding_status\n    bool getBcellBindingStatus() const { return bcell_binding_status; }\n\n    // Setter for bcell_binding_status\n    void setBcellBindingStatus(bool status) { this->bcell_binding_status = status; }\n};\n\n#endif\n"
      ],
      "407": [
            "Represent this header file from a custom port of netlogo to C++ for retrieval:",
            "Here is a block of relevant header file code:\nSection Name: TURTLE_H \n\nEntry Data: \n// turtle.h\n#ifndef TURTLE_H\n#define TURTLE_H\n\n#include 'agent.h'\n\n\nclass Turtle : public Agent{\n  public :\n    Turtle(int x, int y, int ID_num, int heading=90) : Agent(x, y), ID_num(ID_num), heading(heading) {x_dec=x; y_dec=y;};\n    virtual ~Turtle() = default;\n\n  private:\n    std::vector<std::weak_ptr<Turtle>> linkedTurtles;\n\n\n    int type =0;  //agent type, will be used for the get-one-of functions\n    int ID_num;\n    int heading;\n    // int age;\n    int time_alive;\n    bool is_alive=true;\n    float x_dec; //x and y decimal coordinates\n    float y_dec;\n    float temp_x; // temporary coords for turtle move, before actual turtle coords are moved in case destination patch is full.\n    float temp_y; // Turtle cant know about the world cause circular dependency in #include, so world will handle turtle movement between patches\n\n    // added turtles-own variables\n    bool in_blood;\n    int bcr;\n    std::string isotype;\n    bool csr_bool;\n    float tnfa_threshold;\n    float breg_threshold;\n    float cd21_level;\n    float s1pr1_level;\n    float s1pr2_level;\n    float cxcr5_level;\n    float ccr7_level;\n    float ebi2r_level;\n    bool pro_breg;\n    int level_of_activation;\n    float tnf_a_stimulation;\n    int exposure_number;\n\n    // add more variables that apply to all turtles here for the specific NetLogo model being ported\n\n  public:\n    std::pair<double,double> move(float distance=1);\n    std::pair<int,int> jumpRandom(std::mt19937 &RNG_Engine);\n    void execute_move(bool didMove);\n    void wiggle(std::mt19937 &RNG_Engine);\n    void display();\n    void copy_other_turtle_attributes(std::shared_ptr<Turtle> otherTurtle); // meant to be used when netlogo sets breed, cause this will copy values from original cell to new cell\n\n    int getID() const {return ID_num;};\n    int getType() const {return type;};\n\n    void setHeading(int newHeading){heading = newHeading;};\n    int getHeading() const {return heading;};\n\n    float get_x_dec() const {return x_dec;}       // already has regular getX() and getY() from agent parent class\n    float get_y_dec() const {return y_dec;}\n    void set_x_dec(double new_x_dec) {x_dec = new_x_dec;}\n    void set_y_dec(double new_y_dec) {y_dec = new_y_dec;}\n\n    float get_temp_x() const {return temp_x;}\n    float get_temp_y() const {return temp_y;}\n    void set_temp_x(double new_temp_x) {temp_x = new_temp_x;}\n    void set_temp_y(double new_temp_y) {temp_y = new_temp_y;}\n\n\n    void addLinkedTurtle(std::weak_ptr<Turtle> linkedTurtle);\n    void removeLinkedTurtle();\n    std::vector<std::weak_ptr<Turtle>>& getLinkedTurtles();\n\n\n\n\n    // Add setter and getter for new variables here\n    void set_is_alive(bool new_is_alive) { is_alive = new_is_alive; }\n    bool get_is_alive() const { return is_alive; }\n    // in_blood\n    void setInBlood(bool inBlood) { in_blood = inBlood; }\n    bool getInBlood() const { return in_blood; }\n\n    // bcr\n    void setBcr(int bcrValue) { bcr = bcrValue; }\n    int getBcr() const { return bcr; }\n\n    // isotype\n    void setIsotype(const std::string& isotypeValue) { isotype = isotypeValue; }\n    std::string getIsotype() const { return isotype; }\n\n    // csr_bool\n    void setCsrBool(bool csrBool) { csr_bool = csrBool; }\n    bool getCsrBool() const { return csr_bool; }\n\n    // time_alive\n    void setTimeAlive(int timeAlive) { time_alive = timeAlive; }\n    int getTimeAlive() const { return time_alive; }\n\n    // tnfa_threshold\n    void setTnfaThreshold(float threshold) { tnfa_threshold = threshold; }\n    float getTnfaThreshold() const { return tnfa_threshold; }\n\n    // breg_threshold\n    void setBregThreshold(float threshold) { breg_threshold = threshold; }\n    float getBregThreshold() const { return breg_threshold; }\n\n    // cd21_level\n    void setCd21Level(float level) { cd21_level = level; }\n    float getCd21Level() const { return cd21_level; }\n\n    // s1pr1_level\n    void setS1pr1Level(float level) { s1pr1_level = level; }\n    float getS1pr1Level() const { return s1pr1_level; }\n\n    // s1pr2_level\n    void setS1pr2Level(float level) { s1pr2_level = level; }\n    float getS1pr2Level() const { return s1pr2_level; }\n\n    // cxcr5_level\n    void setCxcr5Level(float level) { cxcr5_level = level; }\n    float getCxcr5Level() const { return cxcr5_level; }\n\n    // ccr7_level\n    void setCcr7Level(float level) { ccr7_level = level; }\n    float getCcr7Level() const { return ccr7_level; }\n\n    // ebi2r_level\n    void setEbi2rLevel(float level) { ebi2r_level = level; }\n    float getEbi2rLevel() const { return ebi2r_level; }\n\n    // pro_breg\n    void setProBreg(bool proBreg) { pro_breg = proBreg; }\n    bool getProBreg() const { return pro_breg; }\n\n    // level_of_activation\n    void setLevelOfActivation(int level) { level_of_activation = level; }\n    int getLevelOfActivation() const { return level_of_activation; }\n\n    // tnf_a_stimulation\n    void setTnfaStimulation(float stimulation) { tnf_a_stimulation = stimulation; }\n    float getTnfaStimulation() const { return tnf_a_stimulation; }\n\n    // exposure_number\n    void setExposureNumber(int exposureNumber) { exposure_number = exposureNumber; }\n    int getExposureNumber() const { return exposure_number; }\n\n    std::weak_ptr<Turtle> createWeakTurtlePtr() {\n      std::weak_ptr<Turtle> test = std::dynamic_pointer_cast<Turtle>(createWeakPtr().lock());\n      std::cout<<'greated weak turtle pointer in turtle function'<<std::endl;\n       return test;\n     }\n\n    bool operator== (const Turtle& turt2){return this->ID_num==turt2.ID_num;};\n    bool operator== (const Turtle* turt2){return this->ID_num==turt2->ID_num;};\n    bool operator== (const std::weak_ptr<Turtle> turt2){return this->ID_num==turt2.lock()->ID_num;};\n\n    // add more turtle specific functions below. These are functions that will apply to all turtle types, not a single breed\n\n};\n\n\n#endif"
      ],
      "408": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: ActivatedBCell::ActivatedBCell(int x, int y, int id, int heading) : Turtle(x, y, id, heading) \n\nEntry Data: ActivatedBCell::ActivatedBCell(int x, int y, int id, int heading) : Turtle(x, y, id, heading) {\n            // Constructor\n            // std::cout<<'Creating activated b cell with ID '<<id<<std::endl;\n        }"
      ],
      "409": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void World::isotypeSwitch(std::shared_ptr<ActivatedBCell> activated_b_cell)  \n\nEntry Data: void World::isotypeSwitch(std::shared_ptr<ActivatedBCell> activated_b_cell) {\n    // Get the patch where the activated b cell is\n    Patch& activated_b_cell_patch = get_patch(activated_b_cell->getX(), activated_b_cell->getY());\n\n    if (!activated_b_cell->getCsrBool()) {\n        double igM_bucket = activated_b_cell_patch.getIl12() + activated_b_cell_patch.getIl15() + activated_b_cell_patch.getIl6();\n        double igA_bucket = activated_b_cell_patch.getIl10() + activated_b_cell_patch.getIl15() + activated_b_cell_patch.getIl21() + activated_b_cell_patch.getTgfB();\n        double igG_bucket = activated_b_cell_patch.getIl4() + activated_b_cell_patch.getIl10() + activated_b_cell_patch.getIl15() + activated_b_cell_patch.getIl21();\n        double igE_bucket = activated_b_cell_patch.getIl4() - activated_b_cell_patch.getIl12() - activated_b_cell_patch.getIfA() - activated_b_cell_patch.getIfG() - activated_b_cell_patch.getTgfB() + activated_b_cell_patch.getIl21();\n\n        std::vector<double> mylist = {igM_bucket, igA_bucket, igG_bucket, igE_bucket};\n        int max_index = std::max_element(mylist.begin(), mylist.end()) - mylist.begin();\n\n        if (max_index == 0) {\n            activated_b_cell->setCsrBool(true);\n            activated_b_cell->setIsotype('m');\n        } else if (max_index == 1) {\n            activated_b_cell->setCsrBool(true);\n            activated_b_cell->setIsotype('a');\n        } else if (max_index == 2) {\n            activated_b_cell->setCsrBool(true);\n            activated_b_cell->setIsotype('g');\n        } else if (max_index == 3) {\n            activated_b_cell->setCsrBool(true);\n            activated_b_cell->setIsotype('e');\n        }\n    }\n}"
      ],
      "410": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void World::activatedBCellFunction(std::shared_ptr<ActivatedBCell> abcell)  \n\nEntry Data: void World::activatedBCellFunction(std::shared_ptr<ActivatedBCell> abcell) {\n  bool print_test = false;\n  if (!abcell->get_is_alive()) {return;}\n    // Only performs the following commands if currently inside the follicle, and NOT in the blood/lymph\n    if (print_test){std::cout<<'ABC function for ID '<<abcell->getID()<<' use count is '<<abcell.use_count()<<std::endl;}\n\n    if (!abcell->getInBlood()) {\n      if (print_test){std::cout<<'doing ABC function for not in blood'<<std::endl;}\n        // Get the patch where the B cell is\n        Patch& bcell_patch = get_patch(abcell->getX(), abcell->getY());\n\n        // If the cell reaches the follicle exit\n        if(bcell_patch.getPatchType() == 2) {\n            abcell->setInBlood(true);\n            abcell->setVisible(false);\n            if (print_test){std::cout<<'killing abc cell at follicle exit '<<abcell->getID()<<std::endl;}\n            if (print_test){std::cout<<'abcell use count is '<<abcell.use_count()<<std::endl;}\n            kill(abcell);\n            return;\n        }\n\n        isotypeSwitch(abcell);   // Determines which isotype to switch to\n        if (print_test){std::cout<<'abcell use count 1is '<<abcell.use_count()<<std::endl;}\n\n        if (abcell->getResponseType() == 2) {\n            tdResponse(abcell);\n            if (print_test){std::cout<<'abcell use count 2ais '<<abcell.use_count()<<std::endl;}\n            if (!abcell->get_is_alive()){return;}\n        } else if (abcell->getResponseType() == 1) {\n            tiResponse(abcell);\n            // return;\n            if (print_test){std::cout<<'abcell use count 2bis '<<abcell.use_count()<<std::endl;}\n        }\n\n        //abcell->checkBregStatus();\n        if (print_test){std::cout<<'abcell use count 3is '<<abcell.use_count()<<std::endl;}\n\n        chemotaxis(abcell);\n        if (print_test){std::cout<<'abcell use count 4is '<<abcell.use_count()<<std::endl;}\n\n        move_turtle(abcell);\n        if (print_test){std::cout<<'abcell use count 5is '<<abcell.use_count()<<std::endl;}\n\n    }\n\n    bool die_by_tnf = checkTNFStatus(abcell);\n    if (print_test){std::cout<<'abcell use count 6is '<<abcell.use_count()<<std::endl;}\n\n    abcell->setTimeAlive(abcell->getTimeAlive() + 1);\n    if ((abcell->getTimeAlive() > 300) || die_by_tnf) {\n        kill(abcell);\n        if (print_test){std::cout<<'killing abc cell at time alive or TNF'<<std::endl;}\n\n    }\n}"
      ],
      "411": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void World::tdResponse(std::shared_ptr<ActivatedBCell> activated_b_cell)  \n\nEntry Data: void World::tdResponse(std::shared_ptr<ActivatedBCell> activated_b_cell) {\n    // Try to get Tfh cell in the current location of the activated B cell\n    auto tfh = getOneTfhHere(activated_b_cell->getX(), activated_b_cell->getY());\n\n    // If a Tfh cell is found, create a new GcB cell and link it with the Tfh cell\n    if (tfh) {\n      if (tfh->getBcellBindingStatus()){std::cout<<'TFH CELL IS ALREADY BOUND TO; skipping'<<std::endl; return;}\n        auto new_gc_b_cell = std::make_shared<GCBCell>(activated_b_cell->getX(), activated_b_cell->getY(), global_ID_counter++, activated_b_cell->getHeading());\n        // std::cout<< 'activated b cell doing tdResponse at '<< activated_b_cell->getX()<<', '<<activated_b_cell->getY()<< 'for ID '<<activated_b_cell->getID()<<std::endl;\n        new_gc_b_cell->copy_other_turtle_attributes(activated_b_cell);\n        new_gc_b_cell->setProBreg(0);\n        new_gc_b_cell->setColor('orange');\n        new_gc_b_cell->setShape('circle');\n        new_gc_b_cell->setSize(1);\n        new_gc_b_cell->setTimeAlive(0);\n\n        std::weak_ptr<Turtle> new_gc_b_cell_weak_ptr = new_gc_b_cell;\n        all_turtles.push_back(new_gc_b_cell_weak_ptr);\n        all_gcb_cells.push_back(new_gc_b_cell);\n        get_patch(new_gc_b_cell->getX(), new_gc_b_cell->getY()).add_turtle(new_gc_b_cell);\n\n        // createLinkWith(new_gc_b_cell, tfh);\n        new_gc_b_cell->addLinkedTurtle(tfh);\n        tfh->setEbi2rLevel(0);\n        tfh->setCcr7Level(0);\n        tfh->setBcellBindingStatus(true);\n\n        kill(activated_b_cell);\n        return;\n    } else {\n        // If no Tfh cell is found, try to get a Th2 cell in the current location of the activated B cell\n        auto th2 = getOneTh2Here(activated_b_cell->getX(), activated_b_cell->getY());\n\n        // If a Th2 cell is found, create a new GcB cell and link it with the Th2 cell\n        if (th2) {\n          if (th2->getBcellBindingStatus()){std::cout<<'th2 CELL IS ALREADY BOUND TO; skipping'<<std::endl; return;}\n          // std::cout<< 'activated b cell doing tdResponse at '<< activated_b_cell->getX()<<', '<<activated_b_cell->getY()<< 'for ID '<<activated_b_cell->getID()<<std::endl;\n\n            auto new_gc_b_cell = std::make_shared<GCBCell>(activated_b_cell->getX(), activated_b_cell->getY(), global_ID_counter++, activated_b_cell->getHeading());\n            new_gc_b_cell->copy_other_turtle_attributes(activated_b_cell);\n            new_gc_b_cell->setProBreg(0);\n            new_gc_b_cell->setColor('orange');\n            new_gc_b_cell->setShape('circle');\n            new_gc_b_cell->setSize(1);\n            new_gc_b_cell->setTimeAlive(0);\n\n            std::weak_ptr<Turtle> new_gc_b_cell_weak_ptr = new_gc_b_cell;\n            all_turtles.push_back(new_gc_b_cell_weak_ptr);\n            all_gcb_cells.push_back(new_gc_b_cell);\n            get_patch(new_gc_b_cell->getX(), new_gc_b_cell->getY()).add_turtle(new_gc_b_cell);\n\n            // createLinkWith(new_gc_b_cell, th2);\n            new_gc_b_cell->addLinkedTurtle(th2);\n            th2->setEbi2rLevel(0);\n            th2->setCcr7Level(0);\n            th2->setBcellBindingStatus(true);\n\n            kill(activated_b_cell);\n            return;\n        }\n    }\n}\n"
      ],
      "412": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void World::tiResponse(std::shared_ptr<ActivatedBCell> activated_b_cell)  \n\nEntry Data: void World::tiResponse(std::shared_ptr<ActivatedBCell> activated_b_cell) {\n    bool print_test = false;\n    // Activated B-cells undergoing TI response secrete TNF-a\n    auto current_patch = get_patch(activated_b_cell->getX(), activated_b_cell->getY());\n    current_patch.setTnfA(current_patch.getTnfA() + 1);\n\n    if (activated_b_cell->getTimeAlive() % 70 == 0) {\n        double proPC = (current_patch.getIl21() + current_patch.getIl10() + current_patch.getIfA() + current_patch.getIfG()) * 10;\n        double proMem = 0;\n        if (proPC > proMem) {\n            // Create a new SL Plasma Cell and add it to the corresponding containers\n            auto new_sl_plasma_cell = std::make_shared<SLPlasmaCell>(activated_b_cell->getX(), activated_b_cell->getY(), global_ID_counter++);\n            new_sl_plasma_cell->copy_other_turtle_attributes(activated_b_cell);\n            new_sl_plasma_cell->setTimeAlive(0);\n            // Set color, shape, size, etc. as required\n            new_sl_plasma_cell->setColor('lime');\n            new_sl_plasma_cell->setShape('circle');\n            new_sl_plasma_cell->setSize(1);\n\n\n            std::weak_ptr<Turtle> new_sl_plasma_cell_weak_ptr = new_sl_plasma_cell;\n            all_turtles.push_back(new_sl_plasma_cell_weak_ptr);\n            all_sl_plasma_cells.push_back(new_sl_plasma_cell);\n            get_patch(new_sl_plasma_cell->getX(), new_sl_plasma_cell->getY()).add_turtle(new_sl_plasma_cell);\n            if(print_test){std::cout<<'final SL plasma cell use count '<<new_sl_plasma_cell.use_count()<<std::endl;}\n        } else {\n            if (step < 2800) {\n                // Create a new Memory B Cell and add it to the corresponding containers\n                auto new_mem_b_cell = std::make_shared<MemBCell>(activated_b_cell->getX(), activated_b_cell->getY(), global_ID_counter++);\n                new_mem_b_cell->copy_other_turtle_attributes(activated_b_cell);\n\n                new_mem_b_cell->setExposureNumber(1);\n                new_mem_b_cell->setTimeAlive(0);\n                // Set color, shape, size, etc. as required\n                new_mem_b_cell->setColor('pink');\n                new_mem_b_cell->setShape('target');\n                new_mem_b_cell->setSize(1);\n                new_mem_b_cell->setS1pr1Level(10);\n                new_mem_b_cell->setProBreg(0);\n                new_mem_b_cell->setCd21Level(0);\n                new_mem_b_cell->setCxcr5Level(10);\n\n                std::weak_ptr<Turtle> new_mem_b_cell_weak_ptr = new_mem_b_cell;\n                all_turtles.push_back(new_mem_b_cell_weak_ptr);\n                all_mem_b_cells.push_back(new_mem_b_cell);\n                get_patch(new_mem_b_cell->getX(), new_mem_b_cell->getY()).add_turtle(new_mem_b_cell);\n\n            } else {\n                // Create a new Memory B Cell and add it to the corresponding containers\n                auto new_mem_b_cell = std::make_shared<MemBCell>(activated_b_cell->getX(), activated_b_cell->getY(), global_ID_counter++);\n                new_mem_b_cell->copy_other_turtle_attributes(activated_b_cell);\n\n                new_mem_b_cell->setExposureNumber(2);\n                new_mem_b_cell->setTimeAlive(0);\n                // Set color, shape, size, etc. as required\n                new_mem_b_cell->setColor('pink');\n                new_mem_b_cell->setShape('target');\n                new_mem_b_cell->setSize(1);\n                new_mem_b_cell->setS1pr1Level(10);\n                new_mem_b_cell->setProBreg(0);\n                new_mem_b_cell->setCd21Level(0);\n                new_mem_b_cell->setCxcr5Level(10);\n\n                std::weak_ptr<Turtle> new_mem_b_cell_weak_ptr = new_mem_b_cell;\n                all_turtles.push_back(new_mem_b_cell_weak_ptr);\n                all_mem_b_cells.push_back(new_mem_b_cell);\n                get_patch(new_mem_b_cell->getX(), new_mem_b_cell->getY()).add_turtle(new_mem_b_cell);\n\n            }\n        }\n    }\n}\n"
      ],
      "413": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: Antibodies::Antibodies(int x, int y, int id, int heading) : Turtle(x, y, id, heading)  \n\nEntry Data: Antibodies::Antibodies(int x, int y, int id, int heading) : Turtle(x, y, id, heading) {\n    // Constructor\n    // std::cout<<'creating antibdy at '<<x<<', '<<y<<' with ID '<<id<<std::endl;\n}"
      ],
      "414": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void World::antibodiesFunction(std::shared_ptr<Antibodies> antibody)  \n\nEntry Data: void World::antibodiesFunction(std::shared_ptr<Antibodies> antibody) {\n  if (!antibody->get_is_alive()) {return;}\n\n    // Increase the time alive of the antibody\n    antibody->setTimeAlive(antibody->getTimeAlive() + 1);\n\n    // Check if the antibody has exceeded its lifespan\n    if (antibody->getTimeAlive() > 900) {\n        // If it has, kill the antibody\n        // std::cout<<'killing antibody at end of life. ID is '<<antibody->getID()<<std::endl;\n        kill(antibody);\n    }\n}"
      ],
      "415": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: Bacteria::Bacteria(int x, int y, int id, int heading) : Turtle(x, y, id, heading)  \n\nEntry Data: Bacteria::Bacteria(int x, int y, int id, int heading) : Turtle(x, y, id, heading) {\n    // Constructor\n    // std::cout<<'creating bacteria with ID '<<id<<std::endl;\n\n}"
      ],
      "416": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void World::bacteriaFunction(std::shared_ptr<Bacteria> bacteria)  \n\nEntry Data: void World::bacteriaFunction(std::shared_ptr<Bacteria> bacteria) {\n  bool print_test = false;\n  if (!bacteria->get_is_alive()) {return;}\n    Patch& current_patch = get_patch(bacteria->getX(), bacteria->getY());\n\n    // Check if the current patch type is 2\n    if (current_patch.getPatchType() == 2) {\n        int x = rand() % 2; // Randomly generate 0 or 1\n        if (x == 0) {\n            place_turtle(WORLD_WIDTH-2, std::ceil(WORLD_HEIGHT/2), bacteria);\n            bacteria->setS1pr1Level(0);\n        } else {\n            std::vector<std::shared_ptr<FDCs>> available_fdcs = get_fdcs_with_no_presented_antigen();\n\n            if (!available_fdcs.empty()) {\n                auto fdc = available_fdcs[RNG_Engine() % available_fdcs.size()];\n                fdc->setTimePresenting(0);\n                fdc->setPresentedAntigen(bacteria->getEpitopeType());\n                if (print_test){std::cout<<'BACTERIA SETTING FDC COLOR TO RED'<<std::endl;}\n                fdc->setColor('red');\n                int rTI = RNG_Engine() % bacteria->getNumTIep();\n                int rTD = RNG_Engine() % bacteria->getNumTDep();\n                if (rTI > rTD) {\n                    fdc->setPresentedAntigenType(1);\n                } else {\n                    fdc->setPresentedAntigenType(2);\n                }\n                if (print_test){std::cout<<'killing bacteria at end of life. ID is '<<bacteria->getID()<<std::endl;}\n                kill(bacteria);\n                return;\n            }\n        }\n    }\n\n    bacteria->setS1pr1Level(bacteria->getS1pr1Level() + 0.004);\n    chemotaxis(bacteria);\n    if (print_test){std::cout<<'Moving bacteria'<<std::endl;}\n    move_turtle(bacteria);\n}\n"
      ],
      "417": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: BregCell::BregCell(int x, int y, int id, int heading) : Turtle(x, y, id, heading)  \n\nEntry Data: BregCell::BregCell(int x, int y, int id, int heading) : Turtle(x, y, id, heading) {\n    // Constructor\n    // std::cout<<'Creating a breg cell with ID '<<id<<std::endl;\n}"
      ],
      "418": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void World::bregFunction(std::shared_ptr<BregCell> breg_cell)  \n\nEntry Data: void World::bregFunction(std::shared_ptr<BregCell> breg_cell) {\n  if (!breg_cell->get_is_alive()) {return;}\n\n    // std::cout<<'breg_function for ID number '<<breg_cell->getID()<<std::endl;\n\n    // Get the patch where the BReg cell is\n    Patch& breg_patch = get_patch(breg_cell->getX(), breg_cell->getY());\n\n    // Secretes the cytokines\n    breg_patch.setIl10(breg_patch.getIl10() + 5);\n    breg_patch.setTgfB(breg_patch.getTgfB() + 1);\n\n    // Chemotaxis and move\n    chemotaxis(breg_cell);\n    // std::cout<<'Moving breg'<<std::endl;\n    \n    move_turtle(breg_cell);\n\n    // Check TNF status\n    bool die_by_tnf = checkTNFStatus(breg_cell);\n\n    // Increase the time alive\n    breg_cell->setTimeAlive(breg_cell->getTimeAlive() + 1);\n\n    // Kill if the time alive exceeds 300\n    if((breg_cell->getTimeAlive() > 300)|| die_by_tnf) {\n      // std::cout<<'killing breg_cell at end of life. ID is '<<breg_cell->getID()<<std::endl;\n      kill(breg_cell);\n    }\n}\n"
      ],
      "419": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: FDCs::FDCs(int x, int y, int id, int heading) : Turtle(x, y, id, heading)  \n\nEntry Data: FDCs::FDCs(int x, int y, int id, int heading) : Turtle(x, y, id, heading) {\n    // Constructor\n    // std::cout<<'creating FDC with ID '<<id<<std::endl;\n\n}"
      ],
      "420": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void World::fdcFunction(std::shared_ptr<FDCs> fdc)  \n\nEntry Data: void World::fdcFunction(std::shared_ptr<FDCs> fdc) {\n  // std::cout<<'Doing FDC Function!'<<std::endl;\n    // Get the patch where the FDC is\n    Patch& fdc_patch = get_patch(fdc->getX(), fdc->getY());\n\n    // Secretes the cytokines\n    fdc_patch.setCxcl13Level(fdc_patch.getCxcl13Level() + 2);\n    fdc_patch.setIl4(fdc_patch.getIl4() + 1);\n    fdc_patch.setIl6(fdc_patch.getIl6() + 2);\n    fdc_patch.setIl15(fdc_patch.getIl15() + 2);\n    fdc_patch.setIl12(fdc_patch.getIl12() + 2);\n\n    // If FDC is presenting antigen, determines when it will stop presenting it\n    if(fdc->getPresentedAntigen() != 0) {\n        fdc->setTimePresenting(fdc->getTimePresenting() + 1);\n    }\n    if(fdc->getTimePresenting() == 300) {\n        // Stops presenting the antigen after 300 steps\n        fdc->setPresentedAntigen(0);\n        fdc->setColor('brown');\n        fdc->setPresentedAntigenType(0);\n        fdc->setTimePresenting(0);\n    }\n\n    // Calculate FDC responsiveness\n    fdc->calculate_responsiveness();\n}"
      ],
      "421": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void FDCs::calculate_responsiveness()  \n\nEntry Data: void FDCs::calculate_responsiveness() {\n    if(responsiveness > 0) {\n        responsiveness -= 0.01;\n    }\n}"
      ],
      "422": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: GCBCell::GCBCell(int x, int y, int id, int heading) : Turtle(x, y, id, heading)  \n\nEntry Data: GCBCell::GCBCell(int x, int y, int id, int heading) : Turtle(x, y, id, heading) {\n    // Constructor\n    // std::cout<<'creating GCBcell with ID '<<id<<std::endl;\n\n}"
      ],
      "423": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void World::gc_b_cell_function(std::shared_ptr<GCBCell> gc_b_cell)  \n\nEntry Data: void World::gc_b_cell_function(std::shared_ptr<GCBCell> gc_b_cell) {\n  if (!gc_b_cell->get_is_alive()) {return;}\n  bool print_test = false;\n  if (print_test){std::cout<<'doing GCB cell function for cell '<<gc_b_cell->getID()<<std::endl;}\n\n    if(!gc_b_cell->getInBlood()) {\n      // std::cout<<'doing GCB cell function for cell not in blood '<<gc_b_cell->getID()<<std::endl;\n      // std::cout<<'location is '<<gc_b_cell->getX()<<', '<<gc_b_cell->getY()<<std::endl;\n        Patch& current_patch = get_patch(gc_b_cell->getX(), gc_b_cell->getY());\n\n        if(current_patch.getPatchType() == 2) {\n            gc_b_cell->setInBlood(true);\n            gc_b_cell->setVisible(false);\n        }\n\n        // Downregulates ebi2r and ccr7 so it can localize to follicle center again\n        gc_b_cell->setEbi2rLevel(0);\n        gc_b_cell->setCcr7Level(0);\n\n        // The GC B-cell only moves if it has not yet reached the follicle center\n        if(calculateDistance(WORLD_WIDTH/2, WORLD_HEIGHT/2, gc_b_cell->getX(), gc_b_cell->getY()) > 15) {\n          if (print_test){std::cout<<'doing GCB cell function for large distance to center  '<<gc_b_cell->getID()<<std::endl;}\n          if (print_test){std::cout<<'location is '<<gc_b_cell->getX()<<', '<<gc_b_cell->getY()<<std::endl;}\n            chemotaxis(gc_b_cell);\n            if (print_test){std::cout<<'Moving gcb'<<std::endl;}\n\n            move_turtle(gc_b_cell, 0.5);\n            if (print_test){std::cout<<'gcb moved'<<std::endl;}\n\n            // gc_b_cell->gc_move();\n        } else {\n          if (print_test){std::cout<<'DISTANCE OF GC B CELL TO CENTER IS < 15 SO DOING ELSE PART OF GCB CELL FUNCTION'<<std::endl;}\n\n            double proPC2 = current_patch.getIl21() + current_patch.getIl10() * 2 + current_patch.getIfA() + current_patch.getIfG();\n            if (print_test){std::cout<<'got proPC2'<<std::endl;}\n            double proMem2 = current_patch.getIl21() + current_patch.getIl4();\n            if (print_test){std::cout<<'got proMem2'<<std::endl;}\n            double proPC = fmod(RNG_Engine(), proPC2);\n            if (print_test){std::cout<<'got proPC'<<std::endl;}\n            double proMem = fmod(RNG_Engine(), proMem2);\n            if (print_test){std::cout<<'got proMem'<<std::endl;}\n\n            if(gc_b_cell->getTimeAlive() % 80 == 0) {\n                if(proPC > proMem) {\n                    auto plasma_cell = std::make_shared<LLPlasmaCell>(gc_b_cell->getX(), gc_b_cell->getY(), global_ID_counter++, gc_b_cell->getHeading());\n                    plasma_cell->copy_other_turtle_attributes(gc_b_cell);\n                    plasma_cell->setExposureNumber(step < 2800 ? 1 : 2);\n                    plasma_cell->setTimeAlive(0);\n                    plasma_cell->setColor('lime');\n                    plasma_cell->setShape('circle');\n                    plasma_cell->setSize(1);\n                    plasma_cell->setS1pr1Level(40);\n                    plasma_cell->setProBreg(0);\n                    plasma_cell->setTnfaThreshold(plasma_cell->getTnfaThreshold() - 130);\n                    std::weak_ptr<Turtle> plasma_cell_weak_ptr = plasma_cell;\n                    all_turtles.push_back(plasma_cell_weak_ptr);\n                    all_ll_plasma_cells.push_back(plasma_cell);\n                    get_patch(plasma_cell->getX(), plasma_cell->getY()).add_turtle(plasma_cell);\n\n                } else {\n                    auto mem_b_cell = std::make_shared<MemBCell>(gc_b_cell->getX(), gc_b_cell->getY(), global_ID_counter++, gc_b_cell->getHeading());\n                    mem_b_cell->copy_other_turtle_attributes(gc_b_cell);\n                    mem_b_cell->setExposureNumber(step < 2800 ? 1 : 2);\n                    mem_b_cell->setTimeAlive(0);\n                    mem_b_cell->setColor('pink');\n                    mem_b_cell->setShape('target');\n                    mem_b_cell->setS1pr1Level(10);\n                    mem_b_cell->setProBreg(0);\n                    mem_b_cell->setCd21Level(0);\n                    mem_b_cell->setCxcr5Level(10);\n\n                    std::weak_ptr<Turtle> mem_b_cell_weak_ptr = mem_b_cell;\n                    all_turtles.push_back(mem_b_cell_weak_ptr);\n                    all_mem_b_cells.push_back(mem_b_cell);\n                    get_patch(mem_b_cell->getX(), mem_b_cell->getY()).add_turtle(mem_b_cell);\n                }\n            }\n        }\n\n        //check_breg_status(gc_b_cell);\n    }\n    if (print_test){std::cout<<'gcb function part 2'<<std::endl;}\n\n    bool die_by_tnf = checkTNFStatus(gc_b_cell);\n\n    gc_b_cell->setTimeAlive(gc_b_cell->getTimeAlive() + 1);\n    if (print_test){std::cout<<'gcb time alive'<<std::endl;}\n    if((gc_b_cell->getTimeAlive() > 700) || die_by_tnf) {\n      if (print_test){std::cout<<'gcb unbinding neighbor'<<std::endl;}\n      if (print_test){std::cout<<'linkedTurtles: '<<gc_b_cell->getLinkedTurtles().size()<<std::endl;}\n\n        for(auto neighbor : gc_b_cell->getLinkedTurtles()) {\n          if (std::shared_ptr<TfhCell> cell_to_unbind = std::dynamic_pointer_cast<TfhCell>(neighbor.lock())){\n            cell_to_unbind->setBcellBindingStatus(false);\n            if (print_test){std::cout<<'gcb neighbor unbound'<<std::endl;}\n\n          } else if (std::shared_ptr<Th2Cell> cell_to_unbind = std::dynamic_pointer_cast<Th2Cell>(neighbor.lock())){\n            cell_to_unbind->setBcellBindingStatus(false);\n            if (print_test){std::cout<<'gcb neighbor unbound'<<std::endl;}\n\n          }\n        }\n        if (print_test){std::cout<<'killing gdb'<<std::endl;}\n        kill(gc_b_cell);\n        if (print_test){std::cout<<'killing dead'<<std::endl;}\n\n    }\n}"
      ],
      "424": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: // Function to calculate Euclidean distance between two points\ndouble calculateDistance(int x1, int y1, int x2, int y2)  \n\nEntry Data: // Function to calculate Euclidean distance between two points\ndouble calculateDistance(int x1, int y1, int x2, int y2) {\n    double dx = x2 - x1;\n    double dy = y2 - y1;\n    return std::sqrt(dx * dx + dy * dy);\n}"
      ],
      "425": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: // Function to generate coordinates within a radius without buffer zone\nstd::vector<std::pair<int, int>> generateCoordinates(int number_to_generate, int center_x, int center_y, int radius_from_center, int buffer_zone_between_points)  \n\nEntry Data: // Function to generate coordinates within a radius without buffer zone\nstd::vector<std::pair<int, int>> generateCoordinates(int number_to_generate, int center_x, int center_y, int radius_from_center, int buffer_zone_between_points) {\n  std::size_t n = number_to_generate;\n  int x = center_x;\n  int y = center_y;\n  int r = radius_from_center;\n  int b = buffer_zone_between_points;\n  \n    std::vector<std::pair<int, int>> coordinates;\n\n    // Generate random coordinates within the radius\n    while (coordinates.size() < n) {\n        int newX = std::rand() % (2 * r + 1) + (x - r);\n        int newY = std::rand() % (2 * r + 1) + (y - r);\n        \n        bool isValid = true;\n        if (calculateDistance(newX, newY, x, y) > r){isValid=false;}\n        for (const auto& coord : coordinates) {\n            // Check if the new coordinate is within the buffer zone\n            if (!isValid){break;}\n            if (calculateDistance(newX, newY, coord.first, coord.second) <= b) {\n                isValid = false;\n            }\n        }\n\n        if (isValid) {\n            coordinates.emplace_back(newX, newY);\n        }\n    }\n\n    return coordinates;\n}\n"
      ],
      "426": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: LLPlasmaCell::LLPlasmaCell(int x, int y, int id, int heading) : Turtle(x, y, id, heading)  \n\nEntry Data: LLPlasmaCell::LLPlasmaCell(int x, int y, int id, int heading) : Turtle(x, y, id, heading) {\n    // Constructor\n    // std::cout<<'creating LL Plasma cell'<<std::endl;\n\n}"
      ],
      "427": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: int main(int argc, char const *argv[])  \n\nEntry Data: int main(int argc, char const *argv[]) {\n  std::cout<<'starting main'<<std::endl;\n  World world = World();\n  World* worldptr = &world; // pointer to give to rendering engine\n  RenderingEngine engine;\n  // setting up world\n  world.setup();\n  // world.injure_sterile(INJURY_NUMBER);\n  world.updateTurtleVectors();\n\n  // setting up rendering engine\n  if (RENDERING){\n    engine.~RenderingEngine();\n    new (&engine) RenderingEngine(worldptr);\n  }\n  bool quit=false;\n  bool paused=false;\n  SDL_Event event;\n\n\n  auto startTime = std::chrono::high_resolution_clock::now();\n  // main loop\n  std::cout<<'STARTING GO'<<std::endl;\n  for (size_t i = 0; i < NUM_STEPS; i++) {\n    if (i%100==0){\n      std::cout<<'#######################################################\n Beginning Step Number ' <<i<<'\n#######################################################'<<std::endl;\n    }\n    if (!paused){\n      world.go();\n    }\n\n    // rendering loop\n    if (RENDERING){\n      engine.setBackgroundColor('black');\n      engine.renderAllPatches();\n      engine.renderPatchMode();\n      engine.renderAllTurtles();\n      engine.render();\n      while (SDL_PollEvent(&event)) {\n           if (event.type == SDL_QUIT) {\n               quit = true;\n           }\n           if (event.type == SDL_KEYDOWN && event.key.keysym.sym == SDLK_SPACE) {\n               paused = !paused; // Toggle pause state\n           }\n       }\n\n       if (quit) {\n           break;\n       }\n\n       // While paused, keep checking for events and only proceed if space is pressed again\n       while (paused) {\n           while (SDL_PollEvent(&event)) {\n               if (event.type == SDL_QUIT) {\n                   quit = true;\n                   paused = false;\n               }\n               if (event.type == SDL_KEYDOWN && event.key.keysym.sym == SDLK_SPACE) {\n                   paused = !paused; // Toggle pause state\n               }\n           }\n           std::this_thread::sleep_for(std::chrono::milliseconds(10)); // Sleep for a short duration to avoid busy-waiting\n       }\n       std::this_thread::sleep_for(std::chrono::milliseconds(50));\n   }\n\n\n  }\n  auto endTime = std::chrono::high_resolution_clock::now();\n  auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime);\n  std::cout << 'Program duration: ' << duration.count() << ' milliseconds' << std::endl;\n\n  return 0;\n}"
      ],
      "428": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: MemBCell::MemBCell(int x, int y, int id, int heading) : Turtle(x, y, id, heading)  \n\nEntry Data: MemBCell::MemBCell(int x, int y, int id, int heading) : Turtle(x, y, id, heading) {\n    // Constructor\n    // std::cout<<'creating memory B cell ID '<<id<<' at x,y '<<x<<', '<<y<<std::endl;\n\n}"
      ],
      "429": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void World::memBCellFunction(std::shared_ptr<MemBCell> mem_b_cell)  \n\nEntry Data: void World::memBCellFunction(std::shared_ptr<MemBCell> mem_b_cell) {\n  if (!mem_b_cell->get_is_alive()) {return;}\n  bool print_test = false;\n  if (print_test){std::cout<<'memory_b_cellfunction for ID number '<<mem_b_cell->getID()<<std::endl;}\n  if (print_test){std::cout<<'memory_b_cellfunction location '<<mem_b_cell->getX()<<', '<<mem_b_cell->getY()<<std::endl;}\n\n  // Get the current patch of the Memory B cell\n  Patch& current_patch = get_patch(mem_b_cell->getX(), mem_b_cell->getY());\n\n  // Calculate CD21 expression based on il6 and il10 levels in the current patch\n  int cd21_level = 300 - (current_patch.getIl6() * 50 + current_patch.getIl10() * 0);\n  mem_b_cell->setCd21Level(cd21_level);\n\n  // If the memory B cell is in the follicle\n  if(current_patch.getPatchType() == 2) {\n    place_turtle(WORLD_WIDTH, std::ceil(WORLD_HEIGHT/2), mem_b_cell);\n    mem_b_cell->setProBreg(0);\n    mem_b_cell->setS1pr1Level(0);\n    mem_b_cell->setTimeInFollicle(0);\n  }\n\n  mem_b_cell->setTimeInFollicle(mem_b_cell->getTimeInFollicle() + 1);\n  if(mem_b_cell->getTimeInFollicle() > 300) {\n    mem_b_cell->setS1pr1Level(mem_b_cell->getS1pr1Level() + 0.5);\n  }\n\n  mem_b_cell->setTimeAlive(mem_b_cell->getTimeAlive() + 1);\n  if(mem_b_cell->getTimeAlive() > 15000) {\n    if (print_test){std::cout<<'Killing mem_b_cell for age '<<mem_b_cell->getID()<<'. use count:'<<mem_b_cell.use_count()<<std::endl;}\n\n    kill(mem_b_cell);\n    return;\n  }\n\n  auto apc = getOneFDCHere(mem_b_cell->getX(), mem_b_cell->getY());\n  int random_encounter = RNG_Engine() % 100;\n  auto antigen = getOneBacteriaHere(mem_b_cell->getX(), mem_b_cell->getY());\n\n  if((apc != nullptr && apc->getPresentedAntigen() != 0 && apc->getResponsiveness() > random_encounter) || antigen != nullptr){\n    if(mem_b_cell->getCd21Level() > BCELL_CD21_ACTIVATION_THRESHOLD){\n\n      auto new_activated_b_cell = std::make_shared<ActivatedBCell>(mem_b_cell->getX(), mem_b_cell->getY(), global_ID_counter++, mem_b_cell->getHeading());\n      new_activated_b_cell->copy_other_turtle_attributes(mem_b_cell);\n      current_patch.setIl6(current_patch.getIl6() + PHAG_IL6_BURST);\n      new_activated_b_cell->setProBreg(0);\n      new_activated_b_cell->setShape('target');\n      new_activated_b_cell->setSize(1);\n      new_activated_b_cell->setColor('cyan');\n      new_activated_b_cell->setCsrBool(false);\n      new_activated_b_cell->setTimeAlive(100);\n\n\n      int rTI = RNG_Engine() % 100;\n      int rTD = RNG_Engine() % 100;\n      if(antigen != nullptr){\n\n        if(rTI > rTD){\n          new_activated_b_cell->setResponseType(1); // TI response\n        } else{\n          new_activated_b_cell->setResponseType(2); // TD response\n          new_activated_b_cell->setCcr7Level(12);\n          new_activated_b_cell->setEbi2rLevel(12);\n        }\n        if (print_test){std::cout<<'Killing antigen in memory_b_cell function '<<antigen->getID()<<'. use count:'<<antigen.use_count()<<std::endl;}\n        kill(antigen);\n      }\n      else if (apc != nullptr){\n        if(rTI > rTD){\n            new_activated_b_cell->setResponseType(1); // TI response\n        }\n        else{\n            new_activated_b_cell->setResponseType(2); // TD response\n            new_activated_b_cell->setCcr7Level(12);\n            new_activated_b_cell->setEbi2rLevel(12);\n        }\n      }\n\n      std::weak_ptr<Turtle> new_activated_b_cell_weak_ptr = new_activated_b_cell;\n      all_turtles.push_back(new_activated_b_cell_weak_ptr);\n      all_activated_b_cells.push_back(new_activated_b_cell);\n      get_patch(new_activated_b_cell->getX(), new_activated_b_cell->getY()).add_turtle(new_activated_b_cell);\n\n      kill(mem_b_cell); // kill old memory b cell because its not an activated b cell\n      return;\n      // std::shared_ptr<ActivatedBCell> mem_b_cell = new_activated_b_cell;  //renaming mem_b_cell so rest of the function still works on the new cell\n    }\n  }\n  // Checks level of stimulation of b-reg differentiation\n  bool turn_into_breg = checkBregStatus(mem_b_cell);\n  if (turn_into_breg){\n    if (print_test){std::cout<<'Mem B ID '<<mem_b_cell->getID()<<'turning into Breg'<<std::endl;}\n    std::shared_ptr<BregCell> mem_b_cell = turnIntoBreg(mem_b_cell);\n  };\n\n  chemotaxis(mem_b_cell);\n  if (print_test){std::cout<<'Moving mem_b cell'<<std::endl;}\n\n  move_turtle(mem_b_cell);\n\n\n  // Checks level of TNF-a stimulation for apoptosis\n  if(checkTNFStatus(mem_b_cell)){kill(mem_b_cell);};\n}"
      ],
      "430": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: NaiveBCell::NaiveBCell(int x, int y, int id, int heading) : Turtle(x, y, id, heading)  \n\nEntry Data: NaiveBCell::NaiveBCell(int x, int y, int id, int heading) : Turtle(x, y, id, heading) {\n    // Constructor\n    // std::cout<<'creating naive B cell with ID '<<id<<std::endl;\n\n}"
      ],
      "431": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void World::spawnBCell()  \n\nEntry Data: void World::spawnBCell() {\n  bool print_test = false;\n  if(step % 10 == 0) {\n    // std::cout<<'SPAWNING B CELL'<<std::endl;\n      // Position of the new Naive B-cell\n      int cell_x = WORLD_WIDTH -2; //I added std::floor()\n      int cell_y = std::floor(WORLD_HEIGHT / 2);\n\n      // Create a new Naive B-cell\n      auto b_cell = std::make_shared<NaiveBCell>(cell_x, cell_y, global_ID_counter++, 180);\n      if (print_test){std::cout<< 'NaiveBCell use count after creation  '<<b_cell.use_count()<<std::endl;}\n\n      std::weak_ptr<Turtle> b_cell_weak_ptr = b_cell;\n      if (print_test){std::cout<< 'NaiveBCell use count after weap tr  '<<b_cell.use_count()<<std::endl;}\n\n      // Set the properties of the new Naive B-cell\n      b_cell->setShape('circle');\n      b_cell->setColor('white');\n      b_cell->setSize(1);\n      b_cell->setTimeAlive(0);\n      b_cell->setBcr(RNG_Engine() % 30);\n      b_cell->setIsotype('md');\n      b_cell->setS1pr1Level(0);\n      b_cell->setS1pr2Level(0);\n      b_cell->setCxcr5Level(16);\n      b_cell->setCcr7Level(0);\n      b_cell->setEbi2rLevel(0);\n      b_cell->setCd21Level(0);\n      b_cell->setInBlood(false);\n\n      // Set thresholds\n      b_cell->setTnfaThreshold(BCELL_TNFA_APOP_THRESHOLD + (RNG_Engine() % 50));\n      b_cell->setBregThreshold(BCELL_BREG_DIFF_THRESHOLD + (RNG_Engine() % 50));\n\n      // Add the new Naive B-cell to the list\n      all_naive_b_cells.push_back(b_cell);\n      if (print_test){std::cout<< 'NaiveBCell use count after all cells pushback  '<<b_cell.use_count()<<std::endl;}\n\n      all_turtles.push_back(b_cell_weak_ptr);\n      if (print_test){std::cout<< 'NaiveBCell use count after all turtles pushback  '<<b_cell.use_count()<<std::endl;}\n\n      get_patch(b_cell->getX(), b_cell->getY()).add_turtle(b_cell);\n      if (print_test){std::cout<< 'NaiveBCell use count after all patch add  '<<b_cell.use_count()<<std::endl;}\n\n  }\n}"
      ],
      "432": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void World::naiveBCellFunction(std::shared_ptr<NaiveBCell> naive_b_cell)  \n\nEntry Data: void World::naiveBCellFunction(std::shared_ptr<NaiveBCell> naive_b_cell) {\n  if (!naive_b_cell->get_is_alive()) {return;}\n\n  bool print_test = false;\n  // std::cout<<'naive_b_cellfunction for ID number '<<naive_b_cell->getID()<<'Ebi2rLevel '<<naive_b_cell->getEbi2rLevel()<<std::endl;\n  // Get the current patch of the naive B cell\n  Patch& current_patch = get_patch(naive_b_cell->getX(), naive_b_cell->getY());\n\n  // Calculate CD21 expression based on il6 and il10 levels in the current patch\n  int cd21_level = 300 - (current_patch.getIl6() * 50 + current_patch.getIl10() * 0);\n  // std::cout<<'setting cd21 level to be '<<cd21_level<<' for cell with ID '<<naive_b_cell->getID()<<std::endl;\n  naive_b_cell->setCd21Level(cd21_level);\n\n  // If naive B cell is in the follicle, it dies\n  if (current_patch.getPatchType() == 2) {\n    // std::cout<<'killing naive Bcell on follicle exit '<<naive_b_cell->getID()<<std::endl;\n    // std::cout<<'naive_b_cell use count is '<<naive_b_cell.use_count()<<std::endl;\n    kill(naive_b_cell);\n    return;\n  }\n  auto apc = getOneFDCHere(naive_b_cell->getX(), naive_b_cell->getY());\n  int random_encounter = RNG_Engine() % 100;\n  auto antigen = getOneBacteriaHere(naive_b_cell->getX(), naive_b_cell->getY());\n\n  if ((apc != nullptr && apc->getPresentedAntigen() != 0 && apc->getResponsiveness() > random_encounter) || antigen != nullptr){\n    if (print_test){std::cout<<'STEPPING INTO NAIVE_B_CELL FUNCTION. ID is '<<naive_b_cell->getID()<<std::endl;}\n    if(naive_b_cell->getCd21Level() > BCELL_CD21_ACTIVATION_THRESHOLD){\n      if(print_test){std::cout<<'becoming activated B_cell'<<std::endl;}\n      // creating a new activated_b_cell\n      // std::cout<<'Before turning into activated b cell, original naive_b_cell use count is '<<naive_b_cell.use_count()<<std::endl;\n\n      auto new_activated_b_cell = std::make_shared<ActivatedBCell>(naive_b_cell->getX(), naive_b_cell->getY(), global_ID_counter++, naive_b_cell->getHeading());\n      if (print_test){std::cout<< 'new_activated_b_cell use count upon creation '<<new_activated_b_cell.use_count()<<std::endl;}\n      new_activated_b_cell->copy_other_turtle_attributes(naive_b_cell);\n      if (print_test){std::cout<< 'new_activated_b_cell use count after copy  '<<new_activated_b_cell.use_count()<<std::endl;}\n\n      // std::cout<<'After creeating but before turning into activated b cell, original naive_b_cell use count is '<<naive_b_cell.use_count()<<std::endl;\n      \n      current_patch.setIl6(current_patch.getIl6() + PHAG_IL6_BURST);\n      new_activated_b_cell->setProBreg(0);\n      new_activated_b_cell->setShape('target');\n      new_activated_b_cell->setSize(1);\n      new_activated_b_cell->setColor('red');\n      new_activated_b_cell->setCsrBool(false);\n      new_activated_b_cell->setTimeAlive(0);\n\n      if (print_test){std::cout<<'location of mew activated_b_Cell is '<<new_activated_b_cell->getX()<<', '<<new_activated_b_cell->getY()<<std::endl;}\n\n      int rTI = RNG_Engine() % 100;\n      int rTD = RNG_Engine() % 100;\n\n      if(antigen != nullptr){\n        if(rTI > rTD){\n          new_activated_b_cell->setResponseType(1); // TI response\n        } else{\n          new_activated_b_cell->setResponseType(2); // TD response\n          new_activated_b_cell->setCcr7Level(12);\n          new_activated_b_cell->setEbi2rLevel(12);\n        }\n        if (print_test){std::cout<<'Killing antigen in naive_b_cell function '<<antigen->getID()<<'. use count:'<<antigen.use_count()<<std::endl;}\n\n        kill(antigen);\n      }\n      else if (apc != nullptr){\n        if(rTI > rTD){\n            new_activated_b_cell->setResponseType(1); // TI response\n        }\n        else{\n            new_activated_b_cell->setResponseType(2); // TD response\n            new_activated_b_cell->setCcr7Level(12);\n            new_activated_b_cell->setEbi2rLevel(12);\n        }\n      }\n\n\n      std::weak_ptr<Turtle> new_activated_b_cell_weak_ptr = new_activated_b_cell;\n      if (print_test){std::cout<< 'new_activated_b_cell use count after weak ptr  '<<new_activated_b_cell.use_count()<<std::endl;}\n\n      all_activated_b_cells.push_back(new_activated_b_cell);\n      if (print_test){std::cout<< 'new_activated_b_cell use count after all_activated_b_cells pushback '<<new_activated_b_cell.use_count()<<std::endl;}\n      all_turtles.push_back(new_activated_b_cell_weak_ptr);\n      if (print_test){std::cout<< 'new_activated_b_cell use count after turtles pushback  '<<new_activated_b_cell.use_count()<<std::endl;}\n      \n      get_patch(new_activated_b_cell->getX(), new_activated_b_cell->getY()).add_turtle(new_activated_b_cell);\n      // current_patch.add_turtle(new_activated_b_cell);\n      if (print_test){std::cout<< 'new_activated_b_cell use count after patch add  '<<new_activated_b_cell.use_count()<<std::endl;}\n      // std::cout<<'After turning into activated b cell, original naive_b_cell use count is '<<naive_b_cell.use_count()<<std::endl;\n      // std::cout<<'After turning into activated b cell, original naive_b_cell ID is '<<naive_b_cell->getID()<<std::endl;\n      kill(naive_b_cell);\n\n      // std::shared_ptr<ActivatedBCell> naive_b_cell = new_activated_b_cell; // renaming naive_b_Cell so the rest of the function still works as expected\n      // std::cout<< 'new_activated_b_cell use count after rename  '<<new_activated_b_cell.use_count()<<std::endl;\n\n      return;\n    }\n  }\n\n\n  // if(print_test){std::cout<<'chomtaxin naive_b_cell'<<std::endl;}\n  // std::cout<< 'naive_b_cell use count before chemotaxis '<<naive_b_cell.use_count()<<std::endl;\n\n  chemotaxis(naive_b_cell);\n  // std::cout<< 'naive_b_cell use count after chemotaxis '<<naive_b_cell.use_count()<<std::endl;\n  // std::cout<<'Moving b_cell'<<std::endl;\n\n  move_turtle(naive_b_cell);\n  // std::cout<< 'naive_b_cell use count after move turtle '<<naive_b_cell.use_count()<<std::endl;\n\n  // Checks level of stimulation of b-reg differentiation\n  bool turn_into_breg = checkBregStatus(naive_b_cell);\n  if (turn_into_breg){\n    if (print_test){std::cout<<'naive_b cell ID '<<naive_b_cell->getID()<<'turning into Breg'<<std::endl;}\n    // cant do it like below, leads to weird error where orignal cell is overwritten in templated turnIntoBreg function.\n    // std::shared_ptr<BregCell> naive_b_cell = turnIntoBreg(naive_b_cell);\n    // need to do it like this instead\n    std::shared_ptr<BregCell> output_b_cell = turnIntoBreg(naive_b_cell);\n    std::shared_ptr<BregCell> naive_b_Cell;\n    naive_b_Cell = output_b_cell;\n  };\n\n  // Checks level of TNF-a stimulation for apoptosis\n  bool die_by_tnf = checkTNFStatus(naive_b_cell);\n\n  // this slowly increases the # of s1p receptors (s1pr) in the naive b cell when the b-cell is old enough\n  if(naive_b_cell->getTimeAlive() > 300)\n  {\n      naive_b_cell->setS1pr1Level(naive_b_cell->getS1pr1Level() + 0.5);\n  }\n\n  naive_b_cell->setTimeAlive(naive_b_cell->getTimeAlive() + 1);\n\n  // Checks if the cell has lived beyond its maximum lifespan, if so, it will be removed\n  if((naive_b_cell->getTimeAlive() > 1000) || die_by_tnf ) {\n      kill(naive_b_cell);\n  }\n\n\n}"
      ],
      "433": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void Patch::add_turtle(std::shared_ptr<Turtle> turtle_to_add) \n\nEntry Data: void Patch::add_turtle(std::shared_ptr<Turtle> turtle_to_add){\n  turtles_here.emplace_back(turtle_to_add);\n}"
      ],
      "434": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void Patch::remove_turtle(std::shared_ptr<Turtle> turtle_to_remove) \n\nEntry Data: void Patch::remove_turtle(std::shared_ptr<Turtle> turtle_to_remove){\n  turtles_here.erase(std::remove(turtles_here.begin(), turtles_here.end(), turtle_to_remove), turtles_here.end());\n  turtle_to_remove.reset();\n}"
      ],
      "435": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void Patch::display()  \n\nEntry Data: void Patch::display() {\n    std::cout << 'Patch position: (' << this->getX() << ', ' << getY() << ')' << std::endl;\n    // std::cout << 'Patch color: ' << color << std::endl;\n    if (turtles_here.size() > 0){\n      for (auto &turtle: turtles_here){\n        turtle->display();\n      }\n    }\n}"
      ],
      "436": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: bool Patch::is_at_capacity() \n\nEntry Data: bool Patch::is_at_capacity(){\n  return (turtles_here.size() >= PATCH_MAX_CAPACITY);\n}"
      ],
      "437": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: RenderingEngine::RenderingEngine() \n\nEntry Data: RenderingEngine::RenderingEngine(){\n  std::cout<<'calling default Constructor'<<std::endl;\n\n  // SDL_Init(SDL_INIT_VIDEO);\n  // window = SDL_CreateWindow('SDL Window', SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, SCREEN_WIDTH, SCREEN_HEIGHT, SDL_WINDOW_SHOWN);\n  // renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);\n  // SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_BLEND);\n  // SDL_RenderClear(renderer);\n}"
      ],
      "438": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: RenderingEngine::RenderingEngine(World *world) \n\nEntry Data: RenderingEngine::RenderingEngine(World *world){\n  std::cout<<'calling world Constructor'<<std::endl;\n  myWorld = world;\n  SDL_Init(SDL_INIT_VIDEO);\n  window = SDL_CreateWindow('SDL Window', SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, SCREEN_WIDTH, SCREEN_HEIGHT, SDL_WINDOW_SHOWN);\n  renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);\n  SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_BLEND);\n  SDL_RenderClear(renderer);\n}"
      ],
      "439": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: RenderingEngine::~RenderingEngine() \n\nEntry Data: RenderingEngine::~RenderingEngine(){\n  SDL_DestroyRenderer(renderer);\n  SDL_DestroyWindow(window);\n  SDL_Quit();\n}"
      ],
      "440": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: std::tuple<int, int, int> RenderingEngine::getColor(const std::string& color) \n\nEntry Data: std::tuple<int, int, int> RenderingEngine::getColor(const std::string& color){\n  int red, green, blue;\n  if (color == 'red') {\n      red = 255;\n      green = 0;\n      blue = 0;\n  }\n  else if (color == 'green') {\n      red = 0;\n      green = 255;\n      blue = 0;\n  }\n  else if (color == 'cyan') {\n    red = 0;\n    green = 255;\n    blue = 255;\n  }\n  else if (color == 'blue') {\n      red = 0;\n      green = 0;\n      blue = 255;\n  }\n  else if (color =='black'){\n    red = 0;\n    green = 0;\n    blue = 0;\n  }\n  else if (color == 'white'){\n    red = 255;\n    green = 255;\n    blue = 255;\n  }\n  else if (color == 'yellow'){\n    red = 255;\n    green = 255;\n    blue = 0;\n  }\n  else if (color == 'violet'){\n    red = 127;\n    green = 0;\n    blue = 255;\n  }\n  else if (color =='brown'){\n    red = 85;\n    green = 42;\n    blue = 42;\n  }\n  else if (color == 'orange'){\n    red = 255;\n    green = 95;\n    blue = 31;\n  }\n  else if (color == 'grey' || color =='gray'){\n    red = 128;\n    green = 128;\n    blue = 128;\n  }\n  else if (color =='pink'){\n    red = 255;\n    green = 16;\n    blue = 240;\n  }\n  else if (color =='lime'){\n    red = 50;\n    green = 205;\n    blue = 50;\n  }\n  \n  else if (color == 'mauve'){\n    red = 172;\n    blue = 79;\n    green = 106;\n  }\n\n\n  else {\n    std::cout<<'using OTHER color'<<std::endl;\n    std::cout<<'color is '<<color<<std::endl;\n    \n      red = 255;\n      green = 16;\n      blue = 240;\n  }\n  return std::make_tuple(red, green, blue);\n}"
      ],
      "441": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void RenderingEngine::render() \n\nEntry Data: void RenderingEngine::render(){\n  SDL_RenderPresent(renderer);\n}"
      ],
      "442": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void RenderingEngine::setBackgroundColor(const std::string& color) \n\nEntry Data: void RenderingEngine::setBackgroundColor(const std::string& color){\n  std::tuple<int, int, int> RGB = getColor(color);\n    SDL_SetRenderDrawColor(renderer, std::get<0>(RGB), std::get<1>(RGB), std::get<2>(RGB), SDL_ALPHA_OPAQUE);\n    SDL_RenderClear(renderer);\n    // SDL_RenderPresent(renderer);\n}"
      ],
      "443": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void RenderingEngine::drawLine(double startX, double startY, double endX, double endY, const std::string& color, int alpha) \n\nEntry Data: void RenderingEngine::drawLine(double startX, double startY, double endX, double endY, const std::string& color, int alpha){\n  std::tuple<int, int, int> RGB = getColor(color);\n  SDL_SetRenderDrawColor(renderer, std::get<0>(RGB), std::get<1>(RGB), std::get<2>(RGB), alpha);\n  SDL_RenderDrawLine(renderer, startX, startY, endX, endY);\n  // SDL_RenderPresent(renderer);\n}"
      ],
      "444": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void RenderingEngine::drawCircle(double centerX, double centerY, double radius, const std::string& color, int alpha) \n\nEntry Data: void RenderingEngine::drawCircle(double centerX, double centerY, double radius, const std::string& color, int alpha){\n  centerX += GRID_SIZE/2;\n  centerY += GRID_SIZE/2;\n  std::tuple<int, int, int> RGB = getColor(color);\n  SDL_SetRenderDrawColor(renderer, std::get<0>(RGB), std::get<1>(RGB), std::get<2>(RGB), alpha);\n\n\tfor (int y = -radius; y <= radius; y++) {\n\t    for (int x = -radius; x <= radius; x++) {\n\t        if (x*x + y*y <= radius*radius) {\n\t            SDL_RenderDrawPoint(renderer, centerX + x, centerY + y);\n\t        }\n\t    }\n\t}\n\t// SDL_RenderPresent(renderer);\n}"
      ],
      "445": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void RenderingEngine::drawSquare(int x, int y, int size, const std::string& color, int alpha)  \n\nEntry Data: void RenderingEngine::drawSquare(int x, int y, int size, const std::string& color, int alpha) {\n  std::tuple<int, int, int> RGB = getColor(color);\n  SDL_SetRenderDrawColor(renderer, std::get<0>(RGB), std::get<1>(RGB), std::get<2>(RGB), alpha);\n  SDL_Rect rect = { x, y, size, size };\n  SDL_RenderFillRect(renderer, &rect);\n  // SDL_RenderPresent(renderer);\n}"
      ],
      "446": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void RenderingEngine::drawFilledEllipse(int centerX, int centerY, int radiusX, int radiusY, const std::string& color, int alpha, int angleDegrees)  \n\nEntry Data: void RenderingEngine::drawFilledEllipse(int centerX, int centerY, int radiusX, int radiusY, const std::string& color, int alpha, int angleDegrees) {\n    std::tuple<int, int, int> RGB = getColor(color);\n    SDL_SetRenderDrawColor(renderer, std::get<0>(RGB), std::get<1>(RGB), std::get<2>(RGB), alpha);\n    double angleRadians = (90 + angleDegrees) * M_PI / 180.0;\n    int major_axis = std::max(radiusX, radiusY);\n    for (int x = centerX - major_axis; x <= centerX + major_axis; ++x) {\n        for (int y = centerY - major_axis; y <= centerY + major_axis; ++y) {\n            // Compute the position of (x, y) in the rotated ellipse's frame of reference\n            double rotatedX = (x - centerX) * cos(-angleRadians) - (y - centerY) * sin(-angleRadians);\n            double rotatedY = (x - centerX) * sin(-angleRadians) + (y - centerY) * cos(-angleRadians);\n\n            // Check if this rotated point lies within the unrotated ellipse\n            if ((rotatedX * rotatedX) / (radiusX * radiusX) + (rotatedY * rotatedY) / (radiusY * radiusY) <= 1) {\n                SDL_RenderDrawPoint(renderer, x, y);\n            }\n        }\n    }\n}"
      ],
      "447": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void RenderingEngine::renderAllPatches() \n\nEntry Data: void RenderingEngine::renderAllPatches(){\n  for (int x = 0; x < WORLD_WIDTH; x++){\n    for (int y = 0; y < WORLD_HEIGHT; y++){\n      auto& patch = myWorld->get_patch(x,y);\n      int patch_x = patch.getX() * GRID_SIZE;\n      int patch_y = patch.getY() * GRID_SIZE;\n      std::string color = patch.getColor();\n      int opacity = patch.getOpacity();\n      drawSquare(patch_x,patch_y,GRID_SIZE, color, opacity);\n    }\n  }\n}"
      ],
      "448": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void RenderingEngine::renderPatchMode() \n\nEntry Data: void RenderingEngine::renderPatchMode(){\n  for (int x = 0; x < WORLD_WIDTH; x++){\n    for (int y = 0; y < WORLD_HEIGHT; y++){\n      auto& patch = myWorld->get_patch(x,y);\n      int patch_x = patch.getX() * GRID_SIZE;\n      int patch_y = patch.getY() * GRID_SIZE;\n      std::string color = patch.getModeColor();\n      int opacity = patch.getModeOpacity() * (255/3);\n      if (opacity > 255){opacity=255;}\n      // if (opacity>0){std::cout<<opacity<<std::endl;}\n      // std::cout<<'opacity '<<opacity<<std::endl;\n      // \n      // float opacity_scaling_value = (opacity - 0.001) / (3-0.001);\n      // if (opacity_scaling_value>1){opacity_scaling_value=1;}\n      // if (opacity_scaling_value<0){opacity_scaling_value=0;}\n      // opacity = opacity / (3/2);\n      // opacity = opacity_scaling_value * 255;\n      drawSquare(patch_x,patch_y,GRID_SIZE, color, opacity);\n    }\n  }\n}"
      ],
      "449": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void RenderingEngine::renderAllTurtles() \n\nEntry Data: void RenderingEngine::renderAllTurtles(){\n  int x, y;\n  for (auto& agent : myWorld->all_turtles){\n    x = agent.lock()->getX() * GRID_SIZE;\n    y = agent.lock()->getY() * GRID_SIZE;\n    std::string color = agent.lock()->getColor();\n    int opacity = agent.lock()->getOpacity();\n    std::string shape = agent.lock()->getShape();\n    if (shape=='square'){\n      drawSquare(x,y,(GRID_SIZE-1) * agent.lock()->getSize(), color, opacity);\n    }else if(shape=='target'){\n      drawSquare(x,y,(GRID_SIZE-1) * agent.lock()->getSize(), color, opacity);\n      drawCircle(x-1,y-1,(((GRID_SIZE/2)*agent.lock()->getSize())-2), 'black', opacity);\n    }else if (shape=='bug'){\n      // going to be an elipse with two little antennae on the front \n      int angle = agent.lock()->getHeading();\n      \n      drawFilledEllipse(x,y, (GRID_SIZE-1) * agent.lock()->getSize()/2, (GRID_SIZE-1) * agent.lock()->getSize()/4, color, opacity, angle);\n      drawLine(x,y, x+cos(angle*M_PI/180)*GRID_SIZE* agent.lock()->getSize(), y - sin(angle*M_PI/180)*GRID_SIZE* agent.lock()->getSize(), color, opacity);\n      // bounding rect\n      // SDL_Rect ellipseRect = \n      \n      // for (int x_draw=-1 * agent.lock()->getSize()*GRID_SIZE; x_draw <= agent.lock()->getSize()*GRID_SIZE; x_draw++){\n      //   for (int y_draw=-1 * agent.lock()->getSize()*GRID_SIZE; y_draw <= agent.lock()->getSize()*GRID_SIZE; y_draw++){\n      //     if (x_draw < ){\n      // \n      //     };\n      // \n      //   }\n      // }\n      \n      \n      // float x_offset = sin(angle) * (GRID_SIZE/2);\n      // float y_offset = cos(angle) * (GRID_SIZE/2);\n      // \n      // drawSquare(x,y,(GRID_SIZE-2) * agent.lock()->getSize(), color, opacity);\n      // drawCircle(x + x_offset,y + y_offset,(((GRID_SIZE/2)*agent.lock()->getSize())-2), color, opacity);\n\n    }else{\n      drawCircle(x,y,((GRID_SIZE/2)), color, opacity);\n\n    }\n  }\n}\n"
      ],
      "450": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void World::auto_inoculate(int numBac)  \n\nEntry Data: void World::auto_inoculate(int numBac) {\n\n    int numPhagocytosedBac = std::min(static_cast<int>(round(numBac * 0.8)), 100);\n    int numFreeBac = numBac - numPhagocytosedBac;\n\n    // Simulating the 'ask up-to-n-of num-phagocytosed-bac fdcs'\n    // Let's say all_fdcs is your list of FDCs\n    for (int i = 0; i < std::min(numPhagocytosedBac, static_cast<int>(all_fdcs.size())); i++) {\n        int random_FDC_index = RNG_Engine() % all_fdcs.size();\n        all_fdcs[random_FDC_index]->setResponsiveness(std::min(all_fdcs[random_FDC_index]->getResponsiveness() + 50, 100));\n        all_fdcs[random_FDC_index]->setTimePresenting(0);\n        all_fdcs[random_FDC_index]->setPresentedAntigen(BACTERIA_EPITOPE_TYPE);\n        all_fdcs[random_FDC_index]->setColor('red');  // Assuming you have some way to represent color in your FDC class\n\n        int rTI = RNG_Engine() % NUMBER_OF_TI_EPITOPES;\n        int rTD = RNG_Engine() % NUMBER_OF_TD_EPITOPES;\n\n        if (rTI > rTD) {\n            all_fdcs[random_FDC_index]->setPresentedAntigenType(1); // 1 is TI\n        } else {\n            all_fdcs[random_FDC_index]->setPresentedAntigenType(2); // 2 is TD\n        }\n    }\n\n    // Now simulating the 'create-bacteria num-free-bac'\n    std::cout<<'IN AUTOINOCULATE, ADDING NEW BACTERIA. TOTAL ADDED IS '<<numFreeBac<<std::endl;\n    for (int i = 0; i < numFreeBac; i++) {\n        std::shared_ptr<Bacteria> new_bacteria = std::make_shared<Bacteria>(WORLD_WIDTH-1, std::ceil(WORLD_HEIGHT/2), global_ID_counter++);\n\n        new_bacteria->setColor('red');\n        new_bacteria->setShape('bug');\n        new_bacteria->setSize(BACTERIA_SIZE);\n        new_bacteria->setTimeAlive(0);\n        new_bacteria->setInBlood(false);\n        new_bacteria->setEpitopeType(BACTERIA_EPITOPE_TYPE);\n        new_bacteria->setNumTIep(NUMBER_OF_TI_EPITOPES);\n        new_bacteria->setNumTDep(NUMBER_OF_TD_EPITOPES);\n\n        new_bacteria->setS1pr1Level(0);\n        new_bacteria->setS1pr2Level(0);\n        new_bacteria->setCxcr5Level(0);\n        new_bacteria->setCcr7Level(0);\n        new_bacteria->setEbi2rLevel(0);\n\n        std::weak_ptr<Turtle> new_bacteria_weak_ptr = new_bacteria;\n        all_bacterias.push_back(new_bacteria);  // Assuming you have a list named all_bacteria\n        all_turtles.push_back(new_bacteria_weak_ptr);\n        get_patch(new_bacteria->getX(), new_bacteria->getY()).add_turtle(new_bacteria);\n    }\n}"
      ],
      "451": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void World::check_overall_cd21_expression()  \n\nEntry Data: void World::check_overall_cd21_expression() {\n    if (step % 20 == 0) {   // Only calculating avg CD21 expression every 20 ticks to increase run speed\n        double total_cd21_expression = 0;\n\n        for (const auto& cell : all_naive_b_cells) {\n            total_cd21_expression += cell->getCd21Level();\n        }\n\n        for (const auto& cell : all_mem_b_cells) {\n            total_cd21_expression += cell->getCd21Level();\n        }\n\n        int total_cell_count = all_naive_b_cells.size() + all_mem_b_cells.size();\n\n        if (total_cell_count != 0) {\n            average_cd21_expression = total_cd21_expression / total_cell_count;\n        } else {\n            average_cd21_expression = 0;\n        }\n    }\n}"
      ],
      "452": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void World::calculateIncomingTNFaIL6Level()  \n\nEntry Data: void World::calculateIncomingTNFaIL6Level() {\n    for (auto& patchRow : all_patches) {\n      for (auto& patch : patchRow){\n        patch.setTnfA(patch.getTnfA() + (countCells<Bacteria>(patch.getX(), patch.getY()) / 500.0));\n\n        patch.setIl6(patch.getIl6() + (countCells<Bacteria>(patch.getX(), patch.getY()) / 500.0));\n      }\n    }\n}"
      ],
      "453": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void World::simulateBackgroundInflammation()  \n\nEntry Data: void World::simulateBackgroundInflammation() {\n    for (auto& patchRow : all_patches) {\n      for (auto& patch : patchRow){\n        patch.setTnfA(patch.getTnfA() + BACKGROUND_TNFA);\n        patch.setIl6(patch.getIl6() + BACKGROUND_IL6);\n      }\n    }\n}\n"
      ],
      "454": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void World::spawnTh0Cell()  \n\nEntry Data: void World::spawnTh0Cell() {\n    if(step % 20 == 0) {\n      std::cout<<'SPAWNING TH0 CELL'<<std::endl;\n\n        // Position of the new Th0-cell\n        int cell_x, cell_y;\n\n        // Keep generating random coordinates until we find a patch of type 1\n        do {\n            cell_x = RNG_Engine() % WORLD_WIDTH;\n            cell_y = RNG_Engine() % WORLD_HEIGHT;\n        } while(get_patch(cell_x, cell_y).getPatchType() != 1);\n\n        // Increase global ID counter\n        global_ID_counter++;\n        // Create a new Th0-cell\n        auto th0_cell = std::make_shared<Th0Cell>(cell_x, cell_y, global_ID_counter);\n        std::weak_ptr<Turtle> th0_cell_weak_ptr = th0_cell;\n\n        // Set the properties of the new Th0-cell\n        th0_cell->setShape('square');\n        th0_cell->setColor('yellow');\n        th0_cell->setTimeAlive(0);\n        th0_cell->setS1pr1Level(0);\n        th0_cell->setS1pr2Level(0);\n        th0_cell->setCxcr5Level(0);\n        th0_cell->setCcr7Level(6);\n        th0_cell->setEbi2rLevel(6);\n        th0_cell->setInBlood(false);\n\n        // Add the new Th0-cell to the list of all Th0-cells\n        all_th0_cells.push_back(th0_cell);\n\n        // Also add it to the list of all Turtles\n        all_turtles.push_back(th0_cell_weak_ptr);\n\n        get_patch(th0_cell->getX(), th0_cell->getY()).add_turtle(th0_cell);\n\n    }\n}\n"
      ],
      "455": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: std::shared_ptr<Antibodies> World::getOneAntibodyHere(int patchX, int patchY)  \n\nEntry Data: std::shared_ptr<Antibodies> World::getOneAntibodyHere(int patchX, int patchY) {\n    // Create a vector to store antibodies on the specified patch\n    std::vector<std::shared_ptr<Antibodies>> antibodiesOnPatch;\n    Patch& current_patch = get_patch(patchX, patchY);\n    std::vector<std::shared_ptr<Turtle>> turtles_on_patch = current_patch.getTurtlesHere();\n    // Find antibodies on the patch\n    for (const auto& turtle : turtles_on_patch) {\n      if (std::shared_ptr<Antibodies> antibody = std::dynamic_pointer_cast<Antibodies>(turtle)) {\n        // The turtle is a NaiveBCell, add it to the corresponding vector\n        antibodiesOnPatch.push_back(antibody);\n      }\n    }\n    // Check if any antibodies are found on the patch\n    if (antibodiesOnPatch.empty()) {\n        return nullptr; // Return nullptr if no antibodies found on the patch\n    }\n    // Generate a random index to pick a random antibody from the antibodiesOnPatch vector\n    int randomIndex = RNG_Engine() % antibodiesOnPatch.size();\n\n    // Return the randomly selected antibody\n    return antibodiesOnPatch[randomIndex];\n}\n"
      ],
      "456": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: std::shared_ptr<FDCs> World::getOneFDCHere(int patchX, int patchY) \n\nEntry Data: std::shared_ptr<FDCs> World::getOneFDCHere(int patchX, int patchY){\n    // Create a vector to store antibodies on the specified patch\n    std::vector<std::shared_ptr<FDCs>> FDCsOnPatch;\n    Patch& current_patch = get_patch(patchX, patchY);\n    std::vector<std::shared_ptr<Turtle>> turtles_on_patch = current_patch.getTurtlesHere();\n    // Find antibodies on the patch\n    for (const auto& turtle : turtles_on_patch) {\n      if (std::shared_ptr<FDCs> fdc = std::dynamic_pointer_cast<FDCs>(turtle)) {\n        // The turtle is a NaiveBCell, add it to the corresponding vector\n        FDCsOnPatch.push_back(fdc);\n      }\n    }\n    // Check if any antibodies are found on the patch\n    if (FDCsOnPatch.empty()) {\n        return nullptr; // Return nullptr if no antibodies found on the patch\n    }\n    // Generate a random index to pick a random antibody from the antibodiesOnPatch vector\n    int randomIndex = RNG_Engine() % FDCsOnPatch.size();\n\n    // Return the randomly selected antibody\n    return FDCsOnPatch[randomIndex];\n}\n"
      ],
      "457": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: \nstd::shared_ptr<Bacteria> World::getOneBacteriaHere(int patchX, int patchY) \n\nEntry Data: \nstd::shared_ptr<Bacteria> World::getOneBacteriaHere(int patchX, int patchY){\n    // Create a vector to store antibodies on the specified patch\n    std::vector<std::shared_ptr<Bacteria>> bacteriaOnPatch;\n    for (float x =-BACTERIA_SIZE/2; x <= BACTERIA_SIZE/2; x++){\n      for (float y =-BACTERIA_SIZE/2; y <= BACTERIA_SIZE/2; y++){\n        float x_to_get, y_to_get;\n        if (!TOROIDAL_WORLD) {\n          x_to_get = std::min(patchX+x,(float)WORLD_WIDTH-1);\n          x_to_get = std::max(x_to_get,(float)0);\n          y_to_get = std::min(patchY+y,(float)WORLD_HEIGHT-1);\n          y_to_get = std::min(y_to_get,(float)0);\n        } else {\n          x_to_get = fmod(patchX+x,WORLD_WIDTH);\n          y_to_get = fmod(patchY+y,WORLD_HEIGHT);\n        }\n\n        Patch& current_patch = get_patch(x_to_get, y_to_get);\n        std::vector<std::shared_ptr<Turtle>> turtles_on_patch = current_patch.getTurtlesHere();\n        // Find antibodies on the patch\n        for (const auto& turtle : turtles_on_patch) {\n          if (std::shared_ptr<Bacteria> bacteria = std::dynamic_pointer_cast<Bacteria>(turtle)) {\n            // The turtle is a bacteria, add it to the corresponding vector\n            // std::cout<<'FOUND BACTERIA ON PATCH'<<std::endl;\n            bacteriaOnPatch.push_back(bacteria);\n          }\n        }\n      }\n    }\n\n    // Check if any antibodies are found on the patch\n    if (bacteriaOnPatch.empty()) {\n        return nullptr; // Return nullptr if no antibodies found on the patch\n    }\n    // Generate a random index to pick a random Bacteria from the antibodiesOnPatch vector\n    int randomIndex = RNG_Engine() % bacteriaOnPatch.size();\n\n    // Return the randomly selected Bacteria\n    return bacteriaOnPatch[randomIndex];\n}"
      ],
      "458": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: std::shared_ptr<Th2Cell> World::getOneTh2Here(int patchX, int patchY) \n\nEntry Data: std::shared_ptr<Th2Cell> World::getOneTh2Here(int patchX, int patchY){\n    std::vector<std::shared_ptr<Th2Cell>> Th2CellsOnPatch;\n    Patch& current_patch = get_patch(patchX, patchY);\n    std::vector<std::shared_ptr<Turtle>> turtles_on_patch = current_patch.getTurtlesHere();\n    for (const auto& turtle : turtles_on_patch) {\n      if (std::shared_ptr<Th2Cell> th2 = std::dynamic_pointer_cast<Th2Cell>(turtle)) {\n        Th2CellsOnPatch.push_back(th2);\n      }\n    }\n    if (Th2CellsOnPatch.empty()) {\n        return nullptr;\n    }\n    int randomIndex = RNG_Engine() % Th2CellsOnPatch.size();\n    return Th2CellsOnPatch[randomIndex];\n}"
      ],
      "459": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: std::shared_ptr<TfhCell> World::getOneTfhHere(int patchX, int patchY) \n\nEntry Data: std::shared_ptr<TfhCell> World::getOneTfhHere(int patchX, int patchY){\n    std::vector<std::shared_ptr<TfhCell>> TfhCellsOnPatch;\n    Patch& current_patch = get_patch(patchX, patchY);\n    std::vector<std::shared_ptr<Turtle>> turtles_on_patch = current_patch.getTurtlesHere();\n    for (const auto& turtle : turtles_on_patch) {\n      if (std::shared_ptr<TfhCell> tfh = std::dynamic_pointer_cast<TfhCell>(turtle)) {\n        TfhCellsOnPatch.push_back(tfh);\n      }\n    }\n    if (TfhCellsOnPatch.empty()) {\n        return nullptr;\n    }\n    int randomIndex = RNG_Engine() % TfhCellsOnPatch.size();\n    return TfhCellsOnPatch[randomIndex];\n}"
      ],
      "460": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: std::shared_ptr<ActivatedBCell> World::getOneActivatedBCellHere(int patchX, int patchY) \n\nEntry Data: std::shared_ptr<ActivatedBCell> World::getOneActivatedBCellHere(int patchX, int patchY){\n    std::vector<std::shared_ptr<ActivatedBCell>> ActivatedBCellsOnPatch;\n    Patch& current_patch = get_patch(patchX, patchY);\n    std::vector<std::shared_ptr<Turtle>> turtles_on_patch = current_patch.getTurtlesHere();\n    for (const auto& turtle : turtles_on_patch) {\n      if (std::shared_ptr<ActivatedBCell> activated_b_cell = std::dynamic_pointer_cast<ActivatedBCell>(turtle)) {\n        ActivatedBCellsOnPatch.push_back(activated_b_cell);\n      }\n    }\n    if (ActivatedBCellsOnPatch.empty()) {\n        return nullptr;\n    }\n    int randomIndex = RNG_Engine() % ActivatedBCellsOnPatch.size();\n    return ActivatedBCellsOnPatch[randomIndex];\n}\n"
      ],
      "461": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: std::vector<std::shared_ptr<FDCs>> World::get_fdcs_with_no_presented_antigen() \n\nEntry Data: std::vector<std::shared_ptr<FDCs>> World::get_fdcs_with_no_presented_antigen(){\n  std::vector<std::shared_ptr<FDCs>> FDCs_with_no_anitigen;\n  for (auto fdc : all_fdcs){\n    if (fdc->getPresentedAntigen() ==0) {\n      FDCs_with_no_anitigen.push_back(fdc);\n    }\n  }\n  return FDCs_with_no_anitigen;\n}\n"
      ],
      "462": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: SLPlasmaCell::SLPlasmaCell(int x, int y, int id, int heading) : Turtle(x, y, id, heading)  \n\nEntry Data: SLPlasmaCell::SLPlasmaCell(int x, int y, int id, int heading) : Turtle(x, y, id, heading) {\n    // Constructor\n    // std::cout<<'creating SL plasma cell with ID '<<id<<std::endl;\n\n}"
      ],
      "463": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void World::sl_plasma_cell_function(std::shared_ptr<SLPlasmaCell> sl_plasma_cell)  \n\nEntry Data: void World::sl_plasma_cell_function(std::shared_ptr<SLPlasmaCell> sl_plasma_cell) {\n  if (!sl_plasma_cell->get_is_alive()) {return;}\n  bool print_test = false;\n  Patch& current_patch = get_patch(sl_plasma_cell->getX(), sl_plasma_cell->getY());\n  if (print_test){std::cout<<'doing SL plasma function for '<<sl_plasma_cell->getID()<<std::endl;}\n    if(!sl_plasma_cell->getInBlood()) {\n      if (print_test){std::cout<<'doing SL plasma cause not in blood at '<<sl_plasma_cell->getX()<<', '<<sl_plasma_cell->getY()<<std::endl;}\n\n        if(current_patch.getPatchType() == 2) {\n            sl_plasma_cell->setInBlood(true);\n            sl_plasma_cell->setVisible(false);\n            if(print_test){std::cout<<'killing Sl_plasma cell at follicle exit'<<std::endl;}\n            return;\n        }\n\n        // Assuming you have a check_breg_status function\n        bool turn_into_breg = checkBregStatus(sl_plasma_cell);\n        if (turn_into_breg){\n          if (print_test){std::cout<<'sl_plasma ID '<<sl_plasma_cell->getID()<<'turning into Breg'<<std::endl;}\n          std::shared_ptr<BregCell> sl_plasma_cell = turnIntoBreg(sl_plasma_cell);\n        };\n\n        chemotaxis(sl_plasma_cell);\n        if (print_test){std::cout<<'moving SL_plasma_cell with use count '<<sl_plasma_cell.use_count()<<std::endl;}\n\n        move_turtle(sl_plasma_cell);\n        //std::cout<<'moved SL_plasma_cell with use count '<<sl_plasma_cell.use_count()<<std::endl;\n    }\n\n    if(sl_plasma_cell->getTimeAlive() % 50 == 0) {\n        auto antibody = std::make_shared<Antibodies>(sl_plasma_cell->getX(), sl_plasma_cell->getY(), global_ID_counter++, sl_plasma_cell->getHeading());\n        antibody->copy_other_turtle_attributes(sl_plasma_cell);\n        antibody->setTimeAlive(0);\n        antibody->setAntibodyType(sl_plasma_cell->getIsotype());\n        antibody->setVisible(false);\n        antibody->setColor('mauve');\n        \n        std::weak_ptr<Turtle> antibody_weak_ptr = antibody;\n        all_turtles.push_back(antibody_weak_ptr);\n        all_antibodies.push_back(antibody);\n        get_patch(antibody->getX(), antibody->getY()).add_turtle(antibody);\n    }\n\n    // Checks level of TNF-a stimulation for apoptosis\n    bool die_by_tnf = checkTNFStatus(sl_plasma_cell);\n\n    sl_plasma_cell->setTimeAlive(sl_plasma_cell->getTimeAlive() + 1);\n    if((sl_plasma_cell->getTimeAlive() > 240 + (current_patch.getIl6() + current_patch.getIl21()) * 10) || die_by_tnf) {\n        kill(sl_plasma_cell);\n    }\n}\n"
      ],
      "464": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: TfhCell::TfhCell(int x, int y, int id, int heading) : Turtle(x, y, id, heading)  \n\nEntry Data: TfhCell::TfhCell(int x, int y, int id, int heading) : Turtle(x, y, id, heading) {\n    // Constructor\n    // std::cout<<'creating TFH cell ID '<<id<<std::endl;\n\n}"
      ],
      "465": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void World::tfhCellFunction(std::shared_ptr<TfhCell> tfh_cell)  \n\nEntry Data: void World::tfhCellFunction(std::shared_ptr<TfhCell> tfh_cell) {\n  if (!tfh_cell->get_is_alive()) {return;}\n  bool print_test = false;\n  if (print_test){std::cout<<'TfH function for ID '<<tfh_cell->getID()<<std::endl;}\n\n    Patch& current_patch = get_patch(tfh_cell->getX(), tfh_cell->getY());\n\n    if (calculateDistance(WORLD_WIDTH / 2, WORLD_HEIGHT / 2, tfh_cell->getX(), tfh_cell->getY()) > 20 || !tfh_cell->getBcellBindingStatus()) {\n      // std::cout<<'chemotaxin TfH with distance to center equal to '<<calculateDistance(WORLD_WIDTH / 2, WORLD_HEIGHT / 2, tfh_cell->getX(), tfh_cell->getY())<<std::endl;\n\n        chemotaxis(tfh_cell);\n        // std::cout<<'Moving tfh'<<std::endl;\n\n        move_turtle(tfh_cell);\n    }\n\n    // Secretes the following cytokines\n    current_patch.setIl21(current_patch.getIl21() + 1);\n    current_patch.setIl4(current_patch.getIl4() + 1);\n    current_patch.setIl2(current_patch.getIl2() + 1);\n    current_patch.setIl10(current_patch.getIl10() + 1);\n\n    tfh_cell->setTimeAlive(tfh_cell->getTimeAlive() + 1);\n\n    // Uncomment the following lines if you want the Tfh cells to die after being alive for more than 500 time steps.\n    //if (tfh_cell->getTimeAlive() > 500) {\n    //    kill(tfh_cell);\n    //}\n}"
      ],
      "466": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: Th0Cell::Th0Cell(int x, int y, int id, int heading) : Turtle(x, y, id, heading)  \n\nEntry Data: Th0Cell::Th0Cell(int x, int y, int id, int heading) : Turtle(x, y, id, heading) {\n    // Constructor\n    // std::cout<<'creating TH 0 cell with ID '<<id<<std::endl;\n\n}"
      ],
      "467": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void World::th0CellFunction(std::shared_ptr<Th0Cell> th0_cell)  \n\nEntry Data: void World::th0CellFunction(std::shared_ptr<Th0Cell> th0_cell) {\n  if (!th0_cell->get_is_alive()) {return;}\n\n  std::cout<<'TH 0 function'<<std::endl;\n    // Get the current patch of the Th0 cell\n    Patch& current_patch = get_patch(th0_cell->getX(), th0_cell->getY());\n\n    double pro_TH1 = (current_patch.getIl12() + current_patch.getIfG()) * 100;\n    double pro_TH2 = (current_patch.getIl10() + current_patch.getIl4()) * 100;\n    double pro_TFH = (current_patch.getIl21() + current_patch.getIl12()) * 100;\n\n    double rTH1 = fmod((double)RNG_Engine(), pro_TH1);\n    double rTH2 = fmod((double)RNG_Engine(), pro_TH2);\n    double rTFH = fmod((double)RNG_Engine(), pro_TFH);\n\n    th0_cell->setR1(rTH1);\n    th0_cell->setR2(rTH2);\n    th0_cell->setRf(rTFH);\n\n    if (rTH1 > rTH2 && rTH1 > rTFH) {\n        th0_cell->setTh1Activation(th0_cell->getTh1Activation() + 1);\n    }\n    if (rTH2 > rTH1 && rTH2 > rTFH) {\n        th0_cell->setTh2Activation(th0_cell->getTh2Activation() + 1);\n    }\n    if (rTFH > rTH1 && rTFH > rTH2) {\n        th0_cell->setTfhActivation(th0_cell->getTfhActivation() + 1);\n    }\n\n    if (th0_cell->getTh1Activation() >= 20) {\n        auto th1_cell = std::make_shared<Th1Cell>(th0_cell->getX(), th0_cell->getY(), global_ID_counter++, th0_cell->getHeading());\n        th1_cell->copy_other_turtle_attributes(th0_cell);\n        th1_cell->setColor('blue');\n        th1_cell->setTimeAlive(0);\n        th1_cell->setSize(1);\n        th1_cell->setShape('circle');\n\n        std::weak_ptr<Turtle> th1_cell_weak_ptr = th1_cell;\n        all_turtles.push_back(th1_cell_weak_ptr);\n        all_th1_cells.push_back(th1_cell);\n        current_patch.add_turtle(th1_cell);\n\n        kill(th0_cell);\n        std::shared_ptr<Th1Cell> th0_cell = th1_cell;\n    } else if (th0_cell->getTh2Activation() >= 20) {\n        auto th2_cell = std::make_shared<Th2Cell>(th0_cell->getX(), th0_cell->getY(), global_ID_counter++, th0_cell->getHeading());\n        th2_cell->copy_other_turtle_attributes(th0_cell);\n        th2_cell->setColor('blue');\n        th2_cell->setTimeAlive(0);\n        th2_cell->setSize(1);\n        th2_cell->setShape('circle');\n        th2_cell->setBcellBindingStatus(false);\n\n        std::weak_ptr<Turtle> th2_cell_weak_ptr = th2_cell;\n        all_turtles.push_back(th2_cell_weak_ptr);\n        all_th2_cells.push_back(th2_cell);\n        current_patch.add_turtle(th2_cell);\n\n        kill(th0_cell);\n        std::shared_ptr<Th2Cell> th0_cell = th2_cell;\n\n    } else if (th0_cell->getTfhActivation() >= 20) {\n        auto tfh_cell = std::make_shared<TfhCell>(th0_cell->getX(), th0_cell->getY(), global_ID_counter++, th0_cell->getHeading());\n        global_ID_counter++;\n        tfh_cell->copy_other_turtle_attributes(th0_cell);\n        tfh_cell->setCxcr5Level(10);\n        tfh_cell->setColor('cyan');\n        tfh_cell->setShape('circle');\n        tfh_cell->setSize(1);\n        tfh_cell->setTimeAlive(0);\n        tfh_cell->setBcellBindingStatus(false);\n\n        std::weak_ptr<Turtle> tfh_cell_weak_ptr = tfh_cell;\n        all_turtles.push_back(tfh_cell_weak_ptr);\n        all_tfh_cells.push_back(tfh_cell);\n        current_patch.add_turtle(tfh_cell);\n\n        kill(th0_cell);\n        std::shared_ptr<TfhCell> th0_cell = tfh_cell;\n\n    }\n    std::cout<<'chemotaxin from TH0 '<<std::endl;\n    chemotaxis(th0_cell);\n    // std::cout<<'Moving th0'<<std::endl;\n\n    move_turtle(th0_cell);\n\n    th0_cell->setTimeAlive(th0_cell->getTimeAlive() + 1);\n    if (th0_cell->getTimeAlive() > 300) {\n      std::cout <<'killing th0 cell '<<th0_cell->getID()<<std::endl;\n        kill(th0_cell);\n    }\n}\n"
      ],
      "468": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: Th1Cell::Th1Cell(int x, int y, int id, int heading) : Turtle(x, y, id, heading)  \n\nEntry Data: Th1Cell::Th1Cell(int x, int y, int id, int heading) : Turtle(x, y, id, heading) {\n    // Constructor\n    // std::cout<<'creating TH 1 cell with ID '<<id<<std::endl;\n\n}"
      ],
      "469": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void World::th1CellFunction(std::shared_ptr<Th1Cell> th1_cell)  \n\nEntry Data: void World::th1CellFunction(std::shared_ptr<Th1Cell> th1_cell) {\n  if (!th1_cell->get_is_alive()) {return;}\n    bool print_test = false;\n    if (print_test){std::cout<<'TH1 function for '<<th1_cell->getID()<<std::endl;}\n    Patch& current_patch = get_patch(th1_cell->getX(), th1_cell->getY());\n\n    chemotaxis(th1_cell);\n    // std::cout<<'Moving th1'<<std::endl;\n\n    move_turtle(th1_cell);\n\n    // Secretes the following cytokines\n    current_patch.setIfG(current_patch.getIfG() + 1);\n\n    th1_cell->setTimeAlive(th1_cell->getTimeAlive() + 1);\n\n    // Uncomment the following lines if you want the Th1 cells to die after being alive for more than 500 time steps.\n    //if (th1_cell->getTimeAlive() > 500) {\n    //    kill(th1_cell);\n    //}\n}\n"
      ],
      "470": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: Th2Cell::Th2Cell(int x, int y, int id, int heading) : Turtle(x, y, id, heading)  \n\nEntry Data: Th2Cell::Th2Cell(int x, int y, int id, int heading) : Turtle(x, y, id, heading) {\n    // Constructor\n    // std::cout<<'creating TH 2 cell ID '<<id<<std::endl;\n\n}"
      ],
      "471": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void World::th2CellFunction(std::shared_ptr<Th2Cell> th2_cell)  \n\nEntry Data: void World::th2CellFunction(std::shared_ptr<Th2Cell> th2_cell) {\n  if (!th2_cell->get_is_alive()) {return;}\n  bool print_test = false;\n  if (print_test){std::cout<<'TH2 function for '<<th2_cell->getID()<<std::endl;}\n\n    Patch& current_patch = get_patch(th2_cell->getX(), th2_cell->getY());\n\n    // Calculate the Euclidean distance between the cell's location and the center of the world (WORLD_WIDTH/2, WORLD_HEIGHT/2)\n    if (calculateDistance(WORLD_WIDTH/2, WORLD_HEIGHT/2, th2_cell->getX(), th2_cell->getY()) > 20 || !th2_cell->getBcellBindingStatus()) {\n        chemotaxis(th2_cell);\n        // std::cout<<'Moving th2'<<std::endl;\n\n        move_turtle(th2_cell);\n    }\n\n    // Secretes the following cytokines\n    current_patch.setIl4(current_patch.getIl4() + 1);\n    current_patch.setIl10(current_patch.getIl10() + 1);\n\n    th2_cell->setTimeAlive(th2_cell->getTimeAlive() + 1);\n\n    // Uncomment the following lines if you want the Th2 cells to die after being alive for more than 500 time steps.\n    //if (th2_cell->getTimeAlive() > 500) {\n    //    kill(th2_cell);\n    //}\n}\n"
      ],
      "472": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void Turtle::addLinkedTurtle(std::weak_ptr<Turtle> linkedTurtle)  \n\nEntry Data: void Turtle::addLinkedTurtle(std::weak_ptr<Turtle> linkedTurtle) {\n    linkedTurtles.push_back(linkedTurtle);\n    std::shared_ptr<Turtle> temp_shared_ptr = std::dynamic_pointer_cast<Turtle>(shared_from_this());\n    std::weak_ptr<Turtle> weak_ptr = temp_shared_ptr;\n    linkedTurtle.lock()->getLinkedTurtles().push_back(weak_ptr);\n    temp_shared_ptr.reset();\n}\n"
      ],
      "473": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: std::vector<std::weak_ptr<Turtle>>& Turtle::getLinkedTurtles()  \n\nEntry Data: std::vector<std::weak_ptr<Turtle>>& Turtle::getLinkedTurtles() {\n    return linkedTurtles;\n}\n"
      ],
      "474": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void Turtle::removeLinkedTurtle() \n\nEntry Data: void Turtle::removeLinkedTurtle(){\n  for(auto neighbor : this->getLinkedTurtles()){\n    auto iter = std::find_if(neighbor.lock()->getLinkedTurtles().begin(), neighbor.lock()->getLinkedTurtles().end(), WeakPtrComparator<Turtle>(ID_num));  // finding where current ID_num of this turtle is in the nieghbors list of links\n    if (iter != neighbor.lock()->getLinkedTurtles().end()) {\n         neighbor.lock()->getLinkedTurtles().erase(iter);\n     } else {\n         std::cout << 'Linked turtle not found in the neighbors vector. 1 ERRORRRR' << std::endl;\n     }\n\n     iter = std::find_if(this->getLinkedTurtles().begin(), this->getLinkedTurtles().end(), WeakPtrComparator<Turtle>(neighbor.lock()->getID()));\n     if (iter != this->getLinkedTurtles().end()) {\n          this->getLinkedTurtles().erase(iter);\n      } else {\n          std::cout << 'Neighbor Linked turtle not found in the vector. 2 ERRORRRR' << std::endl;\n      }\n  }\n  linkedTurtles.clear();\n}\n\n"
      ],
      "475": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: std::pair<double,double> Turtle::move(float distance)  \n\nEntry Data: std::pair<double,double> Turtle::move(float distance) {\n  // this function moves the turtle internally and is called inside World::move_turtle(), so should only really be accessed from there.\n\n  // default val for distance=1\n  // calculates the movement for the turtle based on its heading and distance to move and returns the coordinates of the destination patch\n    temp_x = x_dec;   //placeholders in case we are not able to actually execute the move. In that case, these will reset x/y decimal values\n    temp_y = y_dec;\n    double d_x = cos(heading * M_PI/180) * distance;   // converting degrees to radians and getting delta x and delta y\n    double d_y = -1 * sin(heading * M_PI/180) * distance;\n    if (!TURTLE_CONTINOUS_MOVEMENT) {   //ie discrete movement, turtles always land on the middle of patches\n      d_x = round(d_x);\n      d_y = round(d_y);\n    }\n    x_dec += d_x;\n    y_dec += d_y;\n    if (TOROIDAL_WORLD){\n      x_dec = fmod(fmod(x_dec, WORLD_WIDTH) +WORLD_WIDTH, WORLD_WIDTH);              // wrapping around world with modulo\n      y_dec = fmod(fmod(y_dec, WORLD_HEIGHT) +WORLD_HEIGHT, WORLD_HEIGHT);           // taking double mod to make sure that a positive number for grid coordinates\n    } else{\n      if (x_dec >= WORLD_WIDTH){x_dec = WORLD_WIDTH-1;}\n      if (y_dec >= WORLD_HEIGHT){y_dec = WORLD_HEIGHT-1;}\n      if (x_dec < 0){x_dec = 0;}\n      if (y_dec < 0){y_dec = 0;}\n    }\n    return std::make_pair(x_dec, y_dec);\n}"
      ],
      "476": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void Turtle::execute_move(bool didMove) \n\nEntry Data: void Turtle::execute_move(bool didMove){\n  // if we execute the move, then the world has moved the turtle to a new patch, and we need to update internal variables\n  if(didMove){\n    setX(trunc(x_dec));                             // truncating decimal coords to get int coords\n    setY(trunc(y_dec));\n    temp_x = x_dec;\n    temp_y = y_dec;\n  } else{\n    x_dec = temp_x;\n    y_dec = temp_y;\n  }\n}"
      ],
      "477": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: std::pair<int,int> Turtle::jumpRandom(std::mt19937 &RNG_Engine)  \n\nEntry Data: std::pair<int,int> Turtle::jumpRandom(std::mt19937 &RNG_Engine) {\n  // get a random direction, then a random distance, then return the coordinates that we jumped to\n    int random_heading = RNG_Engine()%360;\n    int random_distance = RNG_Engine()%MAX_RANDOM_DISTANCE;\n\n    this->setHeading(random_heading);\n    return this->move(random_distance);\n}\n"
      ],
      "478": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void Turtle::wiggle(std::mt19937 &RNG_Engine) \n\nEntry Data: void Turtle::wiggle(std::mt19937 &RNG_Engine){\n  // randomly wiggle heading up to 45 degrees left up to 45 degrees right\n  int random_left = RNG_Engine()%45;\n  int random_right = RNG_Engine()%45;\n\n  // std::cout<<'WIGGLING TURTLE NOW. new heading is '<<this->getHeading() + random_left - random_right<<std::endl;\n  this->setHeading(this->getHeading() + (random_left - random_right));\n}\n"
      ],
      "479": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void Turtle::display()  \n\nEntry Data: void Turtle::display() {\n  std::cout << 'Turtle position: (' << this->getX() << ', ' << this->getY() << ')' << std::endl;\n  std::cout << 'Turtle exact position: (' << x_dec << ', ' << y_dec << ')' << std::endl;\n  std::cout << 'Turtle Heading: (' << heading << ')' << std::endl;\n  std::cout << 'Turtle ID: (' << ID_num << ')' << std::endl;\n}\n"
      ],
      "480": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void Turtle::copy_other_turtle_attributes(std::shared_ptr<Turtle> otherTurtle) \n\nEntry Data: void Turtle::copy_other_turtle_attributes(std::shared_ptr<Turtle> otherTurtle){\n  this->setHeading(otherTurtle->getHeading());\n  this->setTimeAlive(otherTurtle->getTimeAlive());\n  // Copying the additional attributes\n  // this->x_dec = otherTurtle->get_x_dec();\n  // this->y_dec = otherTurtle->get_y_dec();\n  // this->temp_x = otherTurtle->get_temp_x();\n  // this->temp_y = otherTurtle->get_temp_y();\n  this->setInBlood(otherTurtle->getInBlood());\n  this->setBcr(otherTurtle->getBcr());\n  this->setIsotype(otherTurtle->getIsotype());\n  this->setCsrBool(otherTurtle->getCsrBool());\n  this->setTnfaThreshold(otherTurtle->getTnfaThreshold());\n  this->setBregThreshold(otherTurtle->getBregThreshold());\n  this->setCd21Level(otherTurtle->getCd21Level());\n  this->setS1pr1Level(otherTurtle->getS1pr1Level());\n  this->setS1pr2Level(otherTurtle->getS1pr2Level());\n  this->setCxcr5Level(otherTurtle->getCxcr5Level());\n  this->setCcr7Level(otherTurtle->getCcr7Level());\n  this->setEbi2rLevel(otherTurtle->getEbi2rLevel());\n  this->setProBreg(otherTurtle->getProBreg());\n  this->setLevelOfActivation(otherTurtle->getLevelOfActivation());\n  this->setTnfaStimulation(otherTurtle->getTnfaStimulation());\n  this->setExposureNumber(otherTurtle->getExposureNumber());\n}\n"
      ],
      "481": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void World::add_patch(int x, int y) \n\nEntry Data: void World::add_patch(int x, int y){\n  all_patches[x][y] = Patch(x,y);\n}\n"
      ],
      "482": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: Patch& World::get_patch(double x_arg, double y_arg) \n\nEntry Data: Patch& World::get_patch(double x_arg, double y_arg){\n  int x = trunc(x_arg);\n  int y = trunc(y_arg);\n  x = (x+WORLD_WIDTH)%WORLD_WIDTH;\n  y = (y+WORLD_HEIGHT)%WORLD_HEIGHT;\n  return all_patches[x][y];\n}\n"
      ],
      "483": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: Patch& World::get_patch_ahead(std::shared_ptr<Turtle> turtle, float distance) \n\nEntry Data: Patch& World::get_patch_ahead(std::shared_ptr<Turtle> turtle, float distance){\n  // default value for distance=1\n  // get the patch in front of the turtle, based on its current heading\n  int heading = turtle->getHeading();\n  int current_x = turtle->getX();\n  int current_y = turtle->getY();\n\n  float d_x = cos(heading * M_PI/180) * distance;   // converting degrees to radians and getting delta x and delta y\n  float d_y = sin(heading * M_PI/180) * distance;\n\n  int ahead_x = round(current_x + d_x);\n  int ahead_y = round(current_y + d_y);\n\n  return get_patch(ahead_x, ahead_y);\n}\n"
      ],
      "484": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: Patch& World::get_patch_ahead_right(std::shared_ptr<Turtle> turtle, float distance) \n\nEntry Data: Patch& World::get_patch_ahead_right(std::shared_ptr<Turtle> turtle, float distance){\n  // default value for distance=1\n  // get the patch in front and to the right of the turtle, based on its current heading\n  int heading = turtle->getHeading() - 45; // to look right 45 degrees\n  int current_x = turtle->getX();\n  int current_y = turtle->getY();\n\n  float d_x = cos(heading * M_PI/180) * distance;   // converting degrees to radians and getting delta x and delta y\n  float d_y = sin(heading * M_PI/180) * distance;\n\n  int ahead_x = round(current_x + d_x);\n  int ahead_y = round(current_y + d_y);\n\n  return get_patch(ahead_x, ahead_y);\n}\n"
      ],
      "485": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: Patch& World::get_patch_ahead_left(std::shared_ptr<Turtle> turtle, float distance) \n\nEntry Data: Patch& World::get_patch_ahead_left(std::shared_ptr<Turtle> turtle, float distance){\n  // default value for distance=1\n  // get the patch in front and to the right of the turtle, based on its current heading\n  int heading = turtle->getHeading() + 45; // to look left 45 degrees\n  int current_x = turtle->getX();\n  int current_y = turtle->getY();\n\n  float d_x = cos(heading * M_PI/180) * distance;   // converting degrees to radians and getting delta x and delta y\n  float d_y = sin(heading * M_PI/180) * distance;\n\n  int ahead_x = round(current_x + d_x);\n  int ahead_y = round(current_y + d_y);\n\n  return get_patch(ahead_x, ahead_y);\n}\n"
      ],
      "486": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void World::setup_patches() \n\nEntry Data: void World::setup_patches(){\n  for(int x=0; x<WORLD_WIDTH; x++){\n    for(int y=0; y<WORLD_HEIGHT; y++){\n      add_patch(x,y);\n      // set initial values on patches here; eg patch.setOxy(100) to set patch oxy to initial value\n    }\n  }\n}\n"
      ],
      "487": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void World::display_patches() \n\nEntry Data: void World::display_patches(){\n  // prints details about all patches as well as any turtles associated with them to the console\n  for(auto &patchArr: all_patches){\n    for(auto &patch: patchArr){\n      patch.display();\n    }\n  }\n}\n"
      ],
      "488": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void World::add_turtle(int x, int y, int id, int heading) \n\nEntry Data: void World::add_turtle(int x, int y, int id, int heading){\n  // creates a new generic turtle and adds it to the patch, as well as the list of all turtles\n  std::shared_ptr<Turtle> new_turtle = std::make_shared<Turtle>(x, y, id, heading);\n  get_patch(x,y).add_turtle(new_turtle);\n  all_turtles.emplace_back(new_turtle);\n}\n"
      ],
      "489": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void World::place_turtle(double x, double y, std::shared_ptr<Turtle> turtle) \n\nEntry Data: void World::place_turtle(double x, double y, std::shared_ptr<Turtle> turtle){\n  // moves turtle from its original patch to a new patch\n  Patch& original_patch = get_patch(turtle->getX(), turtle->getY());\n  Patch& new_patch = get_patch(x, y);\n  turtle->setX(trunc(x));\n  turtle->setY(trunc(y));\n  turtle->set_x_dec(x);\n  turtle->set_y_dec(y);\n  turtle->set_temp_x(x);\n  turtle->set_temp_y(y);\n\n  original_patch.remove_turtle(turtle);\n  new_patch.add_turtle(turtle);\n}\n"
      ],
      "490": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void World::move_turtle(std::shared_ptr<Turtle> turtle, float distance) \n\nEntry Data: void World::move_turtle(std::shared_ptr<Turtle> turtle, float distance){\n  // moves the turtle but asking the turtle to calculate its movement, and if there is space on the target_patch, the world executes the move\n  // This is the way that turtls should really be moved in the simulation, because this is the highest level control and will move them on world, their patch, and internally\n\n  turtle->wiggle(RNG_Engine);\n\n\n  Patch &turtle_current_patch = get_patch(turtle->getX(), turtle->getY());\n  std::pair<double,double> new_coords = turtle->move(distance); //moving along turtle.heading for the default value of 1 unit unless a parameter is given\n  Patch& target_patch = get_patch(new_coords.first, new_coords.second);\n  if (target_patch.is_at_capacity()){\n    turtle->execute_move(false);\n  }\n  else{\n    // moving linked turtles here\n    float main_turtle_dx = new_coords.first - turtle->get_temp_x();\n    float main_turtle_dy = new_coords.second - turtle->get_temp_y();\n    if (turtle->getLinkedTurtles().size()>0){\n      for (auto link : turtle->getLinkedTurtles()) {\n        float current_x = link.lock()->get_x_dec();\n        float current_y = link.lock()->get_y_dec();\n        place_turtle(current_x+main_turtle_dx, current_y+main_turtle_dy, link.lock());\n      }\n    }\n    turtle->execute_move(true);\n    int temp = turtle_current_patch.getTurtlesHere().size();\n    turtle_current_patch.remove_turtle(turtle);\n    // if we do not actually remove the turtle from the patch, something is wrong\n    if ((temp - turtle_current_patch.getTurtlesHere().size()) != 1){std::cout<<'We did not remove the turtle from a patch when moving it. current size is '<< turtle_current_patch.getTurtlesHere().size()<<'. This is a problem and we will exit now'; exit(10);}\n    // adding the turtle to the new patch (can be the same as the old patch)\n    target_patch.add_turtle(turtle);\n  }\n}\n"
      ],
      "491": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void World::move_turtle_random_jump(std::shared_ptr<Turtle> turtle) \n\nEntry Data: void World::move_turtle_random_jump(std::shared_ptr<Turtle> turtle){\n  // same as move turtle but instead of turtle-> move() we are using turtle->jumpRandom(RNG_Engine)\n  Patch &turtle_current_patch = get_patch(turtle->getX(), turtle->getY());\n  std::pair<int,int> new_coords = turtle->jumpRandom(RNG_Engine);\n\n  Patch& target_patch = get_patch(new_coords.first, new_coords.second);\n    if (turtle_current_patch == target_patch){\n    return;\n  } else if (target_patch.is_at_capacity()){\n    turtle->execute_move(false);\n  }\n  else{\n    turtle->execute_move(true);\n    turtle_current_patch.remove_turtle(turtle);\n    target_patch.add_turtle(turtle);\n  }\n}\n"
      ],
      "492": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void World::turtle_wiggle(std::shared_ptr<Turtle> turtle) \n\nEntry Data: void World::turtle_wiggle(std::shared_ptr<Turtle> turtle){\n  // wiggles the turtles heading, then moves forward along the new heading for 1 unit\n  turtle->wiggle(RNG_Engine);\n  move_turtle(turtle);\n}"
      ],
      "493": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void World::kill_turtle(std::shared_ptr<Turtle> turtle) \n\nEntry Data: void World::kill_turtle(std::shared_ptr<Turtle> turtle){\n  // removed turtle from its patch\n  turtle->set_is_alive(false);\n  Patch &turtle_current_patch = get_patch(turtle->getX(), turtle->getY());\n  turtle_current_patch.remove_turtle(turtle);\n  turtle.reset();\n}\n"
      ],
      "494": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void World::updateTurtleVectors() \n\nEntry Data: void World::updateTurtleVectors(){\n    for(auto& turtle : all_turtles_to_kill){\n      if (std::shared_ptr<Bacteria> bacteria = std::dynamic_pointer_cast<Bacteria>(turtle)) {\n        all_bacterias.erase(std::remove(begin(all_bacterias), end(all_bacterias), bacteria), end(all_bacterias));\n        bacteria.reset();\n      } else if (std::shared_ptr<Antibodies> antibody = std::dynamic_pointer_cast<Antibodies>(turtle)) {\n        all_antibodies.erase(std::remove(begin(all_antibodies), end(all_antibodies), antibody), end(all_antibodies));\n      } else if (std::shared_ptr<FDCs> fdc = std::dynamic_pointer_cast<FDCs>(turtle)) {\n        all_fdcs.erase(std::remove(begin(all_fdcs), end(all_fdcs), fdc), end(all_fdcs));\n        fdc.reset();\n      } else if (std::shared_ptr<NaiveBCell> naive_b_cell = std::dynamic_pointer_cast<NaiveBCell>(turtle)) {\n        all_naive_b_cells.erase(std::remove(begin(all_naive_b_cells), end(all_naive_b_cells), naive_b_cell), end(all_naive_b_cells));\n        naive_b_cell.reset();\n      } else if (std::shared_ptr<ActivatedBCell> activated_b_cell = std::dynamic_pointer_cast<ActivatedBCell>(turtle)) {\n        all_activated_b_cells.erase(std::remove(begin(all_activated_b_cells), end(all_activated_b_cells), activated_b_cell),end(all_activated_b_cells));\n        activated_b_cell.reset();\n      } else if (std::shared_ptr<GCBCell> gcb_cell = std::dynamic_pointer_cast<GCBCell>(turtle)) {\n        all_gcb_cells.erase(std::remove(begin(all_gcb_cells), end(all_gcb_cells), gcb_cell), end(all_gcb_cells));\n        gcb_cell.reset();\n      } else if (std::shared_ptr<SLPlasmaCell> sl_plasma_cell = std::dynamic_pointer_cast<SLPlasmaCell>(turtle)) {\n        all_sl_plasma_cells.erase(std::remove(begin(all_sl_plasma_cells), end(all_sl_plasma_cells), sl_plasma_cell), end(all_sl_plasma_cells));\n        sl_plasma_cell.reset();\n      } else if (std::shared_ptr<LLPlasmaCell> ll_plasma_cell = std::dynamic_pointer_cast<LLPlasmaCell>(turtle)) {\n        all_ll_plasma_cells.erase(std::remove(begin(all_ll_plasma_cells), end(all_ll_plasma_cells), ll_plasma_cell), end(all_ll_plasma_cells));\n        ll_plasma_cell.reset();\n      } else if (std::shared_ptr<MemBCell> mem_b_cell = std::dynamic_pointer_cast<MemBCell>(turtle)) {\n        all_mem_b_cells.erase(std::remove(begin(all_mem_b_cells), end(all_mem_b_cells), mem_b_cell), end(all_mem_b_cells));\n        mem_b_cell.reset();\n      } else if (std::shared_ptr<BregCell> breg_cell = std::dynamic_pointer_cast<BregCell>(turtle)) {\n        all_breg_cells.erase(std::remove(begin(all_breg_cells), end(all_breg_cells), breg_cell), end(all_breg_cells));\n        breg_cell.reset();\n      } else if (std::shared_ptr<TfhCell> tfh_cell = std::dynamic_pointer_cast<TfhCell>(turtle)) {\n        all_tfh_cells.erase(std::remove(begin(all_tfh_cells), end(all_tfh_cells), tfh_cell), end(all_tfh_cells));\n        tfh_cell.reset();\n      } else if (std::shared_ptr<Th0Cell> th0_cell = std::dynamic_pointer_cast<Th0Cell>(turtle)) {\n        all_th0_cells.erase(std::remove(begin(all_th0_cells), end(all_th0_cells), th0_cell), end(all_th0_cells));\n        th0_cell.reset();\n      } else if (std::shared_ptr<Th1Cell> th1_cell = std::dynamic_pointer_cast<Th1Cell>(turtle)){\n        all_th1_cells.erase(std::remove(begin(all_th1_cells), end(all_th1_cells), th1_cell), end(all_th1_cells));\n        th1_cell.reset();\n      } else if (std::shared_ptr<Th2Cell> th2_cell = std::dynamic_pointer_cast<Th2Cell>(turtle)) {\n        all_th2_cells.erase(std::remove(begin(all_th2_cells), end(all_th2_cells), th2_cell), end(all_th2_cells));\n        th2_cell.reset();\n      }\n      // std::cout<<'turtle ID '<<turtle->getID()<<' use count '<<turtle.use_count()<<std::endl;\n      turtle.reset();\n\n    }\n    all_turtles_to_kill.clear();\n\n    // erasing the turtle weak pointers that are now a null pointer because they have been reset\n    all_turtles.erase(std::remove_if(all_turtles.begin(), all_turtles.end(),\n    [](const std::weak_ptr<Turtle>& wp) {     //lambda function to check if weak pointer is expired (aka killed and reset() has been called)\n        // if (wp.expired()){std::cout<<'Deleting expired Turtle'<<std::endl;}\n        return wp.expired();\n      }),\n    all_turtles.end());\n}\n"
      ],
      "495": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void World::setup() \n\nEntry Data: void World::setup(){\n  // This function initializes the global variables and setus up the world\n  global_ID_counter = 0;\n  step = 0;\n  time = 1;\n  setup_patches(); // Initializing the patches\n\n  // Clear all existing entities\n  all_turtles.clear();\n  all_bacterias.clear();\n  all_antibodies.clear();\n  all_fdcs.clear();\n  all_naive_b_cells.clear();\n  all_activated_b_cells.clear();\n  all_gcb_cells.clear();\n  all_sl_plasma_cells.clear();\n  all_ll_plasma_cells.clear();\n  all_mem_b_cells.clear();\n  all_breg_cells.clear();\n  all_tfh_cells.clear();\n  all_th0_cells.clear();\n  all_th1_cells.clear();\n  all_th2_cells.clear();\n\n  // Check if random runs is false, then set seed\n  if (!RandomRuns) {\n      set_rng_seed(RNG_SEED);\n      std::cout<<'printing test RNG'<<std::endl;\n      for (size_t i = 0; i < 10; i++) {\n        std::cout<<RNG_Engine()<<std::endl;\n      }\n  }\n\n  // Sets up the world structure\n  // In NetLogo, the center of the world is 0,0\n  // In C++, the bottom left of the world is 0,0\n  // Therefore, we need to shift the patches\n  int center_x = std::ceil(WORLD_WIDTH / 2);   //added the std::floor() because only in odd world sizes\n  int center_y = std::ceil(WORLD_HEIGHT / 2);  //will it matter, but 101 is odd\n\n  // Paracortex zone\n  for (int x = center_x - 200; x <= center_x + 200; x++) {\n      for (int y = center_y - 200; y <= center_y + 200; y++) {\n          if (x >= 0 && x < WORLD_WIDTH && y >= 0 && y < WORLD_HEIGHT) {\n              Patch& p = get_patch(x, y);\n              p.setPatchType(1);\n              p.setColor('gray');\n          }\n      }\n  }\n\n  // Follicle zone\n  for (int x = center_x - 49; x <= center_x + 49; x++) {\n      for (int y = center_y - 49; y <= center_y + 49; y++) {\n          if (x >= 0 && x < WORLD_WIDTH && y >= 0 && y < WORLD_HEIGHT) {\n            // Calculate the distance from the center\n            int dist_x = center_x - x;\n            int dist_y = center_y - y;\n            if (dist_x * dist_x + dist_y * dist_y <= 49 * 49) {  // Radius of 49 units\n                Patch& p = get_patch(x, y);\n                p.setPatchType(0);\n                p.setColor('black');\n            }\n          }\n      }\n  }\n\n// Rendering orientation squares\n  // get_patch(0,0).setColor('pink');\n  // get_patch(0,WORLD_HEIGHT-1).setColor('green');\n  // get_patch(WORLD_WIDTH-1,0).setColor('yellow');\n  // get_patch(WORLD_WIDTH-1,WORLD_HEIGHT-1).setColor('orange');\n  //\n  // std::cout<<'Angle To neighbor 0-TL(degrees)'<<atan2(1,-1) * 180/M_PI<<std::endl;\n  // std::cout<<'Angle To neighbor 1-T(degrees)'<<atan2(1,0) * 180/M_PI<<std::endl;\n  // std::cout<<'Angle To neighbor 2-TR(degrees)'<<atan2(1,1) * 180/M_PI<<std::endl;\n  // std::cout<<'Angle To neighbor 3-L(degrees)'<<atan2(0,-1) * 180/M_PI<<std::endl;\n  // std::cout<<'Angle To neighbor 4-R(degrees)'<<atan2(0,1) * 180/M_PI<<std::endl;\n  // std::cout<<'Angle To neighbor 5-BL(degrees)'<<atan2(-1,-1) * 180/M_PI<<std::endl;\n  // std::cout<<'Angle To neighbor 6-B(degrees)'<<atan2(-1,0) * 180/M_PI<<std::endl;\n  // std::cout<<'Angle To neighbor 7-BR(degrees)'<<atan2(-1,1) * 180/M_PI<<std::endl;\n  //\n  // get_patch(0,0).setColor('pink');\n  // get_patch(1,0).setColor('blue');\n  // get_patch(2,0).setColor('green');\n  // get_patch(0,1).setColor('black');\n  // get_patch(1,1).setColor('white');\n  // get_patch(2,1).setColor('brown');\n  // get_patch(0,2).setColor('yellow');\n  // get_patch(1,2).setColor('orange');\n  // get_patch(2,2).setColor('cyan');\n\n  // Exit from follicle\n  for (int y = center_y - 5; y <= center_y + 5; y++) {\n      if (y >= 0 && y < WORLD_HEIGHT) {\n          Patch& p1 = get_patch(center_x - 50, y);\n          Patch& p2 = get_patch(center_x - 49, y);\n          p1.setPatchType(2);\n          p1.setColor('red');\n          p2.setPatchType(2);\n          p2.setColor('red');\n      }\n  }\n\n  //I added this part. In order to initialize 100 (or however many) FDCs that are apropriate distances from the center and also from eachother, we need to generate their positions intentionally, and not randomly. To do this we should generate all of them ahead of time, then create the cells.\n  std::vector<std::pair<int, int>> FDCcoordinates = generateCoordinates(100, center_x, center_y, 30, 3);\n  // creates 100 coordinates, centered on our origin (center_x/y) within 30 units of the center, and each at least 3 units apart from eachother\n\n  // using the above command, I told gpt to recreate the pmn example from the general world.h example, but doing a different initialization command\n  for (size_t i = 0; i < FDCcoordinates.size(); i++) {\n      int x = FDCcoordinates[i].first;  // x-coordinate of the FDC\n      int y = FDCcoordinates[i].second; // y-coordinate of the FDC\n      auto fdc = std::make_shared<FDCs>(x, y, global_ID_counter++); // creating the actual FDC turtle\n      Patch& patch = get_patch(x, y); // get patch to add the turtle to\n\n      // Set shape and color for the FDC\n      fdc->setShape('square');\n      fdc->setColor('brown');\n\n      std::weak_ptr<Turtle> fdc_weak_ptr = fdc;   // creating a weak pointer to give to all turtles vector so that deleting fdc object kills it in the turtle list\n\n      // adding new turtle to all turtles vector, and specific type vector\n      all_turtles.push_back(fdc_weak_ptr);\n      all_fdcs.push_back(fdc);\n      patch.add_turtle(fdc); // add turtle to patch\n  }\n\n  int NUM_TFH_CELLS_TO_ADD = 50;\n  for (int i = 0; i < NUM_TFH_CELLS_TO_ADD; i++) {\n      // generate a new coordinate and verify if the patch at the coordinate is of type 1\n      std::pair<int, int> coord;\n      // do while loop. executes the codeblock once, then checks. while condition, it executes the block again then checks. Same thing as a normal while loop, but it will always do it at least once\n      do {\n          int random_x = RNG_Engine() % WORLD_WIDTH; //random X and Y position\n          int random_y = RNG_Engine() % WORLD_HEIGHT;\n          coord = std::make_pair(random_x, random_y);\n      } while (get_patch(coord.first, coord.second).getPatchType() != 1);\n      auto tfhCell = std::make_shared<TfhCell>(coord.first, coord.second, global_ID_counter++, RNG_Engine()%360); // create the TfhCell\n      Patch& patch = get_patch(coord.first, coord.second); // get patch to add the turtle to\n\n      // Set cell variables\n      tfhCell->setTimeAlive(-1000);\n      tfhCell->setShape('square');\n      tfhCell->setColor('cyan');\n      tfhCell->setCxcr5Level(11);\n      tfhCell->setCcr7Level(6);\n      tfhCell->setEbi2rLevel(5);\n      tfhCell->setBcellBindingStatus(false);\n\n      std::weak_ptr<Turtle> tfhCell_weak_ptr = tfhCell; // creating a weak pointer to give to all turtles vector\n\n      // adding new turtle to all turtles vector, and specific type vector\n      all_turtles.push_back(tfhCell_weak_ptr);\n      all_tfh_cells.push_back(tfhCell);\n      patch.add_turtle(tfhCell); // add turtle to patch\n  }\n\n  int NUM_TH1_CELLS_TO_ADD = 10;\n  for (int i = 0; i < NUM_TH1_CELLS_TO_ADD; i++) {\n      std::pair<int, int> coord;\n      do {\n          int random_x = RNG_Engine() % WORLD_WIDTH; //random X and Y position\n          int random_y = RNG_Engine() % WORLD_HEIGHT;\n          coord = std::make_pair(random_x, random_y);\n      } while (get_patch(coord.first, coord.second).getPatchType() != 1);\n\n      auto th1Cell = std::make_shared<Th1Cell>(coord.first, coord.second, global_ID_counter++, RNG_Engine()%360); // create the Th1Cell\n      Patch& patch = get_patch(coord.first, coord.second); // get patch to add the turtle to\n\n      // Set cell variables\n      th1Cell->setTimeAlive(-1000);\n      th1Cell->setShape('square');\n      th1Cell->setColor('blue');\n      th1Cell->setCxcr5Level(0);\n      th1Cell->setCcr7Level(2);\n      th1Cell->setEbi2rLevel(2);\n      th1Cell->setBcellBindingStatus(false);\n\n      std::weak_ptr<Turtle> th1Cell_weak_ptr = th1Cell; // creating a weak pointer to give to all turtles vector\n\n      // adding new turtle to all turtles vector, and specific type vector\n      all_turtles.push_back(th1Cell_weak_ptr);\n      all_th1_cells.push_back(th1Cell);\n      patch.add_turtle(th1Cell); // add turtle to patch\n  }\n\n  int NUM_TH2_CELLS_TO_ADD = 50;\n  for (int i = 0; i < NUM_TH2_CELLS_TO_ADD; i++) {\n      std::pair<int, int> coord;\n      do {\n          int random_x = RNG_Engine() % WORLD_WIDTH; //random X and Y position\n          int random_y = RNG_Engine() % WORLD_HEIGHT;\n          coord = std::make_pair(random_x, random_y);\n      } while (get_patch(coord.first, coord.second).getPatchType() != 1);\n\n      auto th2Cell = std::make_shared<Th2Cell>(coord.first, coord.second, global_ID_counter++, RNG_Engine()%360); // create the Th2Cell\n      Patch& patch = get_patch(coord.first, coord.second); // get patch to add the turtle to\n\n      // Set cell variables\n      th2Cell->setTimeAlive(-1000);\n      th2Cell->setShape('square');\n      th2Cell->setColor('blue');\n      th2Cell->setCxcr5Level(0);\n      th2Cell->setCcr7Level(2);\n      th2Cell->setEbi2rLevel(2);\n      th2Cell->setBcellBindingStatus(false);\n\n      std::weak_ptr<Turtle> th2Cell_weak_ptr = th2Cell; // creating a weak pointer to give to all turtles vector\n\n      // adding new turtle to all turtles vector, and specific type vector\n      all_turtles.push_back(th2Cell_weak_ptr);\n      all_th2_cells.push_back(th2Cell);\n      patch.add_turtle(th2Cell); // add turtle to patch\n  }\n\n\n\n  // Initialize global variables and counters\n  days_passed = 0;\n\n  // Reset ticks or equivalent time step counter\n  step = 0;\n}\n"
      ],
      "496": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void World::go()  \n\nEntry Data: void World::go() {\n  bool print_test = false;\n  calculateIncomingTNFaIL6Level();\n  simulateBackgroundInflammation();\n\n  // Update days_passed based on the step value.\n  setDaysPassed(step / 48);\n\n  spawnBCell();\n  // spawnTh0Cell();\n\n  // Cytokine release from paracortex\n  for (int x = 0; x < WORLD_WIDTH; x++) {\n      for (int y = 0; y < WORLD_HEIGHT; y++) {\n          Patch& p = get_patch(x, y);\n          if (p.getPatchType() == 1) {\n              p.setCcl19Level(p.getCcl19Level() + 2);\n              p.setEbi2Level(p.getEbi2Level() + 2);\n          }\n      }\n  }\n\n  // Cytokine release from follicle exit\n  for (int x = 0; x < WORLD_WIDTH; x++) {\n      for (int y = 0; y < WORLD_HEIGHT; y++) {\n          Patch& p = get_patch(x, y);\n          if (p.getPatchType() == 2) {\n              p.setS1pLevel(p.getS1pLevel() + 2);\n          }\n      }\n  }\n  if (print_test){std::cout<<'go 1'<<std::endl;}\n  // Ask all agents to perform their functions\n  for (auto& fdc : all_fdcs){fdcFunction(fdc);}\n  if (print_test){std::cout<<'go 2'<<std::endl;}\n\n  for (auto& naiveBCell : all_naive_b_cells){naiveBCellFunction(naiveBCell);}\n  if (print_test){std::cout<<'go 3'<<std::endl;}\n\n  for (auto& activatedBCell : all_activated_b_cells){activatedBCellFunction(activatedBCell);}\n  if (print_test){std::cout<<'go 4'<<std::endl;}\n\n  for (auto& gcbCell : all_gcb_cells){gc_b_cell_function(gcbCell);}\n  if (print_test){std::cout<<'go 5'<<std::endl;}\n\n  for (auto& llPlasmaCell : all_ll_plasma_cells){ll_plasma_cell_function(llPlasmaCell);}\n  if (print_test){std::cout<<'go 6'<<std::endl;}\n\n  for (auto& slPlasmaCell : all_sl_plasma_cells){sl_plasma_cell_function(slPlasmaCell);}\n  if (print_test){std::cout<<'go 7'<<std::endl;}\n\n  for (auto& memBCell : all_mem_b_cells){memBCellFunction(memBCell);}\n  if (print_test){std::cout<<'go 8'<<std::endl;}\n\n  for (auto& antibody : all_antibodies){antibodiesFunction(antibody);}\n  if (print_test){std::cout<<'go 9'<<std::endl;}\n\n  for (auto& bregCell : all_breg_cells){bregFunction(bregCell);}\n  if (print_test){std::cout<<'go 10'<<std::endl;}\n\n  for (auto& tfhCell : all_tfh_cells){tfhCellFunction(tfhCell);}\n  if (print_test){std::cout<<'go 11'<<std::endl;}\n\n  for (auto& th0Cell : all_th0_cells){th0CellFunction(th0Cell);}\n  if (print_test){std::cout<<'go 12'<<std::endl;}\n\n  for (auto& th1Cell : all_th1_cells){th1CellFunction(th1Cell);}\n  if (print_test){std::cout<<'go 13'<<std::endl;}\n\n  for (auto& th2Cell : all_th2_cells){th2CellFunction(th2Cell);}\n  if (print_test){std::cout<<'go 14'<<std::endl;}\n\n  for (auto& bacteria : all_bacterias){bacteriaFunction(bacteria);}\n  if (print_test){std::cout<<'go 15'<<std::endl;}\n\n  update_chemokine_gradient();\n  if (print_test){std::cout<<'go 16'<<std::endl;}\n  check_overall_cd21_expression();\n  if (print_test){std::cout<<'go 17'<<std::endl;}\n\n  // Check if autoinoculate is active\n  if(AUTOINOCULATE) {\n      if(step == AUTOINOCULATE_FIRST_TIME) {\n        std::cout<<'INNOCULATING FOR THE FIRST TIME NOWWWWWW'<<std::endl;\n          auto_inoculate(FIRST_EXPOSURE_AMOUNT);\n      }\n      else if(step == AUTOINOCULATE_SECOND_TIME) {\n        std::cout<<'INNOCULATING FOR THE SECONDDDDDDDDDD TIME NOWWWWWW'<<std::endl;\n          auto_inoculate(SECOND_EXPOSURE_AMOUNT);\n      }\n      else if(step == STOP_EXPOSURE_TIME) {\n          // stop();  // You might want to stop the simulation\n      }\n  }\n\n  // Increase the step (equivalent to NetLogo's tick)\n  step++;\n  // end of go\n  updateTurtleVectors(); // need to update turtle positions/delete dead turtles\n  if (print_test){std::cout<<'go 18'<<std::endl;}\n\n}\n"
      ],
      "497": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void World::update_chemokine_gradient() \n\nEntry Data: void World::update_chemokine_gradient(){\n  diffuse();\n  evaporate();\n}\n"
      ],
      "498": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void World::diffuse() \n\nEntry Data: void World::diffuse(){\n  // need to diffuse values from patches out to neighboring patches\n  double factor_for_neighbors = 1.0/8; //normally eight neighbors in a 2D grid\n\n  // follow this example format for each diffusing variable\n  for (auto& patch_row : all_patches) {  // reset temp_var\n    for (auto& patch : patch_row){\n      patch.setTempS1pLevel(0);\n      patch.setTempCxcl13Level(0);\n      patch.setTempCcl19Level(0);\n      patch.setTempEbi2Level(0);\n      patch.setTempIl2(0);\n      patch.setTempIl4(0);\n      patch.setTempIl6(0);\n      patch.setTempIl10(0);\n      patch.setTempIl12(0);\n      patch.setTempIl15(0);\n      patch.setTempIl21(0);\n      patch.setTempIfG(0);\n      patch.setTempIfA(0);\n      patch.setTempTnfA(0);\n      patch.setTempTgfB(0);\n    }\n  }\n  // start with Endotoxin\n  // get totals for neighbors\n  for (auto& patch_row : all_patches){\n    for (auto& center_patch : patch_row){\n      int center_patch_x_pos = center_patch.getX();\n      int center_patch_y_pos = center_patch.getY();\n      if (!TOROIDAL_WORLD){\n        bool x_edge = (center_patch_x_pos==0 || center_patch_x_pos==(WORLD_WIDTH-1));\n        bool y_edge = (center_patch_y_pos==0|| center_patch_y_pos==(WORLD_HEIGHT-1));\n        if(x_edge && y_edge){factor_for_neighbors = (1.0/3);}\n        else if (x_edge || y_edge){factor_for_neighbors=(1.0/5);}\n        else{factor_for_neighbors=(1.0/8);}\n      }\n      for (int i=-1; i<2; i++){\n        for (int j=-1; j<2; j++){\n          if (i==0 && j==0) { // skipping center cell\n            continue;\n          }\n          int neighbor_x, neighbor_y;\n          if (TOROIDAL_WORLD){\n            neighbor_x = fmod((center_patch_x_pos + i), WORLD_WIDTH); // getting modulo of position + x/y to wrap around toroidal world\n            neighbor_y = fmod((center_patch_y_pos + j), WORLD_HEIGHT);\n          } else{\n            neighbor_x = center_patch_x_pos + i;\n            neighbor_y = center_patch_y_pos + j;\n            // if not toroidal world and neighbor is out of bounds (ie we are on the edge) then continue\n            if ((neighbor_y >= WORLD_HEIGHT) || (neighbor_y < 0)){continue;}\n            if ((neighbor_x >= WORLD_WIDTH) || (neighbor_x < 0)){continue;}\n          }\n          auto& neighbor_patch = get_patch(neighbor_x, neighbor_y);\n\n          // evenly adding the amount diffused out from the center patch to neighbor patches\n          neighbor_patch.setTempCxcl13Level(neighbor_patch.getTempCxcl13Level() + center_patch.getCxcl13Level() * factor_for_neighbors * CXCL13_LEVEL_DIFFUSION_FACTOR);\n          neighbor_patch.setTempCcl19Level(neighbor_patch.getTempCcl19Level() + center_patch.getCcl19Level() * factor_for_neighbors * CCL19_LEVEL_DIFFUSION_FACTOR);\n          neighbor_patch.setTempEbi2Level(neighbor_patch.getTempEbi2Level() + center_patch.getEbi2Level() * factor_for_neighbors * EBI2_LEVEL_DIFFUSION_FACTOR);\n          neighbor_patch.setTempS1pLevel(neighbor_patch.getTempS1pLevel() + center_patch.getS1pLevel() * factor_for_neighbors * S1P_LEVEL_DIFFUSION_FACTOR);\n          neighbor_patch.setTempIl2(neighbor_patch.getTempIl2() + center_patch.getIl2() * factor_for_neighbors * IL2_DIFFUSION_FACTOR);\n          neighbor_patch.setTempIl4(neighbor_patch.getTempIl4() + center_patch.getIl4() * factor_for_neighbors * IL4_DIFFUSION_FACTOR);\n          neighbor_patch.setTempIl6(neighbor_patch.getTempIl6() + center_patch.getIl6() * factor_for_neighbors * IL6_DIFFUSION_FACTOR);\n          neighbor_patch.setTempIl10(neighbor_patch.getTempIl10() + center_patch.getIl10() * factor_for_neighbors * IL10_DIFFUSION_FACTOR);\n          neighbor_patch.setTempIl12(neighbor_patch.getTempIl12() + center_patch.getIl12() * factor_for_neighbors * IL12_DIFFUSION_FACTOR);\n          neighbor_patch.setTempIl15(neighbor_patch.getTempIl15() + center_patch.getIl15() * factor_for_neighbors * IL15_DIFFUSION_FACTOR);\n          neighbor_patch.setTempIl21(neighbor_patch.getTempIl21() + center_patch.getIl21() * factor_for_neighbors * IL21_DIFFUSION_FACTOR);\n          neighbor_patch.setTempIfG(neighbor_patch.getTempIfG() + center_patch.getIfG() * factor_for_neighbors * IF_G_DIFFUSION_FACTOR);\n          neighbor_patch.setTempIfA(neighbor_patch.getTempIfA() + center_patch.getIfA() * factor_for_neighbors * IF_A_DIFFUSION_FACTOR);\n          neighbor_patch.setTempTnfA(neighbor_patch.getTempTnfA() + center_patch.getTnfA() * factor_for_neighbors * TNF_A_DIFFUSION_FACTOR);\n          neighbor_patch.setTempTgfB(neighbor_patch.getTempTgfB() + center_patch.getTgfB() * factor_for_neighbors * TGF_B_DIFFUSION_FACTOR);\n        }\n      }\n    }\n  }\n  // set Endotoxin on each patch from the temp var, then reset tempvar\n  for (auto& patch_row : all_patches){\n    for (auto& patch : patch_row){\n      // new total is starting amount minus the amount that diffused out, plus the amount that diffused in from neighbors\n      patch.setS1pLevel((patch.getS1pLevel() * (1 - S1P_LEVEL_DIFFUSION_FACTOR)) + patch.getTempS1pLevel());\n      // std::cout<<'S1p level in diffusion: '<<patch.getTempS1pLevel()<<std::endl;\n      patch.setTempS1pLevel(0); // resetting\n\n      patch.setCxcl13Level((patch.getCxcl13Level() * (1 - CXCL13_LEVEL_DIFFUSION_FACTOR)) + patch.getTempCxcl13Level());\n      patch.setTempCxcl13Level(0); // resetting\n\n      patch.setCcl19Level((patch.getCcl19Level() * (1 - CCL19_LEVEL_DIFFUSION_FACTOR)) + patch.getTempCcl19Level());\n      patch.setTempCcl19Level(0); // resetting\n\n      patch.setEbi2Level((patch.getEbi2Level() * (1 - EBI2_LEVEL_DIFFUSION_FACTOR)) + patch.getTempEbi2Level());\n      patch.setTempEbi2Level(0); // resetting\n\n      patch.setIl2((patch.getIl2() * (1 - IL2_DIFFUSION_FACTOR)) + patch.getTempIl2());\n      patch.setTempIl2(0); // resetting\n\n      patch.setIl4((patch.getIl4() * (1 - IL4_DIFFUSION_FACTOR)) + patch.getTempIl4());\n      patch.setTempIl4(0); // resetting\n\n      patch.setIl6((patch.getIl6() * (1 - IL6_DIFFUSION_FACTOR)) + patch.getTempIl6());\n      patch.setTempIl6(0); // resetting\n\n      patch.setIl10((patch.getIl10() * (1 - IL10_DIFFUSION_FACTOR)) + patch.getTempIl10());\n      patch.setTempIl10(0); // resetting\n\n      patch.setIl12((patch.getIl12() * (1 - IL12_DIFFUSION_FACTOR)) + patch.getTempIl12());\n      patch.setTempIl12(0); // resetting\n\n      patch.setIl15((patch.getIl15() * (1 - IL15_DIFFUSION_FACTOR)) + patch.getTempIl15());\n      patch.setTempIl15(0); // resetting\n\n      patch.setIl21((patch.getIl21() * (1 - IL21_DIFFUSION_FACTOR)) + patch.getTempIl21());\n      patch.setTempIl21(0); // resetting\n\n      patch.setIfG((patch.getIfG() * (1 - IF_G_DIFFUSION_FACTOR)) + patch.getTempIfG());\n      patch.setTempIfG(0); // resetting\n\n      patch.setIfA((patch.getIfA() * (1 - IF_A_DIFFUSION_FACTOR)) + patch.getTempIfA());\n      patch.setTempIfA(0); // resetting\n\n      patch.setTnfA((patch.getTnfA() * (1 - TNF_A_DIFFUSION_FACTOR)) + patch.getTempTnfA());\n      patch.setTempTnfA(0); // resetting\n\n      patch.setTgfB((patch.getTgfB() * (1 - TGF_B_DIFFUSION_FACTOR)) + patch.getTempTgfB());\n      patch.setTempTgfB(0); // resetting\n    }\n  }\n}\n"
      ],
      "499": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: void World::evaporate() \n\nEntry Data: void World::evaporate(){\n  // evaporate variables off of all patches\n  for (auto& patch_row : all_patches) {\n    for (auto& patch : patch_row){\n      // Endotoxin as an example, amount to set is current amount times the evaporation factor\n      patch.setCxcl13Level(patch.getCxcl13Level() * CXCL13_EVAPORATION_FACTOR);\n      patch.setCcl19Level(patch.getCcl19Level() * CCL19_EVAPORATION_FACTOR);\n      patch.setEbi2Level(patch.getEbi2Level() * EBI2_EVAPORATION_FACTOR);\n      patch.setS1pLevel(patch.getS1pLevel() * S1P_EVAPORATION_FACTOR);\n      patch.setIl2(patch.getIl2() * IL2_EVAPORATION_FACTOR);\n      patch.setIl4(patch.getIl4() * IL4_EVAPORATION_FACTOR);\n      patch.setIl6(patch.getIl6() * IL6_EVAPORATION_FACTOR);\n      patch.setIl10(patch.getIl10() * IL10_EVAPORATION_FACTOR);\n      patch.setIl12(patch.getIl12() * IL12_EVAPORATION_FACTOR);\n      patch.setIl15(patch.getIl15() * IL15_EVAPORATION_FACTOR);\n      patch.setIl21(patch.getIl21() * IL21_EVAPORATION_FACTOR);\n      patch.setIfG(patch.getIfG() * IF_G_EVAPORATION_FACTOR);\n      patch.setIfA(patch.getIfA() * IF_A_EVAPORATION_FACTOR);\n      patch.setTnfA(patch.getTnfA() * TNF_A_EVAPORATION_FACTOR);\n      patch.setTgfB(patch.getTgfB() * TGF_B_EVAPORATION_FACTOR);\n    }\n  }\n}\n"
      ],
      "500": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name:   template <typename CellType>\n  int countCells(int patchX, int patchY) \n\nEntry Data:   template <typename CellType>\n  int countCells(int patchX, int patchY){\n    int total_count = 0;\n    Patch& current_patch = get_patch(patchX, patchY);\n    std::vector<std::shared_ptr<Turtle>> turtles_on_patch = current_patch.getTurtlesHere();\n\n    for (const auto& turtle : turtles_on_patch){\n      if (std::dynamic_pointer_cast<CellType>(turtle)) {\n        // The turtle is of type we are looking for, increment count\n        total_count++;\n      }\n    }\n    return total_count;\n  }"
      ],
      "501": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: template <typename CellType>\n  bool checkTNFStatus(CellType& cell) \n\nEntry Data: template <typename CellType>\n  bool checkTNFStatus(CellType& cell){\n// if returns true, that means this cell needs to die\n    Patch& current_patch = get_patch(cell->getX(), cell->getY());\n    current_patch.setTnfA(current_patch.getTnfA() - .01);\n    cell->setTnfaStimulation(current_patch.getTnfA() * 100);\n\n    return (cell->getTnfaStimulation() > cell->getTnfaThreshold());\n  }"
      ],
      "502": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: template <typename CellType>\n  bool checkBregStatus(CellType& cell) \n\nEntry Data: template <typename CellType>\n  bool checkBregStatus(CellType& cell){\n    Patch& current_patch = get_patch(cell->getX(), cell->getY());\n    if (cell->getProBreg() > cell->getBregThreshold()){\n      return true;\n    } else{\n      float amount_to_set = (current_patch.getIl6() + current_patch.getIl21()) * 45;\n      cell->setProBreg(amount_to_set);\n      return false;\n    }\n  }"
      ],
      "503": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: template <typename CellType>\n  std::shared_ptr<BregCell> turnIntoBreg(CellType& cell) \n\nEntry Data: template <typename CellType>\n  std::shared_ptr<BregCell> turnIntoBreg(CellType& cell){\n    // std::cout<<std::endl<<std::endl<<std::endl<<std::endl;\n    // std::cout<<'turning into breg'<<std::endl;\n    // std::cout<<'original cell ID '<<cell->getID()<< ' and location '<<cell<<std::endl;\n    CellType placeholder = cell;\n    // std::cout<<'placeholder cell ID '<<placeholder->getID()<<' and location '<<placeholder<<std::endl;\n\n    std::shared_ptr<BregCell> breg = std::make_shared<BregCell>(cell->getX(), cell->getY(), global_ID_counter++, cell->getHeading());\n    // std::shared_ptr<BregCell> breg = std::make_shared<BregCell>(0, 0, 99,0);\n    // std::cout<<'breg ID '<<breg->getID()<<' and location '<<breg<<std::endl;\n    // std::cout<<'original cell ID '<<cell->getID()<< ' and location '<<cell<<std::endl;\n    // std::cout<<'placeholder cell ID '<<placeholder->getID()<<' and location '<<placeholder<<std::endl;\n    // global_ID_counter++;\n    // std::cout<<'breg ID '<<breg->getID()<<' and location '<<breg<<std::endl;\n    // std::cout<<'original cell ID '<<cell->getID()<< ' and location '<<cell<<std::endl;\n    // std::cout<<'placeholder cell ID '<<placeholder->getID()<<' and location '<<placeholder<<std::endl;\n\n\n\n    breg->copy_other_turtle_attributes(cell);\n    breg->setSize(1);\n    breg->setShape('circle');\n    breg->setColor('violet');\n    breg->setS1pr1Level(0);\n    breg->setCxcr5Level(10);\n    breg->setTimeAlive(0);\n\n    std::weak_ptr<Turtle> breg_weak_ptr = breg;\n    all_turtles.push_back(breg_weak_ptr);\n    all_breg_cells.push_back(breg);\n    get_patch(cell->getX(), cell->getY()).add_turtle(breg);\n    // std::cout<<'breg ID '<<breg->getID()<<std::endl;\n    // std::cout<<'original cell ID '<<cell->getID()<<std::endl;\n    kill(cell);\n    return breg;\n  }"
      ],
      "504": [
            "Represent this C++ function from a custom port of Netlogo for retrieval:",
            "Here is a block of relevant code from the C++ implementation:\nSection Name: template <typename CellType>\n  void chemotaxis(CellType& cell) \n\nEntry Data: template <typename CellType>\n  void chemotaxis(CellType& cell){\n    // std::cout<<'chemotaxing'<<std::endl;\n    // std::cout<<'my location' <<cell->getX()<<', '<< cell->getY()<<std::endl;\n    Patch& current_patch = get_patch(cell->getX(), cell->getY());\n    double final_heading = cell->getHeading();\n    std::shared_ptr<Bacteria> test_cell = std::dynamic_pointer_cast<Bacteria>(cell);\n    bool print_test = false;\n    // print_test = (test_cell != NULL);\n    // if (print_test){print_test = bool(test_cell->getID() == 120);}\n    // if (print_test){test_cell->setColor('orange'); test_cell->setShape('bug');}\n    // if (print_test){\n    //   print_test = (cell->getX() == WORLD_WIDTH);\n    // }\n    if(print_test){std::cout<<'1st time: ID '<<cell->getID()<<', HEADING '<<cell->getHeading()<<std::endl;};\n\n    std::vector<Patch> neighbors;\n    int count = 0;\n    for (int x = -1; x < 2; x++) {\n      for (int y = -1; y < 2; y++) {\n        if (x==0 && y==0){continue;}\n\n        if (!TOROIDAL_WORLD){\n          if ((current_patch.getX() + x) >= WORLD_WIDTH){continue;}\n          if ((current_patch.getX() + x) < 0){continue;}\n          if ((current_patch.getY() + y) >= WORLD_HEIGHT){continue;}\n          if ((current_patch.getY() + x) < 0){continue;}\n        }\n        // std::cout<<'neighbor '<<count<<' location'<<cell->getX() + x<<', '<< cell->getY()+ y <<std::endl;\n        count ++;\n        neighbors.push_back(get_patch(current_patch.getX() + x, current_patch.getY() + y));\n      }\n    }\n    if (print_test){std::cout<<'chemotaxing2:    '<<count<<std::endl;}\n\n    int random_max_patch_ind = RNG_Engine() % neighbors.size();\n    Patch max_patch = neighbors[random_max_patch_ind];\n\n    double s1pr1_weight = cell->getS1pr1Level() / 100.0;\n    double max_s1p = 0;\n    for (auto neighbor_patch: neighbors){\n      if (neighbor_patch.getS1pLevel() > max_s1p) {\n        // std::cout<<'Changing max patch'<<std::endl;\n        max_s1p = neighbor_patch.getS1pLevel();\n        max_patch = get_patch(neighbor_patch.getX(), neighbor_patch.getY());\n      }\n    }\n    double angle_absolute_to_s1p = cell->angle_to(get_patch(max_patch.getX(), max_patch.getY()));\n    double angle_relative_to_s1p = angle_absolute_to_s1p - cell->getHeading();\n    if (angle_relative_to_s1p<-180){angle_relative_to_s1p+=360;}\n    if (angle_relative_to_s1p>180){angle_relative_to_s1p-=360;}\n    angle_relative_to_s1p = fmod(angle_relative_to_s1p,360);\n\n    if (print_test){std::cout<<'my current position is '<<test_cell->getX()<<', '<<test_cell->getY()<<std::endl;\n      std::cout<<'Max Patch position is '<<max_patch.getX()<<', '<<max_patch.getY()<<std::endl;}\n\n\n    if(print_test){\n      std::cout<<'2nd  time: ID '<<cell->getID()<<', HEADING '<< final_heading;\n      std::cout<<' s1pr1_weight '<<s1pr1_weight<<std::endl;\n      std::cout<<'angle_absolute_to_s1p  '<<angle_absolute_to_s1p<<std::endl;\n      std::cout<<'angle_relative_to_s1p  '<<angle_relative_to_s1p<<std::endl;\n    };\n    final_heading += angle_relative_to_s1p*s1pr1_weight;\n\n\n    // random_max_patch_ind = RNG_Engine() % neighbors.size();\n    // max_patch = neighbors[random_max_patch_ind];\n    double s1pr2_weight = cell->getS1pr2Level() / 100.0;\n    double max_s1pr2 = 0;\n    for (auto neighbor_patch: neighbors){\n        if (neighbor_patch.getS1pLevel() > max_s1pr2) {\n            max_s1pr2 = neighbor_patch.getS1pLevel();\n            max_patch = get_patch(neighbor_patch.getX(), neighbor_patch.getY());\n        }\n    }\n    double angle_absolute_to_s1pr2 = cell->angle_to(get_patch(max_patch.getX(), max_patch.getY()));\n    double angle_relative_to_s1pr2 = angle_absolute_to_s1pr2 - cell->getHeading();\n    if (angle_relative_to_s1pr2<-180){angle_relative_to_s1pr2+=360;}\n    if (angle_relative_to_s1pr2>180){angle_relative_to_s1pr2-=360;}\n    angle_relative_to_s1pr2 = fmod(angle_relative_to_s1pr2,360);\n\n    if (print_test){std::cout<<'my current position is '<<test_cell->getX()<<', '<<test_cell->getY()<<std::endl;\n      std::cout<<'Max Patch position is '<<max_patch.getX()<<', '<<max_patch.getY()<<std::endl;}\n\n\n    final_heading += angle_relative_to_s1pr2*s1pr2_weight;\n    if(print_test){std::cout<<'3rd time: ID '<<cell->getID()<<', HEADING '<<final_heading<<' s1pr2_weight '<<s1pr2_weight<<std::endl;\n    std::cout<<'angle_absolute_to_s1pr2  '<<angle_absolute_to_s1pr2<<std::endl;\n    std::cout<<'angle_relative_to_s1pr2  '<<angle_relative_to_s1pr2<<std::endl;\n    };\n\n\n    //for CxCR5/cxcl13\n    // random_max_patch_ind = RNG_Engine() % neighbors.size();\n    // max_patch = neighbors[random_max_patch_ind];\n    double cxcr5_weight = cell->getCxcr5Level() / 100.0;\n    double max_cxcl13 = 0;\n    for (auto neighbor_patch: neighbors){\n        if (neighbor_patch.getCxcl13Level() > max_cxcl13) {\n            max_cxcl13 = neighbor_patch.getCxcl13Level();\n            max_patch = get_patch(neighbor_patch.getX(), neighbor_patch.getY());\n        }\n    }\n    double angle_absolute_to_cxcl13 = cell->angle_to(get_patch(max_patch.getX(), max_patch.getY()));\n    double angle_relative_to_cxcl13 = angle_absolute_to_cxcl13 - cell->getHeading();\n    if (angle_relative_to_cxcl13<-180){angle_relative_to_cxcl13+=360;}\n    if (angle_relative_to_cxcl13>180){angle_relative_to_cxcl13-=360;}\n    angle_relative_to_cxcl13 = fmod(angle_relative_to_cxcl13,360);\n\n    if (print_test){std::cout<<'my current position is '<<test_cell->getX()<<', '<<test_cell->getY()<<std::endl;\n      std::cout<<'Max Patch position is '<<max_patch.getX()<<', '<<max_patch.getY()<<std::endl;}\n\n    final_heading += angle_relative_to_cxcl13*cxcr5_weight;\n    if(print_test){std::cout<<'4th time: ID '<<cell->getID()<<', HEADING '<< final_heading<<' CXCR5 weight '<<cxcr5_weight<<std::endl;\n    std::cout<<'angle_absolute_to_cxcl13  '<<angle_absolute_to_cxcl13<<std::endl;\n    std::cout<<'angle_relative_to_cxcl13  '<<angle_relative_to_cxcl13<<std::endl;\n    };\n\n    // for ccr7/ccl19\n    // random_max_patch_ind = RNG_Engine() % neighbors.size();\n    // max_patch = neighbors[random_max_patch_ind];\n    double cccl7_weight = cell->getCcr7Level() / 100.0;\n    double max_ccl19 = 0;\n    for (auto neighbor_patch: neighbors){\n        if (neighbor_patch.getCcl19Level() > max_ccl19) {\n            max_ccl19 = neighbor_patch.getCcl19Level();\n            max_patch = get_patch(neighbor_patch.getX(), neighbor_patch.getY());\n        }\n    }\n    double angle_absolute_to_ccl19 = cell->angle_to(get_patch(max_patch.getX(), max_patch.getY()));\n    double angle_relative_to_ccl19 = angle_absolute_to_ccl19 - cell->getHeading();\n    if (angle_relative_to_ccl19<-180){angle_relative_to_ccl19+=360;}\n    if (angle_relative_to_ccl19>180){angle_relative_to_ccl19-=360;}\n    angle_relative_to_ccl19 = fmod(angle_relative_to_ccl19,360);\n\n    if (print_test){std::cout<<'my current position is '<<test_cell->getX()<<', '<<test_cell->getY()<<std::endl;\n      std::cout<<'Max Patch position is '<<max_patch.getX()<<', '<<max_patch.getY()<<std::endl;}\n\n    final_heading += angle_relative_to_ccl19*cccl7_weight;\n    if(print_test){std::cout<<'5th time: ID '<<cell->getID()<<', HEADING '<< final_heading<<' CCcL7 weight '<<cccl7_weight<<std::endl;\n    std::cout<<'angle_absolute_to_ccl19  '<<angle_absolute_to_ccl19<<std::endl;\n    std::cout<<'angle_relative_to_ccl19  '<<angle_relative_to_ccl19<<std::endl;\n    };\n\n    // For ebi2r_level\n    // random_max_patch_ind = RNG_Engine() % neighbors.size();\n    // max_patch = neighbors[random_max_patch_ind];\n    double ebi2r_weight = cell->getEbi2rLevel() / 100.0;\n    double max_ebi2 = 0;\n    for (auto neighbor_patch: neighbors){\n        if (neighbor_patch.getEbi2Level() > max_ebi2) {\n\n            max_ebi2 = neighbor_patch.getEbi2Level();\n            max_patch = get_patch(neighbor_patch.getX(), neighbor_patch.getY());\n        }\n    }\n    double angle_absolute_to_ebi2 = cell->angle_to(get_patch(max_patch.getX(), max_patch.getY()));\n    double angle_relative_to_ebi2 = angle_absolute_to_ebi2 - cell->getHeading();\n    if (angle_relative_to_ebi2<-180){angle_relative_to_ebi2+=360;}\n    if (angle_relative_to_ebi2>180){angle_relative_to_ebi2-=360;}\n    angle_relative_to_ebi2 = fmod(angle_relative_to_ebi2,360);\n\n    if (print_test){std::cout<<'my current position is '<<test_cell->getX()<<', '<<test_cell->getY()<<std::endl;\n      std::cout<<'Max Patch position is '<<max_patch.getX()<<', '<<max_patch.getY()<<std::endl;}\n\n\n\n    final_heading += angle_relative_to_ebi2 * ebi2r_weight;\n    if(print_test){std::cout<<'6th time: ID '<<cell->getID()<<', HEADING '<< final_heading<<' ebi2r_weight'<<ebi2r_weight<<std::endl;\n    std::cout<<'angle_absolute_to_ebi2  '<<angle_absolute_to_ebi2<<std::endl;\n    std::cout<<'angle_relative_to_ebi2  '<<angle_relative_to_ebi2<<std::endl;\n    };\n\n\n    if (final_heading > 180){final_heading-=360;}\n    if (final_heading < -180){final_heading+=360;}\n  cell->setHeading((int)final_heading%(360));\n  // cell->setHeading(180);\n  if(print_test){std::cout<<'FINAL TIME: ID '<<cell->getID()<<', HEADING '<<cell->getHeading()<<std::endl<<std::endl<<std::endl<<std::endl;};\n\n  // std::cout<<'END CHEMOTAXING'<<std::endl;\n  }\n\n\n};"
      ]
}