{
      "0": {
            "code_block": "\n// agent.h\n#ifndef AGENT_H\n#define AGENT_H\n\n\n#include <iostream>\n#include <fstream>\n#include <vector>\n\nclass Agent {\n    protected:\n    Agent(int x, int y) : x(x), y(y) {}\n    private:\n    std::string color = \"\";\n    int alpha = 255;\n    int x;\n    int y;\n    public:\n\n    virtual double getX() const {return x;};\n    virtual double getY() const {return y;};\n    virtual void setX(int newX){x=newX;};\n    virtual void setY(int newY){y=newY;};\n    void setColor(std::string newColor){color = newColor;};\n    std::string getColor() const {return color;};\n    void setOpacity(int newAlpha){alpha = newAlpha;};\n    int getOpacity() const {return alpha;};\n};\n\n\n#endif\n"
      },
      "1": {
            "code_block": "\n// parameters.h\n#ifndef PARAMETERS_H\n#define PARAMETERS_H\n\nconst bool RENDERING = true;\nconst bool SAVING_DATA = false;\nconst bool TURTLE_CONTINOUS_MOVEMENT = false;\n\nconst int RNG_SEED=108;\nconst int NUM_STEPS = 2000;\n\n\nconst static int WORLD_WIDTH = 101;\nconst static int WORLD_HEIGHT = 101;\nconst int PATCH_MAX_CAPACITY = 10;\nconst int MAX_RANDOM_DISTANCE = 100;\n\n#endif"
      },
      "2": {
            "code_block": "\n// patch.h\n#ifndef PATCH_H\n#define PATCH_H\n\n#include 'parameters.h'\n#include 'agent.h'\n#include 'turtle.h'\n#include <memory>\n\n// class Turtle;\n\nclass Patch : public Agent{\n  private:\n    std::vector<std::shared_ptr<Turtle>> turtles_here;\n    \n    double temp_var; //placeholder for diffusion totals before updating\n\n  public:\n    Patch():Agent(0,0){setColor('red');};               // base patch color is red\n    Patch(int xCoord, int yCoord) : Agent(xCoord, yCoord) {setColor('red');};\n        \n    void add_turtle(std::shared_ptr<Turtle> turtle_to_add);\n    void remove_turtle(std::shared_ptr<Turtle> turtle_to_remove);\n    void display();\n    bool is_at_capacity();\n\n    void setTempVar(double newVal){temp_var=newVal};\n    double getTempVar() const {return temp_var};\n    \n    // patch is the same iff the x and y positions are equal\n    bool operator== (Patch& that){return (this->getX()==that.getX() && this->getY()==that.getY());};\n    \n    \n    // Add more patch specific functions below for the particular implementation of a net logo model being ported\n    \n    \n};\n\n\n\n#endif"
      },
      "3": {
            "code_block": "\n// rendering.h\n#ifndef RENDERING_H\n#define RENDERING_H\n\n//Using SDL and standard IO\n#include <SDL2/SDL.h>\n#include <stdlib.h>\n#include <string>\n#include <stdio.h>\n#include <tuple>\n#include 'world.h'\n\n#include 'parameters.h'\n\nclass RenderingEngine {\nprivate:\n  /* data */\n  SDL_Window* window;\n  SDL_Renderer* renderer;\n  World* myWorld;\n\n\npublic:\n  const static int GRID_SIZE = 10;\n  const static int SCREEN_WIDTH = WORLD_WIDTH * GRID_SIZE;\n  const static int SCREEN_HEIGHT = WORLD_WIDTH * GRID_SIZE;\n  RenderingEngine();\n  RenderingEngine(World *world);\n  virtual ~RenderingEngine ();\n  \n  std::tuple<int, int, int> getColor(const std::string& color);\n  void drawCircle(double centerX, double centerY, double radius=GRID_SIZE/2, const std::string& color='red', int alpha=SDL_ALPHA_OPAQUE);\n  void drawSquare(int x, int y, int size=GRID_SIZE, const std::string& color='red', int alpha=SDL_ALPHA_OPAQUE);\n  void drawLine(double startX, double startY, double endX, double endY, const std::string& color='black', int alpha=SDL_ALPHA_OPAQUE);\n  void setBackgroundColor(const std::string& color='red');\n  void render();\n  \n  void renderAllPatches();\n  void renderAllTurtles();\n};\n\n\n#endif"
      },
      "4":{
            "code_block":"\n// turtle.h\n#ifndef TURTLE_H\n#define TURTLE_H\n\n#include \"agent.h\"\n#include <random>\n\nclass Turtle : public Agent{\n    public :\n    Turtle(int x, int y, int ID_num, int heading=0) : Agent(x, y), ID_num(ID_num), heading(heading) {x_dec=x; y_dec=y;};\n    virtual ~Turtle() = default;\n\n    private:\n    int ID_num;\n    int heading;\n    int age;\n    float x_dec; //x and y decimal coordinates\n    float y_dec;\n    float temp_x; // temporary coords for turtle move, before actual turtle coords are moved in case destination patch is full.\n    float temp_y; // Turtle cant know about the world cause circular dependency in #include, so world will handle turtle movement between patches\n    \n\n    // add more variables that apply to all turtles here for the specific netlogo model being ported\n\n\n    public:\n    std::pair<int,int> move(float distance=1);\n    std::pair<int,int> jumpRandom(std::mt19937 &RNG_Engine);\n    void execute_move(bool didMove);\n    void wiggle(std::mt19937 &RNG_Engine);\n    void display();\n\n    int getID() const {return ID_num;};\n    \n    void setHeading(int newHeading){heading = newHeading;};\n    int getHeading() const {return heading;};\n    \n    void setAge(int newAge){age=newAge;};\n    void getAge() const { return age;};\n    \n    float get_x_dec() const {return x_dec;}       // already has regular getX() and getY() from agent parent class\n    float get_y_dec() const {return y_dec;}\n\n\n    bool operator== (const Turtle& turt2){return this->ID_num==turt2.ID_num;};\n    bool operator== (const Turtle* turt2){return this->ID_num==turt2->ID_num;};\n    \n    // add more turtle specific functions below. These are functions that will apply to all turtle types, not a single breed\n\n};\n\n\n#endif\n"
      },
      "5": {
            "code_block": "\n// world.h\n#ifndef WORLD_H\n#define WORLD_H\n\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <vector>\n#include <stdlib.h>\n#include <memory>\n#include <algorithm>\n\n#include 'parameters.h'\n#include 'agent.h'\n#include 'patch.h'\n#include 'turtle.h'\n\n\nclass World {\nprivate:\n  std::mt19937 RNG_Engine;\n  int global_ID_counter;  //ID counter for creating new turtles to make sure each has a unique ID\n  int step;\n  int time;\n  int loop_run;\n  \n  Patch all_patches[WORLD_WIDTH][WORLD_HEIGHT];\n  \n  void set_rng_seed(int newSeed){RNG_Engine.seed(newSeed);}\n  void add_patch(int x, int y);\n\npublic:\n  std::vector<std::weak_ptr<Turtle>> all_turtles;\n  // include vectors of shared_ptr's of other turtle sub-types here\n  // for example:   std::vector<std::shared_ptr<Pmn>> all_pmns;\n\n  \n  World(){};\n  \n  Patch& get_patch(int x, int y);\n  Patch& getPatchAhead(std::shared_ptr<Turtle> turtle, float distance=1);\n  Patch& getPatchAheadRight(std::shared_ptr<Turtle> turtle, float distance=1);\n  Patch& getPatchAheadLeft(std::shared_ptr<Turtle> turtle, float distance=1);\n\n  void setup_patches();\n  void display_patches();\n  \n  void add_turtle(int x, int y, int id, int heading=0);\n  void move_turtle(std::shared_ptr<Turtle> turtle);\n  void move_turtle_random_jump(std::shared_ptr<Turtle> turtle);\n  void turtle_wiggle(std::shared_ptr<Turtle> turtle);\n  \n  void kill_turtle(std::shared_ptr<Turtle> turtle);\n  \n  // templated function to kill any turtle or agent\n  template <typename T>\n  void kill(std::shared_ptr<T> &ptr){\n    kill_turtle(ptr);\n    ptr.reset();\n  }\n\n  void updateTurtleVectors();\n\n  void setup();\n  void go();\n    \n  void diffuse();\n  void evaporate();\n  \n};\n\n\n#endif"
      }
}