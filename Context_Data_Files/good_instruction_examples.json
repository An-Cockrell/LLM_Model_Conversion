{
      "\"\\nbreed [ injs inj ]\\nbreed [ pmns pmn ]\\nbreed [ bands band ]\\nbreed [ pmn-marrows pmn-marrow ]\\nbreed [ monos mono ]\\nbreed [ mono-marrows mono-marrow ]\\nbreed [ gen-mono-marrows gen-mono-marrow ]\\nbreed [ TH0-germs TH0-germ ]\\nbreed [ TH0s TH0 ]\\nbreed [ TH1s TH1 ]\\nbreed [ TH1-germs TH1-germ ]\\nbreed [ TH2s TH2 ]\\nbreed [ TH2-germs TH2-germ ]\\nbreed [ NKs NK ]\\n\": \"1. The breeds are defined using the `breed` keyword at the beginning of the script.\\n      2. Each breed is given a name, the first input defines the name of the turtleset associated with the breed, and the second input defines the name of a single member of the breed.\\n      3. These breeds serve to group different types of turtles together, allowing for easier manipulation of specific groups, when using `ask` commands.\\n\\n      None of the provided code snippet initializes or performs operations on any of these variables. It only defines the breeds and their respective names. The code snippet provided is not sufficient to determine the exact actions taken on these variables if any were present.\"\n": "To integrate the provided breeds into the existing simulation framework, you'll need to follow a series of steps that involve creating corresponding breed-specific vector of shared pointers for each breed.\n        ```cpp\n        // world.h\n        std::vector<std::shared_ptr<Turtle>> all_turtles; // General turtle vector\n        std::vector<std::shared_ptr<Turtle>> all_injs;   // Vector for inj breed\n        std::vector<std::shared_ptr<Turtle>> all_pmns;   // Vector for pmn breed\n        std::vector<std::shared_ptr<Turtle>> all_bands;  // Vector for bands breed\n        // ... and so on for other breeds\n\n        ```\n      \n\n        2. In the `World` class, create a function to handle the creation, tracking, and return of a single instance of a specific breed. Add these functions for each breed in the `world.h` header file:\n\n        ```cpp\n        // world.h\n        std::shared_ptr<Turtle> create_inj_turtle(int x, int y);\n        std::shared_ptr<Turtle> create_pmn_turtle(int x, int y);\n        std::shared_ptr<Turtle> create_band_turtle(int x, int y);\n        // ... and so on for other breeds\n        ```\n        \n        3. Implement these functions in the `World` class's source file (`.cpp`) to create, initialize, and add breed-specific instances to the corresponding vectors and patch, similar to the following:\n        \n        ```cpp\n        // world.cpp\n        std::shared_ptr<Turtle> World::create_inj_turtle(int x, int y) {\n           std::shared_ptr<Turtle> inj_turtle = std::make_shared<Turtle>(x, y, global_ID_counter++);\n       std::weak_ptr<Turtle> inj_weak_ptr = pmn_turtle   // creating a weak pointer to give to all turtles vector\n           all_turtles.push_back(inj_weak_ptr);\n           all_injs.push_back(inj_turtle);\n        \n           Patch& patch = get_patch(x, y);\n           patch.add_turtle(inj_turtle);\n        \n           return inj_turtle;\n        }\n        \n        std::shared_ptr<Turtle> World::create_pmn_turtle(int x, int y) {\n           std::shared_ptr<Turtle> pmn_turtle = std::make_shared<Turtle>(x, y, global_ID_counter++);\n            std::weak_ptr<Turtle> pmn_weak_ptr = pmn_turtle   // creating a weak pointer to give to all turtles vector\n        \n           all_turtles.push_back(pmn_weak_ptr);\n           all_pmns.push_back(pmn_turtle);\n        \n           Patch& patch = get_patch(x, y);\n           patch.add_turtle(pmn_turtle);\n        \n           return pmn_turtle;\n        }\n        \n        // ... and so on for other breeds\n\n        ```\n        \n",
      "\"\\nturtles-own [\\n     wbc-roll        ; selectins\\n     wbc-stick       ; integrens\\n     wbc-migrate     ; diapedesis\\n     pmn-age         ; life span\\n     pmn-pcd         ; programmed cell death\\n     mono-age        ; life span\\n     TNFr\\n     IL-1r\\n     TH0-age\\n     TH1-age\\n     TH2-age\\n     activation\\n     pro-TH1\\n     pro-TH2\\n     rTH1           ; random holder for pro-TH1\\n     rTH2           ; random holder for pro-TH2\\n    ]\\n\\n\\n\": \"The given NetLogo code block uses the `turtles-own` command to define several variables that will be unique to each turtle in the model. Here's an overview of the code and the variables it declares for each turtle:\\n\\n1. The overall function of the code is to define various variables that will be unique to each turtle in the NetLogo model.\\n\\nVariables for each turtle:\\n1. wbc-roll: Represents the selectin molecules on the surface of the white blood cells (WBCs) for rolling along the vessel walls.\\n2. wbc-stick: Represents the integrin molecules on the surface of WBCs that enable them to stick to the vessel walls during diapedesis.\\n3. wbc-migrate: Represents the ability of WBCs to migrate from the vessels into the tissues.\\n4. pmn-age: Represents the life span of a PMN (neutrophil) turtle.\\n5. pmn-pcd: Represents the programmed cell death (apoptosis) of a PMN turtle.\\n6. mono-age: Represents the life span of a monocyte turtle.\\n7. TNFr: Represents the TNF receptors on the surface of the turtles.\\n8. IL-1r: Represents the IL-1 receptors on the surface of the turtles.\\n9. TH0-age: Represents the age of a TH0 (helper T cell) turtle.\\n10. TH1-age: Represents the age of a TH1 (helper T cell) turtle.\\n11. TH2-age: Represents the age of a TH2 (helper T cell) turtle.\\n12. activation: Represents the activation status of a turtle.\\n13. pro-TH1: Represents the level of pro-TH1 cytokines produced by the turtle.\\n14. pro-TH2: Represents the level of pro-TH2 cytokines produced by the turtle.\\n15. rTH1: A random holder for pro-TH1 values.\\n16. rTH2: A random holder for pro-TH2 values.\\n\\nThese variables allow each turtle to have its own unique state and behavior. They store important information such as cell age, receptor levels, and production rates, which can be updated during the simulation.\"\n": "To integrate these turtle-specific variables into your C++ simulation framework, you'll need to add member variables to your Turtle class corresponding to each of the declared turtle-specific variables. Here's a suggested way to proceed:\n\n1. First, declare the new member variables in the Turtle class within `turtle.h`. Add these declarations after your existing `protected` member variables:\n\n```cpp\n// turtle.h\nclass Turtle final : public Agent {\nprivate:\n    // Existing protected member variables\n    double wbc_roll;            // Selectins for rolling along vessel walls\n    double wbc_stick;           // Integrins for sticking to vessel walls during diapedesis\n    double wbc_migrate;         // Ability to migrate from the vessels into tissues\n    int pmn_age;               // PMN life span\n    int pmn_pcd;               // Programmed cell death of PMN\n    int mono_age;              // Monocyte life span\n    double TNFr;                // TNF receptors\n    double IL_1r;               // IL-1 receptors\n    int TH0_age;               // TH0 age\n    int TH1_age;               // TH1 age\n    int TH2_age;               // TH2 age\n    bool activation;           // Activation status\n    double pro_TH1;            // Pro-TH1 cytokines production\n    double pro_TH2;            // Pro-TH2 cytokines production\n    double rTH1;               // Random holder for pro-TH1\n    double rTH2;               // Random holder for pro-TH2\n\n    // Remaining member variables and functions\n}\n```\n\n2. Afterward, initialize the new member variables in the Turtle class constructor within `turtle.cpp`. Add the following code in the constructor after the initializations of existing `protected` member variables:\n\n```cpp\n// turtle.cpp\nTurtle::Turtle(int x, int y, int ID_num, int heading)\n    : Agent(x, y), ID_num(ID_num), heading(heading),\n      wbc_roll(0.0), wbc_stick(0.0), wbc_migrate(0.0),\n      pmn_age(0), pmn_pcd(0), mono_age(0),\n      TNFr(0.0), IL_1r(0.0), TH0_age(0), TH1_age(0), TH2_age(0),\n      activation(false), pro_TH1(0.0), pro_TH2(0.0), rTH1(0.0), rTH2(0.0) {\n    // Existing constructor code\n}\n```\n\nThese new member variables will enable you to store turtle-specific information for each agent and update them as the simulation progresses. You can extend the Agent class methods to interact with these new member variables or create custom methods in the Turtle class to manage their behaviors.",
      "\"\\npatches-own [\\n     oxy             ; oxygen\\n     ec-activation\\n     ec-roll         ; rolling\\n     ec-stick        ; sticking\\n     ec-migrate      ; migration\\n     cytotox         ; o2rads and enzymes\\n     infection       ; infectious vector\\n     endotoxin\\n     PAF\\n     TNF\\n     sTNFr\\n     IL-1\\n     sIL-1r\\n     IL-1ra\\n     INF-g\\n     IL-2\\n     IL-4\\n     IL-6\\n     IL-8\\n     IL-10\\n     IL-12\\n     GCSF\\n     ]\\n\\n\": \"The given NetLogo code block uses the `patches-own` command to define several variables that will be unique to each patch (cellular environment) in the model. Here's an overview of the code and the variables it declares for each patch:\\n\\n1. The overall function of the code is to define various variables that will be unique to each patch in the NetLogo model.\\n\\nVariables for each patch:\\n1. oxy: Represents the oxygen concentration on the patch.\\n2. ec-activation: Represents the activation status of the patch.\\n3. ec-roll: Represents the ability of cells to roll on the patch.\\n4. ec-stick: Represents the ability of cells to stick to the patch.\\n5. ec-migrate: Represents the ability of cells to migrate on the patch.\\n6. cytotox: Represents oxygen radicals and enzymes present on the patch.\\n7. infection: Represents the infectious vector on the patch.\\n8. endotoxin: Represents the endotoxin presence on the patch.\\n9. PAF: Represents platelet activating factor on the patch.\\n10. TNF: Represents TNF (Tumor Necrosis Factor) concentration on the patch.\\n11. sTNFr: Represents soluble TNF receptors (sTNFr) on the patch.\\n12. IL-1: Represents IL-1 (Interleukin 1) concentration on the patch.\\n13. sIL-1r: Represents soluble IL-1 receptors (sIL-1r) on the patch.\\n14. IL-1ra: Represents IL-1 receptor antagonist (IL-1ra) on the patch.\\n15. INF-g: Represents interferon-\\u03b3 (IFN-g) concentration on the patch.\\n16. IL-2: Represents IL-2 (Interleukin 2) concentration on the patch.\\n17. IL-4: Represents IL-4 (Interleukin 4) concentration on the patch.\\n18. IL-6: Represents IL-6 (Interleukin 6) concentration on the patch.\\n19. IL-8: Represents IL-8 (Interleukin 8) concentration on the patch.\\n20. IL-10: Represents IL-10 (Interleukin 10) concentration on the patch.\\n21. IL-12: Represents IL-12 (Interleukin 12) concentration on the patch.\\n22. GCSF: Represents Granulocyte Colony-stimulating Factor (GCSF) concentration on the patch.\\n\\nThese variables allow each patch to have its own unique state, representing the local environment that the cells interact with. They store important information such as oxygen levels, cytokine concentrations, and activation status, which can affect the behavior of the cells. \\n\\nKeep in mind that this code snippet only declares the variables and does not provide any information about how they are updated or used during the simulation.\"\n": "To accommodate these patch-specific variables into your C++ simulation framework, you can add member variables to your Patch class in a similar fashion to the previous response for `turtles-own`. Here's a suggested way to proceed:\n\n1. First, declare the new member variables in the Patch class within `patch.h`. Add these declarations after your existing `private` member variables:\n\n```cpp\n// patch.h\nclass Patch : public Agent {\nprivate:\n    // Existing private member variables\n    double oxy;            // Oxygen concentration\n    bool ec_activation;    // Activation status of the patch\n    double ec_roll;        // Ability of cells to roll\n    double ec_stick;       // Ability of cells to stick\n    double ec_migrate;     // Ability of cells to migrate\n    double cytotox;       // O2rads and enzymes\n    double infection;     // Infectious vector\n    double endotoxin;     // Endotoxin presence\n    double PAF;            // Platelet activating factor\n    double TNF;            // TNF (Tumor Necrosis Factor) concentration\n    double sTNFr;          // Soluble TNF receptors (sTNFr)\n    double IL_1;           // IL-1 concentration\n    double sIL_1r;         // Soluble IL-1 receptors (sIL-1r)\n    double IL_1ra;         // IL-1 receptor antagonist (IL-1ra)\n    double INF_g;          // Interferon-\u03b3 (IFN-g) concentration\n    double IL_2;           // IL-2 concentration\n    double IL_4;           // IL-4 concentration\n    double IL_6;           // IL-6 concentration\n    double IL_8;           // IL-8 concentration\n    double IL_10;          // IL-10 concentration\n    double IL_12;          // IL-12 concentration\n    double GCSF;           // Granulocyte Colony-stimulating Factor (GCSF) concentration\n\n    // Remaining member variables and functions\n}\n```\n\n2. Afterward, initialize the new member variables in the Patch class constructor within `patch.cpp`. Add following code in the constructor after the initializations of existing `private` member variables:\n\n```cpp\n// patch.cpp\nPatch::Patch(int x, int y)\n    : Agent(x, y),\n      oxy(0.0), ec_activation(false), ec_roll(0.0), ec_stick(0.0), ec_migrate(0.0),\n      cytotox(0.0), infection(0.0), endotoxin(0.0), PAF(0.0), TNF(0.0),\n      sTNFr(0.0), IL_1(0.0), sIL_1r(0.0), IL_1ra(0.0), INF_g(0.0),\n      IL_2(0.0), IL_4(0.0), IL_6(0.0), IL_8(0.0), IL_10(0.0),\n      IL_12(0.0), GCSF(0.0) {\n    // Existing constructor code\n}\n```\n\nThese new member variables will enable you to store patch-specific information for each cellular environment. You can extend the Agent class methods to interact with these new member variables or create custom methods in the Patch class to manage their behaviors. \n\nKeep in mind that while you've now declared and initialized the variables, you'll need to update them during the runtime of your simulation to properly use these variables.",
      "\"\\nto setup\\n  cp ct\\n  clear-all-plots\\n\\n  reset-ticks\\n  set system-oxy 0\\n  set oxy-deficit 0\\n  set total-infection 0\\n  set total-TNF 0\\n  set total-sTNFr 0\\n  set total-IL-10 0\\n  set total-GCSF 0\\n  set step 0\\n  set time 1\\n  set loop-run 0\\n  set total-pro-TH1 0\\n  set total-pro-TH2 0\\n\\n  ask patches\\n     [set oxy 100\\n     ]\\n  set-default-shape turtles \\\"circle\\\"\\n  create-pmns 500\\n     [set color white\\n      repeat 10\\n        [jump random 100\\n        ]\\n      set pmn-age random 50\\n      set wbc-roll 1\\n      set wbc-stick 0\\n      set wbc-migrate 0\\n      set pmn-pcd 10\\n     ]\\n\\n  create-monos 50\\n    [set color green\\n     repeat 10\\n       [jump random 100\\n       ]\\n     set mono-age random 500\\n     set TNFr 0\\n     set IL-1r 0\\n     set activation 0\\n    ]\\n\\n  Create-TH1s 50\\n    [set color blue\\n     repeat 10\\n       [jump random 100\\n       ]\\n     set TH1-age random 100\\n    ]\\n\\n  create-TH2s 50\\n    [set color cyan\\n     repeat 10\\n       [jump random 100\\n       ]\\n     set TH2-age random 100\\n    ]\\n\\n  create-pmn-marrows 100\\n    [set color brown\\n     repeat 10\\n       [jump random 100\\n       ]\\n    ]\\n\\n  create-mono-marrows 100\\n    [set color orange\\n     repeat 10\\n       [jump random 100\\n       ]\\n    ]\\n\\n  create-TH0-germs 100\\n    [set color red\\n     repeat 10\\n       [jump random 100\\n       ]\\n    ]\\n\\n  create-TH1-germs 100\\n    [set color red\\n     repeat 10\\n       [jump random 100\\n       ]\\n    ]\\n\\n  create-TH2-germs 100\\n    [set color red\\n     repeat 10\\n       [jump random 100\\n       ]\\n    ]\\n\\n  set-scale-pc\\n  set system-oxy 10201.0\\n  set oxy-deficit 0\\n\\n  if vid:recorder-status = \\\"recording\\\" [ vid:record-view ]\\n\\nend\\n\": \"The given NetLogo code block is the setup function for a multi-turtle simulation model. It initializes the system setup and creates various turtle breeds and their initial populations. Here's an overview of the code and its functions:\\n\\n1. The overall function of the code is to set up the NetLogo simulation environment and create the initial conditions for the simulation.\\n\\nFirst, the code clears all existing plots and resets the tick counter. Then, it sets several global and patch variables to default values.\\n\\nNext, the code sets the default shape of turtles to a circle and creates five different breeds (pmns, monos, TH1s, TH2s, pmn-marrows, mono-marrows, TH0-germs, TH1-germs, and TH2-germs). For each breed, it sets the color and creates a specified number of turtles. Turtles are given unique initial positions by jumping to random locations.\\n\\nThe pmns breed has 500 turtles created, each with a random age (between 1 and 50), white color, and default wbc-roll, wbc-stick, wbc-migrate, pmn-pcd values.\\n\\nThe monos breed has 50 turtles created, each with a random age (between 1 and 500), green color, and default TNFr, IL-1r, and activation values.\\n\\nThe TH1s, TH2s, pmn-marrows, mono-marrows, TH0-germs, TH1-germs, and TH2-germs breeds have 50 turtles each created, with random positions and age.\\n\\nAfter creating the turtles, the code sets the patches' oxygen level to 100 and sets the default shape of turtles to circles. The function then sets the system's oxygen level to a large value for the simulation and checks if the video recorder is running, starting recording if it is.\\n\\nThe function sets the plot scaling and finally increases the system oxygen level to a high value (10201.0). This setup function initializes the turtles, their properties, and the simulation environment for further processing in the model.\"\n":"Based on the provided description and your code structure, here are step-by-step instructions for implementing the NetLogo code snippet:\n\n1. Clear all existing plots and reset the tick counter:\n   - You can create a helper function in your `World` class that clears all plots and resets the tick counter. The implementation will depend on how you have implemented plots in your simulation framework.\n\n2. Set global variables to default values:\n   - Set `system-oxy`, `oxy-deficit`, `total-infection`, `total-TNF`, `total-sTNFr`, `total-IL-10`, `total-GCSF`, `step`, `time`, `loop-run`, `total-pro-TH1`, and `total-pro-TH2` to their respective default values, such as 0 or 1, as needed.\n\n3. Set the default shape of turtles to a circle:\n   - In the `Turtle` class, add a method to set the default shape of the turtle, or, if you already have a method to change the shape, call it with the \"circle\" parameter. Do this with all the properties that are set.\n\n4. Create various turtle breeds and their initial populations:\n\n   - Loop through the required number of turtles for the `pmns` breed, create each turtle at a random location, set their initial properties, and add them to the `all_pmns` vector.\n\n     ```cpp\n     for (int i = 0; i < 500; ++i) {\n        double randomAge = rand() % 50 + 1;\n        double randomX = rand() % WORLD_WIDTH;\n        double randomY = rand() % WORLD_HEIGHT;\n\n        std::shared_ptr<Turtle> pmnTurtle = create_pmn_turtle(randomX, randomY);\n        pmnTurtle->setColor(Turtle::Color::white);\n        pmnTurtle->setAge(\"pmn-age\", randomAge);\n        pmnTurtle->setWBCroll(\"wbc-roll\", 1);\n        pmnTurtle->setWBCstick(\"wbc-stick\", 0);\n        pmnTurtle->setWBCmigrate(\"wbc-migrate\", 0);\n        pmnTurtle->setPMNpcd(\"pmn-pcd\", 10);\n\n        all_pmns.push_back(pmnTurtle);\n     }\n     ```\n\n   - Similarly, create loops for the `monos`, `TH1s`, `TH2s`, `pmn-marrows`, `mono-marrows`, `TH0-germs`, `TH1-germs`, and `TH2-germs` breeds, setting their respective initial properties, colors, and vector containers.\n\n5. Set patches' oxygen level to 100:\n   - Loop through all patches in the `Patches` container and set the `oxy` property of each patch to 100.\n\n6. Check if the video recorder is running and start recording if it is:\n   - This code block is specific to NetLogo and can be skipped in a C++ implementation unless you have a separate video recorder, in which case, add a condition to check if it's already running.\n\n7. Finally, increase the system oxygen level to 10201.0:\n   - Set the `system-oxy` global variable to 10201.0.\n\nMake sure to place the code blocks inside the `setup` function in your `World` class for a clean and organized framework.",
      "\"to pmn-function\\n  ifelse wbc-migrate > 0\\n    [pmn-burst\\n    ]\\n    [ifelse ((ec-roll > 3) and (wbc-roll = 1))\\n       [pmn-sniff\\n       ]\\n       [repeat 2\\n         [pmn-sniff]\\n       ]\\n     if (TNF + PAF > 1)\\n       [set wbc-stick IL-1\\n        set IL-1ra IL-1ra + 1\\n       ]\\n     if ((wbc-stick >= 1) and (ec-stick >= 100))\\n       [set wbc-migrate (TNF + IL-1 + GCSF - IL-10)\\n        set color yellow\\n       ]\\n     set pmn-age pmn-age - 1\\n     if pmn-age < 0\\n       [die]\\n    ]\\n\\nend\\n\": \"The NetLogo code snippet `to pmn-function` outlines the behavior of polymorphonuclear neutrophils (PMNs) based on their different states and environmental factors. PMNs play a significant role in the host defense against bacterial infections.\\n\\nThe code consists of several actions:\\n\\n1. The `ifelse` statement checks if the `wbc-migrate` (White Blood Cell migration) variable is greater than 0, indicating that PMN has finished its rolling and is ready for migration. If true, the `pmn-burst` procedure is executed, which could involve the release of granules, phagocytosis, and subsequent elimination of pathogens.\\n\\n2. If the condition is not met, the `ifelse` statement checks if the `ec-roll` (endothelial cell rolling) value exceeds 3 and the PMN's `wbc-roll` is equal to 1 (meaning the PMN has completed its rolling on the endothelial cell surface). If so, the `pmn-sniff` procedure is executed, which enables the PMN to sense and respond to chemicals (chemoattractants) released by activated endothelial cells and damaged tissues.\\n\\n3. If neither condition is met, the PMN repeats the `pmn-sniff` procedure twice.\\n\\n4. The code then checks if the sum of TNF (Tumor Necrosis Factor) and PAF (Platelet Activating Factor) is greater than 1. If true, the neutrophil's `wbc-stick` variable is set to IL-1, and IL-1ra (IL-1 Receptor Antagonist) level is increased by 1.\\n\\n5. If the `wbc-stick` and the `ec-stick` (endothelial cell sticking) variables meet the specified conditions, the `wbc-migrate` variable is calculated based on the sum of TNF, IL-1, and GCSF (Granulocyte Colony-stimulating Factor), minus IL-10 (Interleukin 10). This calculation represents neutrophil migration toward a site of infection, following the concentration gradient of chemoattractants. The PMN's color is also changed to yellow once it starts migrating.\\n\\n6. Finally, the PMN's `pmn-age` is decreased by 1, and if it falls below 0, the PMN is removed from the simulation using the `die` command.\\n\\nOverall, the given NetLogo code `to pmn-function` simulates the chemotaxis and migration of neutrophils in response to various signals, contributing to the dynamic behavior of the immune system and host response to infections.\"\n": "Based on the provided description and the `pmn-function` procedure in NetLogo, here's an equivalent implementation in C++. To do this, make sure you have the `Turtle` class with the relevant properties described in your C++ implementation. For simplicity, this example assumes that the turtle position is represented by a `position` property which is a `std::pair<int, int>`.\n\n1. Add a new function `pmn_function` in the `World` class:\n\n```cpp\n// world.h\nclass World {\npublic:\n    // ...\n\n    void pmn_function(const std::shared_ptr<Turtle>& pmn);\n\n    // ...\n};\n```\n\n2. Implement the `pmn_function` function in the `world.cpp` file:\n\n```cpp\n// world.cpp\n#include \"world.h\"\n\n// ...\n\nvoid World::pmn_function(const std::shared_ptr<Turtle>& pmn) {\n    int wbc_migrate = pmn->get_wbc_migrate();\n    int ec_roll = pmn->get_ec_roll();\n    int wbc_roll = pmn->get_wbc_roll();\n    int pmn_age = pmn->get_pmn_age();\n\n    int TNF = get_patch(pmn->get_position().first, pmn->get_position().second)->get_TNF();\n    int PAF = get_patch(pmn->get_position().first, pmn->get_position().second)->get_PAF();\n    int IL_1 = get_patch(pmn->get_position().first, pmn->get_position().second)->get_IL_1();\n    int IL_1ra = pmn->get_IL_1ra();\n    int GCSF = get_patch(pmn->get_position().first, pmn->get_position().second)->get_GCSF();\n    int IL_10 = get_patch(pmn->get_position().first, pmn->get_position().second)->get_IL_10();\n\n    if (wbc_migrate > 0) {\n        // pmn-burst\n        // TODO Implement pmn-burst action.\n    } else {\n        if (ec_roll > 3 && wbc_roll == 1) {\n            // pmn-sniff\n            // TODO Implement pmn-sniff action.\n        } else {\n            for (int i = 0; i < 2; ++i) {\n                // pmn-sniff\n                // TODO Implement pmn-sniff action.\n            }\n        }\n\n        if (TNF + PAF > 1) {\n            pmn->set_wbc_stick(IL_1);\n            IL_1ra += 1;\n            pmn->set_IL_1ra(IL_1ra);\n        }\n\n        if ((pmn->get_wbc_stick() >= 1) && (ec_stick >= 100)) {\n            // Calculate wbc-migrate based on the sum of TNF, IL-1, and GCSF, minus IL-10.\n            wbc_migrate = TNF + IL_1 + GCSF - IL_10;\n            pmn->set_wbc_migrate(wbc_migrate);\n            pmn->set_color(Turtle::Color::yellow);\n        }\n\n        pmn_age -= 1;\n        pmn->set_pmn_age(pmn_age);\n\n        if (pmn_age < 0) {\n            // Die\n            pmn->die();\n        }\n    }\n}\n```\n\n3. Call the `pmn_function` in a loop or inside an event-driven mechanism within the `World` class:\n\n```cpp\n// world.cpp\n\n// ...\n\nvoid World::update() {\n    // ...\n\n    for (const std::shared_ptr<Turtle>& pmn : all_pmns) {\n        pmn_function(pmn);\n    }\n\n    // ...\n}\n```\n\nThis C++ implementation should replicate the behavior of the `pmn-function` procedure in NetLogo. Make sure you implement the required TODO actions based on your design."
}