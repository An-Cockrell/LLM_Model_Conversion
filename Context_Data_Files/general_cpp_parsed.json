{
      "0": {
            "code": "\n// agent.h\n#ifndef AGENT_H\n#define AGENT_H\n\n\n#include <iostream>\n#include <fstream>\n#include <vector>\n\nclass Agent {\n    protected:\n    Agent(int x, int y) : x(x), y(y) {}\n    private:\n    std::string color = \"\";\n    int alpha = 255;\n    int x;\n    int y;\n    public:\n\n    virtual double getX() const {return x;};\n    virtual double getY() const {return y;};\n    virtual void setX(int newX){x=newX;};\n    virtual void setY(int newY){y=newY;};\n    void setColor(std::string newColor){color = newColor;};\n    std::string getColor() const {return color;};\n    void setOpacity(int newAlpha){alpha = newAlpha;};\n    int getOpacity() const {return alpha;};\n};\n\n\n#endif\n"
      },
      "1": {
            "code_block": "\n// main.cpp\n#include 'rendering.h'\n#include 'world.h'\n\n#include <chrono>\n\nint main(int argc, char const *argv[]) {\n  std::cout<<'starting main'<<std::endl;\n  World world = World();\n  World* worldptr = &world; // pointer to give to rendering engine\n  \n  // setting up world\n  world.setup();\n  world.injure_sterile(INJURY_NUMBER);\n  world.updateTurtleVectors();\n\n  // setting up rendering engine\n  RenderingEngine engine = RenderingEngine(worldptr);\n  bool quit=false;\n  SDL_Event event;\n\n\n  auto startTime = std::chrono::high_resolution_clock::now();\n  // main loop\n  std::cout<<'STARTING GO'<<std::endl;\n  for (size_t i = 0; i < NUM_STEPS; i++) {\n    std::cout<<'beginning step number ' <<i<<std::endl;\n    world.go();\n    \n    // rendering loop\n    if (RENDERING){\n      engine.setBackgroundColor('black');\n      engine.renderAllPatches();\n      engine.renderAllTurtles();\n      engine.render();\n      SDL_PollEvent(&event);\n      /* will pause every step until ctrl+c is pressed\n      useful for debugging, but tgere is no way to break out of it.\n      kind of annoying, only use it when NUM_STEPS is low*/\n      \n      // quit=false;\n      // while (!quit) {\n        //       while (SDL_PollEvent(&event)) {\n          //           if (event.type == SDL_QUIT) {\n            //               quit = true;\n            //           }\n            //       }\n            //   }\n      /* will loop through and display every turn until end of NUM_STEPS, can break out with ctrl+c */\n      if (event.type == SDL_QUIT) {\n        quit = true;\n      }\n      if(quit){break;}\n    }\n  }\n  auto endTime = std::chrono::high_resolution_clock::now();\n  auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime);\n  std::cout << 'Program duration: ' << duration.count() << ' milliseconds' << std::endl;\n\n  return 0;\n};"
      },
      "2": {
            "code_block": "\n// parameters.h\n#ifndef PARAMETERS_H\n#define PARAMETERS_H\n\nconst bool RENDERING = true;\nconst bool SAVING_DATA = false;\nconst bool TURTLE_CONTINOUS_MOVEMENT = false;\n\nconst int RNG_SEED=108;\nconst int NUM_STEPS = 2000;\n\n\nconst static int WORLD_WIDTH = 101;\nconst static int WORLD_HEIGHT = 101;\nconst int PATCH_MAX_CAPACITY = 10;\nconst int MAX_RANDOM_DISTANCE = 100;\n\n#endif"
      },
      "3": {
            "code_block": "\n// patch.cpp\n#include <iostream>\n#include <string>\n#include <vector>\n#include 'patch.h'\n#include <algorithm>\n#include <fstream>\n\nvoid Patch::add_turtle(std::shared_ptr<Turtle> turtle_to_add){\n  turtles_here.emplace_back(turtle_to_add);\n}\n\nvoid Patch::remove_turtle(std::shared_ptr<Turtle> turtle_to_remove){\n  turtles_here.erase(std::remove(turtles_here.begin(), turtles_here.end(), turtle_to_remove), turtles_here.end());\n}\n\nvoid Patch::display() {\n    std::cout << 'Patch position: (' << this->getX() << ', ' << getY() << ')' << std::endl;\n    // std::cout << 'Patch color: ' << color << std::endl;\n    if (turtles_here.size() > 0){\n      for (auto &turtle: turtles_here){\n        turtle->display();\n      }\n    }\n}\nbool Patch::is_at_capacity(){\n  return (turtles_here.size() >= PATCH_MAX_CAPACITY);\n}\n\n\n// Add more patch specific functions below for the particular implementation of a net logo model being ported\n"
      },
      "4": {
            "code_block": "\n// patch.h\n#ifndef PATCH_H\n#define PATCH_H\n\n#include 'parameters.h'\n#include 'agent.h'\n#include 'turtle.h'\n#include <memory>\n\n// class Turtle;\n\nclass Patch : public Agent{\n  private:\n    std::vector<std::shared_ptr<Turtle>> turtles_here;\n    \n    double temp_var; //placeholder for diffusion totals before updating\n\n  public:\n    Patch():Agent(0,0){setColor('red');};               // base patch color is red\n    Patch(int xCoord, int yCoord) : Agent(xCoord, yCoord) {setColor('red');};\n        \n    void add_turtle(std::shared_ptr<Turtle> turtle_to_add);\n    void remove_turtle(std::shared_ptr<Turtle> turtle_to_remove);\n    void display();\n    bool is_at_capacity();\n\n    void setTempVar(double newVal){temp_var=newVal};\n    double getTempVar() const {return temp_var};\n    \n    // patch is the same iff the x and y positions are equal\n    bool operator== (Patch& that){return (this->getX()==that.getX() && this->getY()==that.getY());};\n    \n    \n    // Add more patch specific functions below for the particular implementation of a net logo model being ported\n    \n    \n};\n\n\n\n#endif"
      },
      "5": {
            "code_block": "\n// rendering.cpp\n#include 'rendering.h'\n\n\nRenderingEngine::RenderingEngine(){\n  SDL_Init(SDL_INIT_VIDEO);\n  window = SDL_CreateWindow('SDL Window', SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, SCREEN_WIDTH, SCREEN_HEIGHT, SDL_WINDOW_SHOWN);\n  renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);\n  SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_BLEND);\n  SDL_RenderClear(renderer);\n}\n\nRenderingEngine::RenderingEngine(World *world){\n  myWorld = world;\n  SDL_Init(SDL_INIT_VIDEO);\n  window = SDL_CreateWindow('SDL Window', SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, SCREEN_WIDTH, SCREEN_HEIGHT, SDL_WINDOW_SHOWN);\n  renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);\n  SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_BLEND);\n  SDL_RenderClear(renderer);\n}\n\nRenderingEngine::~RenderingEngine(){\n  SDL_DestroyRenderer(renderer);\n  SDL_DestroyWindow(window);\n  SDL_Quit();\n}\n\nstd::tuple<int, int, int> RenderingEngine::getColor(const std::string& color){\n  int red, green, blue;\n  if (color == 'red') {\n      red = 255;\n      green = 0;\n      blue = 0;\n  }\n  else if (color == 'green') {\n      red = 0;\n      green = 255;\n      blue = 0;\n  }\n  else if (color == 'cyan') {\n    red = 0;\n    green = 255;\n    blue = 255;\n  }\n  else if (color == 'blue') {\n      red = 0;\n      green = 0;\n      blue = 255;\n  }\n  else if (color =='black'){\n    red = 0;\n    green = 0;\n    blue = 0;\n  }\n  else if (color == 'white'){\n    red = 255;\n    green = 255;\n    blue = 255;\n  }\n  else if (color == 'yellow'){\n    red = 255;\n    green = 255;\n    blue = 0;\n  }\n  else if (color == 'violet'){\n    red = 127;\n    green = 0;\n    blue = 255;\n  }\n  else if (color =='brown'){\n    red = 165;\n    green = 42;\n    blue = 42;\n  }\n  else if (color == 'orange'){\n    red = 255;\n    green = 165;\n    blue = 0;\n  }\n  else if (color == 'grey'){\n    red = 128;\n    green = 128;\n    blue = 128;\n  }\n  \n  else {\n      red = 100;\n      green = 100;\n      blue = 100;\n  }\n  return std::make_tuple(red, green, blue);\n}\n\nvoid RenderingEngine::render(){\n  SDL_RenderPresent(renderer);\n}\n\nvoid RenderingEngine::setBackgroundColor(const std::string& color){\n  std::tuple<int, int, int> RGB = getColor(color);\n    SDL_SetRenderDrawColor(renderer, std::get<0>(RGB), std::get<1>(RGB), std::get<2>(RGB), SDL_ALPHA_OPAQUE);\n    SDL_RenderClear(renderer);\n    // SDL_RenderPresent(renderer);\n}\n\nvoid RenderingEngine::drawLine(double startX, double startY, double endX, double endY, const std::string& color, int alpha){\n  std::tuple<int, int, int> RGB = getColor(color);\n  SDL_SetRenderDrawColor(renderer, std::get<0>(RGB), std::get<1>(RGB), std::get<2>(RGB), alpha);\n  SDL_RenderDrawLine(renderer, startX, startY, endX, endY);\n  // SDL_RenderPresent(renderer);\n}\n\nvoid RenderingEngine::drawCircle(double centerX, double centerY, double radius, const std::string& color, int alpha){\n  centerX -= GRID_SIZE/2;\n  centerY -= GRID_SIZE/2;\n  std::tuple<int, int, int> RGB = getColor(color);\n  SDL_SetRenderDrawColor(renderer, std::get<0>(RGB), std::get<1>(RGB), std::get<2>(RGB), alpha);\n\n\tfor (int y = -radius; y <= radius; ++y) {\n\t    for (int x = -radius; x <= radius; ++x) {\n\t        if (x*x + y*y <= radius*radius) {\n\t            SDL_RenderDrawPoint(renderer, centerX + x, centerY + y);\n\t        }\n\t    }\n\t}\n\t// SDL_RenderPresent(renderer);\n}\n\nvoid RenderingEngine::drawSquare(int x, int y, int size, const std::string& color, int alpha) {\n  std::tuple<int, int, int> RGB = getColor(color);\n  SDL_SetRenderDrawColor(renderer, std::get<0>(RGB), std::get<1>(RGB), std::get<2>(RGB), alpha);\n  SDL_Rect rect = { x, y, size, size };\n  SDL_RenderFillRect(renderer, &rect);\n  // SDL_RenderPresent(renderer);\n}\n\nvoid RenderingEngine::renderAllPatches(){\n  for (int x = 0; x < WORLD_WIDTH; x++){\n    for (int y = 0; y < WORLD_HEIGHT; y++){\n      auto& patch = myWorld->get_patch(x,y);\n      int patch_x = patch.getX() * GRID_SIZE;\n      int patch_y = patch.getY() * GRID_SIZE;\n      std::string color = patch.getColor();\n      int opacity = patch.getOpacity();\n      drawSquare(patch_x,patch_y,GRID_SIZE, color, opacity);\n    }\n  }\n}\n\nvoid RenderingEngine::renderAllTurtles(){\n  int x, y;\n  for (auto& agent : myWorld->all_turtles){\n    x = agent.lock()->getX() * GRID_SIZE;\n    y = agent.lock()->getY() * GRID_SIZE;\n    std::string color = agent.lock()->getColor();\n    int opacity = agent.lock()->getOpacity();\n    drawCircle(x,y,(GRID_SIZE/2)-2, color, opacity);\n  }\n}"
      },
      "6": {
            "code_block": "\n// rendering.h\n#ifndef RENDERING_H\n#define RENDERING_H\n\n//Using SDL and standard IO\n#include <SDL2/SDL.h>\n#include <stdlib.h>\n#include <string>\n#include <stdio.h>\n#include <tuple>\n#include 'world.h'\n\n#include 'parameters.h'\n\nclass RenderingEngine {\nprivate:\n  /* data */\n  SDL_Window* window;\n  SDL_Renderer* renderer;\n  World* myWorld;\n\n\npublic:\n  const static int GRID_SIZE = 10;\n  const static int SCREEN_WIDTH = WORLD_WIDTH * GRID_SIZE;\n  const static int SCREEN_HEIGHT = WORLD_WIDTH * GRID_SIZE;\n  RenderingEngine();\n  RenderingEngine(World *world);\n  virtual ~RenderingEngine ();\n  \n  std::tuple<int, int, int> getColor(const std::string& color);\n  void drawCircle(double centerX, double centerY, double radius=GRID_SIZE/2, const std::string& color='red', int alpha=SDL_ALPHA_OPAQUE);\n  void drawSquare(int x, int y, int size=GRID_SIZE, const std::string& color='red', int alpha=SDL_ALPHA_OPAQUE);\n  void drawLine(double startX, double startY, double endX, double endY, const std::string& color='black', int alpha=SDL_ALPHA_OPAQUE);\n  void setBackgroundColor(const std::string& color='red');\n  void render();\n  \n  void renderAllPatches();\n  void renderAllTurtles();\n};\n\n\n#endif"
      },
      "7": {
            "code_block": "\n// turtle.cpp\n#include <iostream>\n#include <string>\n#include 'agent.h'\n#include <cmath>\n#include 'turtle.h'\n#include 'parameters.h'\n\nstd::pair<int,int> Turtle::move(float distance) {\n  // default val for distance=1\n  // calculates the movement for the turtle based on its heading and distance to move and returns the coordinates of the destination patch\n    temp_x = x_dec;   //placeholders in case we are not able to actually execute the move. In that case, these will reset x/y decimal values\n    temp_y = y_dec;\n    float d_x = cos(heading * M_PI/180) * distance;   // converting degrees to radians and getting delta x and delta y\n    float d_y = sin(heading * M_PI/180) * distance;\n    if (!TURTLE_CONTINOUS_MOVEMENT) {   //ie discrete movement, turtles always land on the middle of patches\n      d_x = round(d_x);\n      d_y = round(d_y);\n    }\n    x_dec += d_x;\n    y_dec += d_y;\n    \n    x_dec = fmod(fmod(x_dec, WORLD_WIDTH) +WORLD_WIDTH, WORLD_WIDTH);              // wrapping around world with modulo\n    y_dec = fmod(fmod(y_dec, WORLD_HEIGHT) +WORLD_HEIGHT, WORLD_HEIGHT);           // taking double mod to make sure that a positive number for grid coordinates\n    int newx, newy;\n    newx = trunc(x_dec);    // truncating decimal coords to get int coords\n    newy = trunc(y_dec);\n\n    return std::make_pair(newx, newy);\n}\nstd::pair<int,int> Turtle::jumpRandom(std::mt19937 &RNG_Engine) {\n  // get a random direction, then a random distance, then return the coordinates that we jumped to\n    int random_heading = RNG_Engine()%360;\n    int random_distance = RNG_Engine()%MAX_RANDOM_DISTANCE;\n    \n    this->setHeading(random_heading);\n    return this->move(random_distance);\n}\n\nvoid Turtle::execute_move(bool didMove){\n  // if we execute the move, then the world has moved the turtle to a new patch, and we need to update internal variables\n  if(didMove){\n    setX(trunc(x_dec));                             // truncating decimal coords to get int coords\n    setY(trunc(y_dec));\n  } else{\n    x_dec = temp_x;\n    y_dec = temp_y;\n  }\n}\n\nvoid Turtle::wiggle(std::mt19937 &RNG_Engine){\n  // randomly wiggle heading up to 45 degrees left up to 45 degrees right\n  int random_left = RNG_Engine()%45;\n  int random_right = RNG_Engine()%45;\n  this->setHeading(this->getHeading() + random_left - random_right);\n}\n\nvoid Turtle::display() {\n  std::cout << 'Turtle position: (' << this->getX() << ', ' << this->getY() << ')' << std::endl;\n  std::cout << 'Turtle exact position: (' << x_dec << ', ' << y_dec << ')' << std::endl;\n  std::cout << 'Turtle Heading: (' << heading << ')' << std::endl;\n  std::cout << 'Turtle ID: (' << ID_num << ')' << std::endl;\n}\n\n// add more turtle specific functions below. These are functions that will apply to all turtle types, not a single breed\n"
      },
      "8": {
            "code_block": "\n\n// world.cpp\n#include 'world.h'\n\n\nvoid World::add_patch(int x, int y){\n  all_patches[x][y] = Patch(x,y);\n}\n\nPatch& World::get_patch(int x, int y){\n  x = (x+WORLD_WIDTH)%WORLD_WIDTH;\n  y = (y+WORLD_HEIGHT)%WORLD_HEIGHT;\n  return all_patches[x][y];\n}\n\nPatch& World::getPatchAhead(std::shared_ptr<Turtle> turtle, float distance){\n  // default value for distance=1\n  // get the patch in front of the turtle, based on its current heading\n  int heading = turtle->getHeading();\n  int current_x = turtle->getX();\n  int current_y = turtle->getY();\n\n  float d_x = cos(heading * M_PI/180) * distance;   // converting degrees to radians and getting delta x and delta y\n  float d_y = sin(heading * M_PI/180) * distance;\n\n  int ahead_x = round(current_x + d_x);\n  int ahead_y = round(current_y + d_y);\n\n  return get_patch(ahead_x, ahead_y);\n}\n\nPatch& World::getPatchAheadRight(std::shared_ptr<Turtle> turtle, float distance){\n  // default value for distance=1\n  // get the patch in front and to the right of the turtle, based on its current heading\n  int heading = turtle->getHeading() - 45; // to look right 45 degrees\n  int current_x = turtle->getX();\n  int current_y = turtle->getY();\n\n  float d_x = cos(heading * M_PI/180) * distance;   // converting degrees to radians and getting delta x and delta y\n  float d_y = sin(heading * M_PI/180) * distance;\n\n  int ahead_x = round(current_x + d_x);\n  int ahead_y = round(current_y + d_y);\n\n  return get_patch(ahead_x, ahead_y);\n}\n\nPatch& World::getPatchAheadLeft(std::shared_ptr<Turtle> turtle, float distance){\n  // default value for distance=1\n  // get the patch in front and to the right of the turtle, based on its current heading\n  int heading = turtle->getHeading() + 45; // to look left 45 degrees\n  int current_x = turtle->getX();\n  int current_y = turtle->getY();\n\n  float d_x = cos(heading * M_PI/180) * distance;   // converting degrees to radians and getting delta x and delta y\n  float d_y = sin(heading * M_PI/180) * distance;\n\n  int ahead_x = round(current_x + d_x);\n  int ahead_y = round(current_y + d_y);\n\n  return get_patch(ahead_x, ahead_y);\n}\n\nvoid World::setup_patches(){\n  for(int x=0; x<WORLD_WIDTH; x++){\n    for(int y=0; y<WORLD_HEIGHT; y++){\n      add_patch(x,y);\n      // set initial values on patches here; eg patch.setOxy(100) to set patch oxy to initial value\n    }\n  }\n}\n\nvoid World::display_patches(){\n  for(auto &patchArr: all_patches){\n    for(auto &patch: patchArr){\n      patch.display();\n    }\n  }\n}\n\nvoid World::add_turtle(int x, int y, int id, int heading){\n  std::shared_ptr<Turtle> new_turtle = std::make_shared<Turtle>(x, y, id, heading);\n  get_patch(x,y).add_turtle(new_turtle);\n  all_turtles.emplace_back(new_turtle);\n}\n\nvoid World::move_turtle(std::shared_ptr<Turtle> turtle){\n  // moves the turtle but asking the turtle to calculate its movement, and if there is space on the target_patch, the world executes the move\n  Patch &turtle_current_patch = get_patch(turtle->getX(), turtle->getY());\n  std::pair<int,int> new_coords = turtle->move(); //moving along turtle.heading for the default value of 1 unit\n  Patch& target_patch = get_patch(new_coords.first, new_coords.second);\n  if (turtle_current_patch == target_patch){\n    return;\n  } else if (target_patch.is_at_capacity()){\n    turtle->execute_move(false);\n  }\n  else{\n    turtle->execute_move(true);\n    turtle_current_patch.remove_turtle(turtle);\n    target_patch.add_turtle(turtle);\n  }\n}\n\nvoid World::move_turtle_random_jump(std::shared_ptr<Turtle> turtle){\n  // same as move turtle but instead of turtle-> move() we are using turtle->jumpRandom(RNG_Engine)\n  Patch &turtle_current_patch = get_patch(turtle->getX(), turtle->getY());\n  std::pair<int,int> new_coords = turtle->jumpRandom(RNG_Engine);\n  Patch& target_patch = get_patch(new_coords.first, new_coords.second);\n    if (turtle_current_patch == target_patch){\n    return;\n  } else if (target_patch.is_at_capacity()){\n    turtle->execute_move(false);\n  }\n  else{\n    turtle->execute_move(true);\n    turtle_current_patch.remove_turtle(turtle);\n    target_patch.add_turtle(turtle);\n  }\n}\n\nvoid World::turtle_wiggle(std::shared_ptr<Turtle> turtle){\n  // wiggles the turtles heading, then moves forward along the new heading for 1 unit\n  turtle->wiggle(RNG_Engine);\n  move_turtle(turtle);\n}\n\nvoid World::kill_turtle(std::shared_ptr<Turtle> turtle){\n  // removed turtle from its patch\n  Patch &turtle_current_patch = get_patch(turtle->getX(), turtle->getY());\n  turtle_current_patch.remove_turtle(turtle);\n}\n\n//void kill(std::shared_ptr<T> &ptr) <-- templated function that will kill any turtle or subclass of turtle. implemented in header file\n\nvoid World::updateTurtleVectors(){\n    // erasing the turtle weak pointers that are now a null pointer because they have been reset\n    all_turtles.erase(std::remove_if(all_turtles.begin(), all_turtles.end(),\n    [](const std::weak_ptr<Turtle>& wp) {     //lambda function to check if weak pointer is expired (aka killed and reset() has been called)\n        return wp.expired();\n      }),\n    all_turtles.end());\n\n    // now need to erase the shared pointers that were reset with kill()\n    // for example:  all_pmns.erase(std::remove(all_pmns.begin(), all_pmns.end(), nullptr), all_pmns.end());\n    // implement erasure for all turtle shared_ptr vectors here\n}\n\nvoid World::setup(){\n  set_rng_seed(RNG_SEED);\n  // This function initializes the global variables and setus up the world\n  step = 0;\n  time = 1;\n  \n  setup_patches(); // Initializing the patches\n  \n  global_ID_counter = 0;\n  // create cell types like so, using PMN as an example\n  for (int i = 0; i < NUM_CELLS_TO_ADD; i++) {\n    global_ID_counter++;   //increment global ID counter to give to the new cell\n    int random_x = RNG_Engine() % WORLD_WIDTH; //random X and Y position\n    int random_y = RNG_Engine() % WORLD_HEIGHT;\n    auto pmn = std::make_shared<Pmn>(random_x, random_y, global_ID_counter);   // creating the actual PMN turtle\n    Patch& patch = get_patch(random_x, random_y); // get patch to to add the turtle to\n    patch.add_turtle(pmn); // add turtle to patch\n    std::weak_ptr<Turtle> pmn_weak_ptr = pmn;   // creating a weak pointer to give to all turtles vector so that deleting pmn object kills it in the turtle list as well. Chat gpt didnt do this, I did\n  \n    // setting new cell variables\n    pmn->setAge(rand() % 50); // setting age to random number no larger than 50\n    pmn->setWbcRoll(1);\n    pmn->setWbcStick(0);\n    pmn->setWbcMigrate(0);\n    pmn->setPmnPcd(10);\n  \n    // performing random jump to get a random space to start because thats how the netlogo did it, probably unnecessary because of random x and y starting position\n    for (int j = 0; j < 10; j++) {\n      move_turtle_random_jump(pmn);\n    }\n    // adding new turtle to all turtles vector, and specific type vector\n    all_turtles.push_back(pmn_weak_ptr);\n    all_pmns.push_back(pmn);\n  }\n    \n  // repeat the above code block for all turtle types in setup\n  \n  // set world global variables at the end\n  // eg, system_oxy = 10201.0;\n}\n\nvoid World::go() {\n    // NetLogo 'tick' equivalent in C++ is simply incrementing the time counter\n    step++;\n\n    // implement netlogo Go function here\n\n\n    // end of go\n    updateTurtleVectors(); // need to update turtle positions/delete dead turtles\n}\n\nvoid World::diffuse(){\n  // need to diffuse values from patches out to neighboring patches\n  float factor_for_neighbors = 1/8; //eight neighbors in a 2D grid\n\n  // // follow this example format for each diffusing variable\n  // for (auto& patch : all_patches){patch->setTempVar(0);}  // reset temp_var\n  // // start with Endotoxin\n  // // get totals for neighbors\n  // for (auto& center_patch : all_patches){\n  //   int center_patch_x_pos = center_patch->getX();\n  //   int center_patch_y_pos = center_patch->getY();\n  //   for (int i=-1; i<2; i++){\n  //     for (int j=-1; j<2; j++){\n  //       if (i==0 && j==0) { // skipping center cell\n  //         continue;\n  //       }\n  //       int neighbor_x = fmod((center_patch_x_pos + i), WORLD_WIDTH); // getting modulo of position + x/y to wrap around toroidal world\n  //       int neighbor_y = fmod((center_patch_y_pos + j), WORLD_HEIGHT);\n  //       auto& neighbor_patch = get_patch(neighbor_x, neighbor_y);\n  //       neighbor_patch.setTempVar(neighbor_patch.getTempVar() + center_patch->getEndotoxin()*factor_for_neighbors*ENDOTOXIN_DIFFUSION_FACTOR); // evenly adding the amount diffused out from the center patch to neighbor patches\n  //     }\n  //   }\n  // }\n  // // set Endotoxin on each patch from the temp var, then reset tempvar\n  // for (auto& patch : all_patches){\n  //   patch->setEndotoxin((patch->getEndotoxin() * (1-ENDOTOXIN_DIFFUSION_FACTOR)) + patch->getTempVar());  // new total is starting amount minus the amount that diffused out, plus the amount that diffused in from neighbors\n  //   patch->setTempVar(0); // resetting\n  // }\n  \n  //implement diffusion for other variables below\n  \n  \n}\n\nvoid World::evaporate(){\n  // evaporate variables off of all patches\n  for (auto& patch : all_patches) {\n    // Endotoxin as an example, amount to set is current amount times the evaporation factor\n    // patch->setEndotoxin(patch->getEndotoxin() * ENDOTOXIN_EVAPORATION_FACTOR);\n\n  }\n}\n\n"
      },
      "9": {
            "code_block": "\n// world.h\n#ifndef WORLD_H\n#define WORLD_H\n\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <vector>\n#include <stdlib.h>\n#include <memory>\n#include <algorithm>\n\n#include 'parameters.h'\n#include 'agent.h'\n#include 'patch.h'\n#include 'turtle.h'\n\n\nclass World {\nprivate:\n  std::mt19937 RNG_Engine;\n  int global_ID_counter;  //ID counter for creating new turtles to make sure each has a unique ID\n  int step;\n  int time;\n  int loop_run;\n  \n  Patch all_patches[WORLD_WIDTH][WORLD_HEIGHT];\n  \n  void set_rng_seed(int newSeed){RNG_Engine.seed(newSeed);}\n  void add_patch(int x, int y);\n\npublic:\n  std::vector<std::weak_ptr<Turtle>> all_turtles;\n  // include vectors of shared_ptr's of other turtle sub-types here\n  // for example:   std::vector<std::shared_ptr<Pmn>> all_pmns;\n\n  \n  World(){};\n  \n  Patch& get_patch(int x, int y);\n  Patch& getPatchAhead(std::shared_ptr<Turtle> turtle, float distance=1);\n  Patch& getPatchAheadRight(std::shared_ptr<Turtle> turtle, float distance=1);\n  Patch& getPatchAheadLeft(std::shared_ptr<Turtle> turtle, float distance=1);\n\n  void setup_patches();\n  void display_patches();\n  \n  void add_turtle(int x, int y, int id, int heading=0);\n  void move_turtle(std::shared_ptr<Turtle> turtle);\n  void move_turtle_random_jump(std::shared_ptr<Turtle> turtle);\n  void turtle_wiggle(std::shared_ptr<Turtle> turtle);\n  \n  void kill_turtle(std::shared_ptr<Turtle> turtle);\n  \n  // templated function to kill any turtle or agent\n  template <typename T>\n  void kill(std::shared_ptr<T> &ptr){\n    kill_turtle(ptr);\n    ptr.reset();\n  }\n\n  void updateTurtleVectors();\n\n  void setup();\n  void go();\n    \n  void diffuse();\n  void evaporate();\n  \n};\n\n\n#endif"
      }
}