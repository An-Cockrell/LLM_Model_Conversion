{
    "0": {
        "Section_title": "Agents",
        "Section_data": "Agents\nThe NetLogo world is made up of agents. Agents are beings that can follow\ninstructions.\nIn NetLogo, there are four types of agents: turtles, patches, links,\nand the observer.\nTurtles are agents that move around in the world. The world is two\ndimensional and is divided up into a grid of patches. Each patch is a square\npiece of \u201cground\u201d over which turtles can move. Links are agents that connect two\nturtles. The observer doesn\u2019t have a location \u2013 you can imagine it as looking\nout over the world of turtles and patches.\nThe observer doesn\u2019t observe passively \u2013 it gives instructions to the other\nagents.\nWhen NetLogo starts up, there are no turtles. The observer can make new turtles.\nPatches can make new turtles too. (Patches can\u2019t move, but otherwise they\u2019re\njust as \u201calive\u201d as turtles.)\nPatches have coordinates. The patch at coordinates (0, 0) is called the origin\nand the coordinates of the other patches are the horizontal and vertical\ndistances from this one. We call the patch\u2019s coordinates pxcor and\npycor. Just like in the standard mathematical coordinate plane,\npxcor increases as you move to the right and pycor increases\nas you move up.\nThe total number of patches is determined by the settings\nmin-pxcor, max-pxcor, min-pycor and\nmax-pycor. When NetLogo starts up, min-pxcor,\nmax-pxcor, min-pycor and max-pycor are\n-16, 16, -16, and 16 respectively. This means that pxcor and\npycor both range from -16 to 16, so there are 33 times 33, or 1089\npatches total. (You can change the number of patches with the Settings button.)\nTurtles have coordinates too: xcor and ycor. A patch\u2019s coordinates are\nalways integers, but a turtle\u2019s coordinates can have decimals. This means that a\nturtle can be positioned at any point within its patch; it doesn\u2019t have to be in\nthe center of the patch.\nLinks do not have coordinates. Every link has two ends, and each end is a\nturtle. If either turtle dies, the link dies too. A link is represented visually\nas a line connecting the two turtles.\n"
    },
    "1": {
        "Section_title": "Procedures",
        "Section_data": "Procedures\nIn NetLogo, commands and reporters tell agents what to do. A command is\nan action for an agent to carry out, resulting in some effect. A reporter is\ninstructions for computing a value, which the agent then \u201creports\u201d to whoever\nasked it.\nTypically, a command name begins with a verb, such as \u201ccreate\u201d, \u201cdie\u201d, \u201cjump\u201d,\n\u201cinspect\u201d, or \u201cclear\u201d. Most reporter names are nouns or noun phrases.\nCommands and reporters built into NetLogo are called primitives.\nThe NetLogo Dictionary has a complete list of built-in\ncommands and reporters.\nCommands and reporters you define yourself are called procedures. Each\nprocedure has a name, preceded by the keyword to or to-report, depending\non whether it is a command procedure or a reporter procedure. The keyword\nend marks the end of the commands in the procedure. Once you define a\nprocedure, you can use it elsewhere in your program.\nMany commands and reporters take inputs \u2013 values that the command or\nreporter uses in carrying out its actions or computing its result.\nHere are two command procedures:\nto setup\n  clear-all\n  create-turtles 10\n  reset-ticks\nend\n\nto go\n  ask turtles [\n    fd 1            ;; forward 1 step\n    rt random 10    ;; turn right\n    lt random 10    ;; turn left\n  ]\n  tick\nend\n\nNote the use of semicolons to add \u201ccomments\u201d to the program. Comments can make\nyour code easier to read and understand, but they don\u2019t affect its behavior.\nIn this program,\n\nsetup and go are user-defined commands.\nclear-all, create-turtles, reset-ticks, ask, lt\n(\u201cleft turn\u201d), rt (\u201cright turn\u201d) and tick, are all primitive\ncommands.\nrandom and turtles are primitive reporters. random takes a single\nnumber as an input and reports a random integer that is less than the input\n(in this case, between 0 and 9). turtles reports the agentset consisting\nof all the turtles. (We\u2019ll explain about agentsets later.)\n\nsetup and go can be called by other procedures, or by buttons, or from the\nCommand Center.\nMany NetLogo models have a once button that calls a procedure called setup and\na forever button that calls a procedure called go.\nIn NetLogo, you may specify which agents \u2013 turtles, patches, or links \u2013 are to\nrun each command. If you don\u2019t specify, the code is run by the observer. In the\ncode above, the observer uses ask to make the set of all turtles run the\ncommands between the square brackets.\nclear-all and create-turtles can only be run by the observer.\nfd, on the other hand, can only be run by turtles. Some other\ncommands and reporters, such as set and ticks, can be run by different\nagent types.\nHere are some more advanced features you can take advantage of when defining\nyour own procedures.\nProcedures with inputs\nProcedures can take inputs, just like many primitives do. To create a procedure\nthat accepts inputs, put their names in square brackets after the procedure\nname. For example:\nto draw-polygon [num-sides len]  ;; turtle procedure\n  pen-down\n  repeat num-sides [\n    fd len\n    rt 360 / num-sides\n  ]\nend\n\nElsewhere in the program, you might use the procedure by asking the turtles to\neach draw an octagon with a side length equal to its who number:\nask turtles [ draw-polygon 8 who ]\n\nReporter procedures\nJust like you can define your own commands, you can define your own reporters.\nYou must do two special things. First, use to-report instead of to to\nbegin your procedure. Then, in the body of the procedure, use report to\nreport the value you want to report.\nto-report absolute-value [number]\n  ifelse number >= 0\n    [ report number ]\n    [ report (- number) ]\nend\n\n"
    },
    "2": {
        "Section_title": "Variables",
        "Section_data": "Variables\nAgent variables\nAgent variables are places to store values (such as numbers) in an agent. An\nagent variable can be a global variable, a turtle variable, a patch variable, or\na link variable.\nIf a variable is a global variable, there is only one value for the variable,\nand every agent can access it. You can think of global variables as belonging to\nthe observer.\nTurtle, patch, and link variables are different. Each turtle has its own value\nfor every turtle variable. The same goes for patches and links.\nSome variables are built into NetLogo. For example, all turtles and links have a\ncolor variable, and all patches have a pcolor variable. (The patch\nvariable begins with \u201cp\u201d so it doesn\u2019t get confused with the turtle variable,\nsince turtles have direct access to patch variables.) If you set the variable,\nthe turtle or patch changes color. (See next section for details.)\nOther built-in turtle variables including xcor, ycor, and heading.\nOther built-in patch variables include pxcor and pycor. (There\nis a complete list here.)\nYou can also define your own variables. You can make a global variable by adding\na switch, slider, chooser, or input box to your model, or by using the\nglobals keyword at the beginning of your code, like this:\nglobals [score]\n\nYou can also define new turtle, patch and link variables using the\nturtles-own, patches-own and links-own keywords, like this:\nturtles-own [energy speed]\npatches-own [friction]\nlinks-own [strength]\n\nThese variables can then be used freely in your model. Use the set command\nto set them. (Any variable you don\u2019t set has a starting value of zero.)\nGlobal variables can be read and set at any time by any agent. As well, a turtle\ncan read and set patch variables of the patch it is standing on. For example,\nthis code:\nask turtles [ set pcolor red ]\n\ncauses every turtle to make the patch it is standing on red. (Because patch\nvariables are shared by turtles in this way, you can\u2019t have a turtle variable\nand a patch variable with the same name.)\nIn other situations where you want an agent to read a different agent\u2019s\nvariable, you can use of. Example:\nshow [color] of turtle 5\n;; prints current color of turtle with who number 5\n\nYou can also use of with a more complicated expression than just a variable\nname, for example:\nshow [xcor + ycor] of turtle 5\n;; prints the sum of the x and y coordinates of\n;; turtle with who number 5\n\nLocal variables\nA local variable is defined and used only in the context of a particular\nprocedure or part of a procedure. To create a local variable, use the let\ncommand. If you use let at the top of a procedure, the variable will exist\nthroughout the procedure. If you use it inside a set of square brackets, for\nexample inside an \u201cask\u201d, then it will exist only inside those brackets.\nto swap-colors [turtle1 turtle2]\n  let temp [color] of turtle1\n  ask turtle1 [ set color [color] of turtle2 ]\n  ask turtle2 [ set color temp ]\nend\n\n"
    },
    "3": {
        "Section_title": "Tick counter",
        "Section_data": "Tick counter\nIn many NetLogo models, time passes in discrete steps, called \u201cticks\u201d. NetLogo\nincludes a built-in tick counter so you can keep track of how many ticks have\npassed.\nThe current value of the tick counter is shown above the view. (You can use the\nSettings button to hide the tick counter, or change the word \u201cticks\u201d to\nsomething else.)\nIn code, to retrieve the current value of the tick counter, use the ticks\nreporter. The tick command advances the tick counter by 1. The clear-all\ncommand clears the tick counter along with everything else.\nWhen the tick counter is clear, it\u2019s an error to try to read or modify it. Use\nthe reset-ticks command when your model is done setting up, to start the\ntick counter.\nIf your model is set to use tick-based updates, then the tick command will\nusually also update the view. See the later section,\nView Updates.\nWhen to tick\nUse reset-ticks at the end of your setup procedure.\nUse tick at the end of your go procedure.\nto setup\n  clear-all\n  create-turtles 10\n  reset-ticks\nend\n\nto go\n  ask turtles [ fd 1 ]\n  tick\nend\n\nFractional ticks\nIn most models, the tick counter starts at 0 and goes up 1 at a time, from\ninteger to integer. But it\u2019s also possible for the tick counter to take on\nin-between floating point values.\nTo advance the tick counter by a fractional amount, use the tick-advance\ncommand. This command takes a numeric input specifying how far to advance the\ntick counter.\nA typical use of fractional ticks is to approximate continuous or curved motion.\nSee, for example, the GasLab models in the Models Library (under\nChemistry & Physics). These models calculate the exact time at which a future\nevent is to occur, then advance the tick counter to exactly that time.\n"
    },
    "4": {
        "Section_title": "Colors",
        "Section_data": "Colors\nNetLogo represents colors in different ways. A color can be number in the range\n0 to 140, with the exception of 140 itself. Below is a chart showing the range\nof such NetLogo colors.\n\nThe chart shows that:\n\nSome of the colors have names. (You can use these names in your code.)\nEvery named color except black and white has a number ending in 5.\nOn either side of each named color are darker and lighter shades of the color.\n0 is pure black. 9.9 is pure white.\n10, 20, and so on are all so dark they are very nearly black.\n19.9, 29.9 and so on are all so light they are very nearly white.\n\n\nCode Example: The color chart was made in NetLogo with the Color Chart\nExample model.\n\nIf you use a number outside the 0 to 140 range, NetLogo will repeatedly add or\nsubtract 140 from the number until it is in the 0 to 140 range. For example, 25\nis orange, so 165, 305, 445, and so on are orange too, and so are -115, -255,\n-395, etc. This calculation is done automatically whenever you set the turtle\nvariable color or the patch variable pcolor. Should you need to perform\nthis calculation in some other context, use the wrap-color primitive.\nIf you want a color that\u2019s not on the chart, more exist between the integers.\nFor example, 26.5 is a shade of orange halfway between 26 and 27. This doesn\u2019t\nmean you can make any color in NetLogo; the NetLogo color space is only a subset\nof all possible colors. It contains only a fixed set of discrete hues (one hue\nper row of the chart). Starting from one of those hues, you can either decrease\nits brightness (darken it) or decrease its saturation (lighten it), but you\ncannot decrease both brightness and saturation. Also, only the first digit after\nthe decimal point is significant. Thus, color values are rounded down to the\nnext 0.1, so for example, there\u2019s no visible difference between 26.5 and 26.52\nor 26.58.\nColor primitives\nThere are a few primitives that are helpful for working with colors.\nWe have already mentioned the wrap-color primitive.\nThe scale-color primitive is useful for converting numeric data into colors.\nshade-of? will tell you if two colors are both \u201cshades\u201d of the same basic\nhue. For example, shade-of? orange 27 is true, because 27 is a lighter shade\nof orange.\n\nCode Example: Scale-color Example demonstrates the scale-color reporter.\n\nRGB and RGBA Colors\nNetLogo also represents colors as RGB (red/green/blue) lists and RGBA\n(red/green/blue/alpha) lists. When using RGB colors the full range of colors is\navailable to you. RGBA colors allow all the colors that RGB allows and you can\nalso vary the transparency of a color. RGB and RGBA lists are made up of three\nor four integers, respectively, between 0 and 255. You can set any\ncolor variables in NetLogo (color for turtles and links and pcolor for\npatches) to an RGB list and that agent will be rendered appropriately. So you\ncan set the color of patch 0 0 to pure red using the following code:\nset pcolor [255 0 0]\n\nTurtles, links, and labels can all contain RGBA lists as their color variables.\nPatches only use the alpha value of an RGBA pcolors in NetLogo 3D, it\u2019s\nignored in 2D NetLogo. You can set the color of a turtle to be approximately\nhalf transparent pure red with the following code:\nset color [255 0 0 125]\n\nYou can convert from a NetLogo color to RGB or HSB (hue/saturation/brightness)\nusing extract-hsb and extract-rgb. You can use rgb to generate rgb\nlists and hsb to convert from an HSB color to RGB.\nSince many colors are missing from the NetLogo color space, approximate-hsb\nand approximate-rgb often can\u2019t give you the exact color you ask for, but\nthey try to come as close as possible.\nExample:\nlet my-color approximate-rgb 0 0 255 ;; my-color is now 104.7\nshow extract-rgb my-color ;; shows [48 88 161] which is pretty far from [0 0 255], the color we started with\n\nThis is an approximation, but it is still near NetLogo blue which is 105.\nUsing RGBA colors, the user has more options when it comes to an agent\u2019s color.\nExample: you can change any turtle from its existing NetLogo color to a sixty percent transparent version of that color using:\nask one-of turtles [set color lput 102 extract-rgb color]\n\nNote: because 255 is fully opaque and sixty percent transparent is equal to forty percent opaque, the correct alpha value is  255 * .4 = 102.\nSee the palette extension section below for an alternate implementation.\n\nCode Examples: HSB and RGB Example (lets you experiment with the HSB and\nRGB color systems), Transparency Example\n\nPalette Extension\nThe palette extension offers primitives that give the user more control over colors. It allows for direct\nmanipulation of RGBA and HSB components without the requiring list manipulations.\nExample: changing the transparency of any turtle to sixty percent transparent with the palette extension:\nextensions [palette]\nask one-of turtles [palette:set-transparency 60]\n\nThe extension offers similar commands for Red, Green, Blue, Alpha, Hue, Saturation, and Brightness.\nSee the documentation of the palette extension for more information.\n\nCode Examples: Palette Example, Color Bubbles, Color Painting, Color Reveal\n\nColor Swatches dialog\nThe Color Swatches dialog helps you experiment with and choose colors. Open it\nby choosing Color Swatches on the Tools Menu.\n\nWhen you click on a color swatch (or a color button), that color will be shown\nagainst other colors. In the bottom left, the code for the currently selected\ncolor is displayed (for example, red + 2) so you can copy and paste it into\nyour code. On the bottom right there are three increment options, 1, 0.5, and\n0.1. These numbers indicate the difference between two adjacent swatches. When\nthe increment is 1 there are 10 different shades in each row; when the increment\nis 0.1 there are 100 different shades in each row. 0.5 is an intermediate\nsetting.\n"
    },
    "5": {
        "Section_title": "Ask",
        "Section_data": "Ask\nNetLogo uses the ask command to give commands to turtles, patches, and\nlinks. All code to be run by turtles must be located in a turtle \u201ccontext\u201d.\nYou can establish a turtle context in any of three ways:\n\nIn a button, by choosing \u201cTurtles\u201d from the popup menu. Any code you put in\nthe button will be run by all turtles.\nIn the Command Center, by choosing \u201cTurtles\u201d from the popup menu. Any commands\nyou enter will be run by all the turtles.\nBy using ask turtles, hatch, or other commands which establish a turtle\ncontext.\n\nThe same goes for patches, links, and the observer, except that you cannot\nask the observer. Any code that is not inside any ask is by default\nobserver code.\nBecause agentset members are always read in a random order, when ask is used with\nan agentset each agent will take its turn in a random order. See Agentsets\nfor more information.\nHere\u2019s an example of the use of ask in a NetLogo procedure:\nto setup\n  clear-all\n  create-turtles 100   ;; create 100 turtles with random headings\n  ask turtles\n    [ set color red    ;; turn them red\n      fd 50 ]          ;; spread them around\n  ask patches\n    [ if pxcor > 0         ;; patches on the right side\n        [ set pcolor green ] ]  ;; of the view turn green\n  reset-ticks\nend\n\nThe models in the Models Library are full of other examples. A good place to\nstart looking is in the Code Examples section.\nUsually, the observer uses ask to ask all turtles, all patches or all links\nto run commands. You can also use ask to have an individual turtle, patch or\nlink run commands. The reporters turtle, patch, link and\npatch-at are useful for this technique. For example:\nto setup\n  clear-all\n  crt 3                           ;; make 3 turtles\n  ask turtle 0                    ;; tell the first one...\n    [ fd 1 ]                      ;; ...to go forward\n  ask turtle 1                    ;; tell the second one...\n    [ set color green ]           ;; ...to become green\n  ask turtle 2                    ;; tell the third one...\n    [ rt 90 ]                     ;; ...to turn right\n  ask patch 2 -2                  ;; ask the patch at (2,-2)\n    [ set pcolor blue ]           ;; ...to become blue\n  ask turtle 0                    ;; ask the first turtle\n    [ ask patch-at 1 0            ;; ...to ask patch to the east\n      [ set pcolor red ] ]        ;; ...to become red\n  ask turtle 0                    ;; tell the first turtle...\n    [ create-link-with turtle 1 ] ;; ...make a link with the second\n  ask link 0 1                    ;; tell the link between turtle 0 and 1\n    [ set color blue ]            ;; ...to become blue\n  reset-ticks\nend\n\nEvery turtle created has a who number. The first turtle created is number 0, the\nsecond turtle number 1, and so forth.\nThe turtle primitive reporter takes a who number as an input, and reports\nthe turtle with that who number. The patch primitive reporter takes values\nfor pxcor and pycor and reports the patch with those coordinates. The link\nprimitive takes two inputs, the who numbers of the two turtles it connects. And\nthe patch-at primitive reporter takes offsets: distances, in the x and y\ndirections, from the first agent. In the example setup procedure above, the\nturtle with who number 0 is asked to get the patch east (and no patches north)\nof itself like this: ask turtle 0 [ ask patch-at 1 0 [ set pcolor red ] ].\nYou can also select a subset of turtles, or a subset of patches, or a subset of\nlinks and ask them to do something. This involves using agentsets. The next\nsection explains them in detail.\nWhen you ask a set of agents to run more than one command, each agent must\nfinish before the next agent starts. One agent runs all of the commands, then\nthe next agent runs all of them, and so on. For example, if you write:\nask turtles\n  [ fd 1\n    set color red ]\n\nfirst one turtle moves and turns red, then another turtle moves and turns red,\nand so on.\nBut if you write it this way:\nask turtles [ fd 1 ]\nask turtles [ set color red ]\n\nfirst all the turtles move, then they all turn red.\n"
    },
    "6": {
        "Section_title": "Agentsets",
        "Section_data": "Agentsets\nAn agentset is exactly what its name implies, a set of agents. An agentset can\ncontain either turtles, patches or links, but not more than one type at once.\nAn agentset is not in any particular order. In fact, it\u2019s always in a random\norder. And every time you use it, the agentset is in a different random order.\nThis helps you keep your model from treating any particular turtles, patches or\nlinks differently from any others (unless you want them to be). Since the order\nis random every time, no one agent always gets to go first.\nYou\u2019ve seen the turtles primitive, which reports the agentset of all\nturtles, the patches primitive, which reports the agentset of all patches\nand the links primitive which reports the agentset of all links.\nBut what\u2019s powerful about the agentset concept is that you can construct\nagentsets that contain only some turtles, some patches or some links. For\nexample, all the red turtles, or the patches with pxcor evenly divisible by\nfive, or the turtles in the first quadrant that are on a green patch or the\nlinks connected to turtle 0. These agentsets can then be used by ask or by\nvarious reporters that take agentsets as inputs.\nOne way is to use turtles-here or turtles-at, to make an agentset\ncontaining only the turtles on my patch, or only the turtles on some other patch\nat some x and y offsets. There\u2019s also turtles-on so you can get the set of\nturtles standing on a given patch or set of patches, or the set of turtles\nstanding on the same patch as a given turtle or set of turtles.\nHere are some more examples of how to make agentsets:\n;; all other turtles:\nother turtles\n;; all other turtles on this patch:\nother turtles-here\n;; all red turtles:\nturtles with [color = red]\n;; all red turtles on my patch\nturtles-here with [color = red]\n;; patches on right side of view\npatches with [pxcor > 0]\n;; all turtles less than 3 patches away\nturtles in-radius 3\n;; the four patches to the east, north, west, and south\npatches at-points [[1 0] [0 1] [-1 0] [0 -1]]\n;; shorthand for those four patches\nneighbors4\n;; turtles in the first quadrant that are on a green patch\nturtles with [(xcor > 0) and (ycor > 0)\n              and (pcolor = green)]\n;; turtles standing on my neighboring four patches\nturtles-on neighbors4\n;; all the links connected to turtle 0\n[my-links] of turtle 0\n\nNote the use of other to exclude this agent. This is common.\nOnce you have created an agentset, here are some simple things you can do:\n\nUse ask to make the agents in the agentset do something\nUse any? to see if the agentset is empty\nUse all? to see if every agent in an agentset satisfies a condition.\nUse count to find out exactly how many agents are in the set\n\nAnd here are some more complex things you can do:\n\n\nPick a random agent from the set using one-of. For example, we can make a\nrandomly chosen turtle turn green:\nask one-of turtles [ set color green ]\n\nOr tell a randomly chosen patch to sprout a new turtle:\nask one-of patches [ sprout 1 ]\n\n\n\nUse the max-one-of or\nmin-one-of reporters to find out which agent\nis the most or least along some scale. For example, to remove the richest\nturtle, you could say\nask max-one-of turtles [sum assets] [ die ]\n\n\n\nMake a histogram of the agentset using the histogram command (in\ncombination with of).\n\nUse of to make a list of values, one for each agent in the agentset. Then\nuse one of NetLogo\u2019s list primitives to do something with the list. (See the\n\u201cLists\u201d section below.) For example, to find out how rich turtles\nare on the average, you could say\nshow mean [sum assets] of turtles\n\n\n\nUse turtle-set, patch-set and link-set reporters to make new\nagentsets by gathering together agents from a variety of possible sources.\n\nUse no-turtles, no-patches and no-links reporters to make empty\nagentsets.\nCheck whether two agentsets are equal using = or !=.\nUse member? to see whether a particular agent is a member of an agentset.\n\nThis only scratches the surface. See the Models Library for many more examples,\nand consult the NetLogo Dictionary for more information about all of the\nagentset primitives.\nMore examples of using agentsets are provided in the individual entries for\nthese primitives in the NetLogo Dictionary.\nSpecial agentsets\nThe agentsets turtles and links have special behavior because they always\nhold the sets of all turtles and all links. Therefore, these agentsets can\ngrow.\nThe following interaction shows the special behavior. Assume the Code tab has\nglobals [g]. Then:\nobserver> clear-all\nobserver> create-turtles 5\nobserver> set g turtles\nobserver> print count g\n5\nobserver> create-turtles 5\nobserver> print count g\n10\nobserver> set g turtle-set turtles\nobserver> print count g\n10\nobserver> create-turtles 5\nobserver> print count g\n10\nobserver> print count turtles\n15\n\nThe turtles agentset grows when new turtles are born, but other agentsets\ndon\u2019t grow. If I write turtle-set turtles, I get a new, normal agentset\ncontaining just the turtles that currently exist. New turtles don\u2019t join when\nthey\u2019re born.\nBreed agentsets are special in the same way as turtles and links. Breeds are\nintroduced and explained below.\nAgentsets and lists\nEarlier, we said that agentsets are always in random order, a different random\norder every time. If you need your agents to do something in a fixed order, you\nneed to make a list of the agents instead. See the Lists section below.\n\nCode Example: Ask Ordering Example\n\n"
    },
    "7": {
        "Section_title": "Breeds",
        "Section_data": "Breeds\nNetLogo allows you to define different \u201cbreeds\u201d of turtles and breeds of links.\nOnce you have defined breeds, you can go on and make the different breeds behave\ndifferently. For example, you could have breeds called sheep and wolves, and\nhave the wolves try to eat the sheep or you could have link breeds called\nstreets and sidewalks where foot traffic is routed on sidewalks and car\ntraffic is routed on streets.\nYou define turtle breeds using the breed keyword, at the top of the Code\ntab, before any procedures:\nbreed [wolves wolf]\nbreed [sheep a-sheep]\n\nYou can refer to a member of the breed using the singular form, just like the\nturtle reporter. When printed, members of the breed will be labeled with the\nsingular name.\nSome commands and reporters have the plural name of the breed in them, such as\ncreate-<breeds>. Others have the singular name of the breed\nin them, such as <breed>.\nThe order in which breeds are declared is also the order in which they are\nlayered in the view. So breeds defined later will appear on top of breeds\ndefined earlier; in this example, sheep will be drawn over wolves.\nWhen you define a breed such as sheep, an agentset for that breed is\nautomatically created, so that all of the agentset capabilities described above\nare immediately available with the sheep agentset.\nThe following new primitives are also automatically available once you define a\nbreed: create-sheep, hatch-sheep,\nsprout-sheep, sheep-here, sheep-at,\nsheep-on, and is-a-sheep?.\nAlso, you can use sheep-own to define new turtle variables that\nonly turtles of the given breed have. (It\u2019s allowed for more than one breed to\nown the same variable.)\nA turtle\u2019s breed agentset is stored in the breed turtle variable.\nSo you can test a turtle\u2019s breed, like this:\nif breed = wolves [ ... ]\n\nNote also that turtles can change breeds. A wolf doesn\u2019t have to remain a wolf\nits whole life. Let\u2019s change a random wolf into a sheep:\nask one-of wolves [ set breed sheep ]\n\nThe set-default-shape primitive is useful for associating certain turtle\nshapes with certain breeds. See the section on shapes below.\nWho numbers are assigned irrespective of breeds. If you already have a frog 0,\nthen the first mouse will be mouse 1, not mouse 0, since the who number 0 is\nalready taken.\nHere is a quick example of using breeds:\nbreed [mice mouse]\nbreed [frogs frog]\nmice-own [cheese]\nto setup\n  clear-all\n  create-mice 50\n    [ set color white\n      set cheese random 10 ]\n  create-frogs 50\n    [ set color green ]\n  reset-ticks\nend\n\n\nCode Example: Breeds and Shapes Example\n\nLink breeds\nLink breeds are very similar to turtle breeds, however, there are a few\ndifferences.\nWhen you declare a link breed you must declare whether it is a breed of directed\nor undirected links by using the directed-link-breed and\nundirected-link-breed keywords.\ndirected-link-breed [streets street]\nundirected-link-breed [friendships friendship]\n\nOnce you have created a breeded link you cannot create unbreeded links and vice\nversa. (You can, however, have directed and undirected links in the same world,\njust not in the same breed)\nUnlike with turtle breeds the singular breed name is required for link breeds,\nas many of the link commands and reports use the singular name, such as\n<link-breed>-neighbor?.\nThe following primitives are also automatically available once you define a\ndirected link breed: create-street-from\ncreate-streets-from create-street-to\ncreate-streets-to in-street-neighbor?\nin-street-neighbors in-street-from\nmy-in-streets my-out-streets\nout-street-neighbor?\nout-street-neighbors out-street-to\nAnd the following are automatically available when you define an undirected link\nbreed: create-friendship-with\ncreate-friendships-with friendship-neighbor?\nfriendship-neighbors friendship-with\nmy-friendships\nMultiple link breeds may declare the same -own variable, but a variable may\nnot be shared between a turtle breed and a link breed.\nJust as with turtle breeds the order in which link breeds are declared defines\nthe order in which the links are drawn, so the friendships will always be on top\nof streets (if for some reason these breeds were in the same model). You can\nalso use <link-breeds>-own to declare variables of each link breed\nseparately.\nYou can change the breed of a link with set breed. (However, you cannot change\na breeded link to an unbreeded one, to prevent having breeded and unbreeded\nlinks in the same world.)\nask one-of friendships [ set breed streets ]\nask one-of friendships [ set breed links ] ;; produces a runtime error\n\nset-default-shape may also be used with link breeds to associate it with a\nparticular link shape.\n\nCode Example: Link Breeds Example\n\n"
    },
    "8": {
        "Section_title": "Buttons",
        "Section_data": "Buttons\nButtons in the interface tab provide an easy way to control the model. Typically\na model will have at least a \u201csetup\u201d button, to set up the initial state of the\nworld, and a \u201cgo\u201d button to make the model run continuously. Some models will\nhave additional buttons that perform other actions.\nA button contains some NetLogo code. That code is run when you press the button.\nA button may be either a \u201conce button\u201d, or a \u201cforever button\u201d. You can control\nthis by editing the button and checking or unchecking the \u201cForever\u201d checkbox.\nOnce buttons run their code once, then stop and pop back up. Forever buttons\nkeep running their code over and over again.\nA forever button stops if the user presses the button again to stop it. The\nbutton waits until the current iteration has finished, then pops up.\nA forever button can also be stopped from\ncode. If the forever button directly calls a procedure, then when that procedure\nstops, the button stops. (In a turtle or patch forever button, the button won\u2019t\nstop until every turtle or patch stops \u2013 a single turtle or patch doesn\u2019t have\nthe power to stop the whole button.)\nNormally, a button is labeled with the code that it runs. For example, a button\nthat says \u201cgo\u201d on it usually contains the code \u201cgo\u201d, which means \u201crun the go\nprocedure\u201d. (Procedures are defined in the Code tab; see below.) But you can\nalso edit a button and enter a \u201cdisplay name\u201d for the button, which is a text\nthat appears on the button instead of the code. You might use this feature if\nyou think the actual code would be confusing to your users.\nWhen you put code in a button, you must also specify which agents you want to\nrun that code. You can choose to have the observer run the code, or all turtles,\nor all patches, or all links. (If you want the code to be run by only some\nturtles or some patches, you could make an observer button, and then have the\nobserver use the ask command to ask only some of the turtles or patches to\ndo something.)\nWhen you edit a button, you have the option to assign an \u201caction key\u201d. This\nmakes that key on the keyboard behave just like a button press. If the button is\na forever button, it will stay down until the key is pressed again (or the\nbutton is clicked). Action keys are particularly useful for games or any model\nwhere rapid triggering of buttons is needed.\nButtons take turns\nMore than one button can be pressed at a time. If this happens, the buttons\n\u201ctake turns\u201d, which means that only one button runs at a time. Each button runs\nits code all the way through once while the other buttons wait, then the next\nbutton gets its turn.\nIn the following examples, \u201csetup\u201d is a once button and \u201cgo\u201d is a forever\nbutton.\nExample #1: The user presses \u201csetup\u201d, then presses \u201cgo\u201d immediately, before the\n\u201csetup\u201d has popped back up. Result: \u201csetup\u201d finishes before \u201cgo\u201d starts.\nExample #2: While the \u201cgo\u201d button is down, the user presses \u201csetup\u201d. Result: the\n\u201cgo\u201d button finishes its current iteration. Then the \u201csetup\u201d button runs. Then\n\u201cgo\u201d starts running again.\nExample #3: The user has two forever buttons down at the same time. Result:\nfirst one button runs its code all the way through, then the other runs its code\nall the way through, and so on, alternating.\nNote that if one button gets stuck in an infinite loop, then no other buttons\nwill run.\nTurtle, patch, and link forever buttons\nThere is a subtle difference between putting commands in a turtle, patch or link\nforever button, and putting the same commands in an observer button that does\nask turtles, ask patches or ask links. An \u201cask\u201d doesn\u2019t complete until all\nof the agents have finished running all of the commands in the \u201cask\u201d. So the\nagents, as they all run the commands concurrently, can be out of sync with each\nother, but they all sync up again at the end of the ask. The same isn\u2019t true of\nturtle, patch and link forever buttons. Since ask was not used, each turtle\nor patch runs the given code over and over again, so they can become (and\nremain) out of sync with each other.\nAt present, this capability is very rarely used in the models in our Models\nLibrary. A model that does use the capability is the Termites model, in the\nBiology section of Sample Models. The \u201cgo\u201d button is a turtle forever button, so\neach termite proceeds independently of every other termite, and the observer is\nnot involved at all. This means that if, for example, you wanted to add ticks\nand/or a plot to the model, you would need to add a second forever button (an\nobserver forever button), and run both forever buttons at the same time. Note\nalso that a model like this cannot be used with BehaviorSpace.\n\nCode Example: State Machine Example shows how Termites can be recoded in a\ntick-based way, without using a turtle forever button.\n\nAt present, NetLogo has no way for one forever button to start another. Buttons\nare only started when you press them.\n"
    },
    "9": {
        "Section_title": "Lists",
        "Section_data": "Lists\nIn the simplest models, each variable holds only one piece of information,\nusually a number or a string. Lists let you store multiple pieces of information\nin a single value by collecting that information in a list. Each value in the\nlist can be any type of value: a number, or a string, an agent or agentset, or\neven another list.\nLists allow for the convenient packaging of information in NetLogo. If your\nagents carry out a repetitive calculation on multiple variables, it might be\neasier to have a list variable, instead of multiple number variables. Several\nprimitives simplify the process of performing the same computation on each value\nin a list.\nThe NetLogo Dictionary has a section that lists all of the\nlist-related primitives.\nConstant lists\nYou can make a list by simply putting the values you want in the list between\nbrackets, like this: set mylist [2 4 6 8]. Note that the individual values are\nseparated by spaces. You can make lists that contain numbers and strings this\nway, as well as lists within lists, for example [[2 4] [3 5]].\nThe empty list is written by putting nothing between the brackets, like this:\n[].\nBuilding lists on the fly\nIf you want to make a list in which the values are determined by reporters, as\nopposed to being a series of constants, use the list reporter. The list\nreporter accepts two other reporters, runs them, and reports the results as a\nlist.\nIf I wanted a list to contain two random values, I might use the following code:\nset random-list list (random 10) (random 20)\n\nThis will set random-list to a new list of two random integers each time it\nruns.\nTo make longer or shorter lists, you can use the list reporter with fewer or\nmore than two inputs, but in order to do so, you must enclose the entire call in\nparentheses, e.g.:\n(list random 10)\n(list random 10 random 20 random 30)\n\nFor more information, see Varying number of inputs.\nSome kinds of lists are most easily built using the n-values reporter, which\nallows you to construct a list of a specific length by repeatedly running a\ngiven reporter. You can make a list of the same value repeated, or all the\nnumbers in a range, or a lot of random numbers, or many other possibilities. See\ndictionary entry for details and examples.\nThe of primitive lets you construct a list from an agentset. It reports a\nlist containing each agent\u2019s value for the given reporter. (The reporter could\nbe a simple variable name, or a more complex expression \u2013 even a call to a\nprocedure defined using to-report.) A common idiom is\nmax [...] of turtles\nsum [...] of turtles\n\nand so on.\nYou can combine two or more lists using the sentence reporter, which\nconcatenates lists by combining their contents into a single, larger list. Like\nlist, sentence normally takes two inputs, but can accept any number of\ninputs if the call is surrounded by parentheses.\nChanging list items\nTechnically, lists can\u2019t be modified, but you can construct new lists based on\nold lists. If you want the new list to replace the old list, use set. For\nexample:\nset mylist [2 7 5 Bob [3 0 -2]]\n; mylist is now [2 7 5 Bob [3 0 -2]]\nset mylist replace-item 2 mylist 10\n; mylist is now [2 7 10 Bob [3 0 -2]]\n\nThe replace-item reporter takes three inputs. The first input specifies\nwhich item in the list is to be changed. 0 means the first item, 1 means the\nsecond item, and so forth.\nTo add an item, say 42, to the end of a list, use the lput reporter.\n(fput adds an item to the beginning of a list.)\nset mylist lput 42 mylist\n; mylist is now [2 7 10 Bob [3 0 -2] 42]\n\nBut what if you changed your mind? The but-last (bl for\nshort) reporter reports all the list items but the last.\nset mylist but-last mylist\n; mylist is now [2 7 10 Bob [3 0 -2]]\n\nSuppose you want to get rid of item 0, the 2 at the beginning of the list.\nset mylist but-first mylist\n; mylist is now [7 10 Bob [3 0 -2]]\n\nSuppose you wanted to change the third item that\u2019s nested inside item 3 from -2\nto 9? The key is to realize that the name that can be used to call the nested\nlist [3 0 -2] is item 3 mylist. Then the replace-item reporter can be\nnested to change the list-within-a-list. The parentheses are added for clarity.\nset mylist (replace-item 3 mylist\n                  (replace-item 2 (item 3 mylist) 9))\n; mylist is now [7 10 Bob [3 0 9]]\n\nIterating over lists\nIf you want to do some operation on each item in a list in turn, the foreach\ncommand and the map reporter may be helpful.\nforeach is used to run a command or commands on each item in a list. It\ntakes an input list and a command name or block of commands, like this:\nforeach [1 2 3] show\n=> 1\n=> 2\n=> 3\nforeach [2 4 6]\n  [ n -> crt n\n    show (word \"created \" n \" turtles\") ]\n=> created 2 turtles\n=> created 4 turtles\n=> created 6 turtles\n\nIn the block, the variable n holds the current value from the input list.\nHere are some more examples of foreach:\nforeach [1 2 3] [ steps -> ask turtles [ fd steps ] ]\n;; turtles move forward 6 patches\nforeach [true false true true] [ should-move? -> ask turtles [ if should-move? [ fd 1 ] ] ]\n;; turtles move forward 3 patches\n\nmap is similar to foreach, but it is a reporter. It takes an input list\nand a reporter name or reporter block. Note that unlike foreach, the\nreporter comes first, like this:\nshow map round [1.2 2.2 2.7]\n;; prints [1 2 3]\n\nmap reports a list containing the results of applying the reporter to each\nitem in the input list. Again, use the variable named in the anonymous procedure\n(x in the examples below) to refer to the current item in the list.\nHere are a couple more examples of map:\nshow map [ x -> x < 0 ] [1 -1 3 4 -2 -10]\n;; prints [false true false false true true]\nshow map [ x -> x * x ] [1 2 3]\n;; prints [1 4 9]\n\nBesides map and foreach, other primitives for processing whole lists in a\nconfigurable way include filter, reduce, and sort-by.\nThese primitives aren\u2019t always the solution for every situation in which you\nwant to operate on an entire list. In some situations, you may need to use some\nother technique such as a loop using repeat or while, or a recursive\nprocedure.\nThe blocks of code we\u2019re giving to map and foreach in these examples are\nactually anonymous procedures. Anonymous procedures are explained in more\ndetail in Anonymous procedures, below.\nVarying number of inputs\nSome commands and reporters involving lists and strings may take a varying\nnumber of inputs. In these cases, in order to pass them a number of inputs other\nthan their default, the primitive and its inputs must be surrounded by\nparentheses. Here are some examples:\nshow list 1 2\n=> [1 2]\nshow (list 1 2 3 4)\n=> [1 2 3 4]\nshow (list)\n=> []\n\nNote that each of these special primitives has a default number of inputs for\nwhich no parentheses are required. The primitives which have this capability are\nlist, word, sentence, map, foreach, run, and\nrunresult.\nLists of agents\nEarlier, we said that agentsets are always in random order, a different random\norder every time. If you need your agents to do something in a fixed order, you\nneed to make a list of the agents instead.\nThere are two primitives that help you do this, sort and sort-by.\nBoth sort and sort-by can take an agentset as input. The result is\nalways a new list, containing the same agents as the agentset did, but in a\nparticular order.\nIf you use sort on an agentset of turtles, the result is a list of turtles\nsorted in ascending order by who number.\nIf you use sort on an agentset of patches, the result is a list of patches\nsorted left-to-right, top-to-bottom.\nIf you use sort on an agentset of links, the result is a list of links,\nsorted in ascending order first by end1 then by end2 any remaining ties\nare resolved by breed in the order they are declared in the Code\ntab.\nIf you need descending order instead, you can combine reverse with sort,\nfor example reverse sort turtles.\nIf you want your agents to be ordered by some other criterion than the standard\nones sort uses, you\u2019ll need to use sort-by instead.\nHere\u2019s an example:\nsort-by [ [a b] -> [size] of a < [size] of b ] turtles\n\nThis returns a list of turtles sorted in ascending order by their turtle\nvariable size.\nThere\u2019s a common pattern to get a list of agents in a random order, using a\ncombination of of and self, in the rare case that you cannot just use\nask:\n[self] of my-agentset\n\nAsking a list of agents\nOnce you have a list of agents, you might want to ask them each to do something.\nTo do this, use the foreach and ask commands in combination, like this:\nforeach sort turtles [ the-turtle ->\n  ask the-turtle [\n    ...\n  ]\n]\n\nThis will ask each turtle in ascending order by who number. Substitute \u201cpatches\u201d\nfor \u201cturtles\u201d to ask patches in left-to-right, top-to-bottom order.\nNote that you can\u2019t use ask directly on a list of turtles. ask only\nworks with agentsets and single agents.\nPerformance of lists\nThe data structure underlying NetLogo\u2019s lists is a sophisticated tree-based data\nstructure on which most operations run in near-constant time. That includes\nfput, lput, butfirst, butlast, length, item, and replace-item.\nOne exception to the fast-performance rule is that concatenating two lists with\nsentence requires traversing and copying the whole second list. (This may be\nfixed in a future version.)\nTechnically, \u201cnear-constant time\u201d is actually logarithmic time, proportional to\nthe depth of the underlying tree, but these trees have large nodes and a high\nbranching factor, so they are never more than a few levels deep. This means that\nchanges can be made in at most a few steps. The trees are immutable, but they\nshare structure with each other, so the whole tree doesn\u2019t need to be copied to\nmake a changed version.\nThe actual data structure used is the immutable Vector class from the Scala\ncollections library. These are 32-wide\nhash array mapped tries,\nas implemented by Tiark Rompf, based in part on work by Phil Bagwell and Rich\nHickey.\n"
    },
    "10": {
        "Section_title": "Math",
        "Section_data": "Math\nAll numbers in NetLogo are stored internally as double precision floating point\nnumbers, as defined in the IEEE 754 standard. They are 64 bit numbers consisting\nof one sign bit, an 11-bit exponent, and a 52-bit mantissa. See the IEEE 754\nstandard for details.\nAn \u201cinteger\u201d in NetLogo is simply a number that happens to have no fractional\npart. No distinction is made between 3 and 3.0; they are the same number. (This\nis the same as how most people use numbers in everyday contexts, but different\nfrom some programming languages. Some languages treat integers and floating\npoint numbers as distinct types.)\nIntegers are always printed by NetLogo without the trailing \u201c.0\u201d:\nshow 1.5 + 1.5\nobserver: 3\n\nIf a number with a fractional part is supplied in a context where an integer is\nexpected, the fractional part is simply discarded. So for example, crt 3.5\ncreates three turtles; the extra 0.5 is ignored.\nThe range of integers is +/-9007199254740992 (2^53, about 9 quadrillion).\nCalculations that exceed this range will not cause runtime errors, but precision\nwill be lost when the least significant (binary) digits are rounded off in order\nfit the number into 64 bits. With very large numbers, this rounding can result\nin imprecise answers which may be surprising:\nshow 2 ^ 60 + 1 = 2 ^ 60\n=> true\n\nCalculations with smaller numbers can also produce surprising results if they\ninvolve fractional quantities, since not all fractions can be precisely\nrepresented and roundoff may occur. For example:\nshow 1 / 6 + 1 / 6 + 1 / 6 + 1 / 6 + 1 / 6 + 1 / 6\n=> 0.9999999999999999\nshow 1 / 9 + 1 / 9 + 1 / 9 + 1 / 9 + 1 / 9 + 1 / 9 + 1 / 9 + 1 / 9 + 1 / 9\n=> 1.0000000000000002\n\nAny operation which produces the special quantities \u201cinfinity\u201d or \u201cnot a number\u201d\nwill cause a runtime error.\nScientific notation\nVery large or very small floating point numbers are displayed by NetLogo using\n\u201cscientific notation\u201d. Examples:\nshow 0.000000000001\n=> 1.0E-12\nshow 50000000000000000000\n=> 5.0E19\n\nNumbers in scientific notation are distinguished by the presence of the letter E\n(for \u201cexponent\u201d). It means \u201ctimes ten to the power of\u201d, so for example, 1.0E-12\nmeans 1.0 times 10 to the -12 power:\nshow 1.0 * 10 ^ -12\n=> 1.0E-12\n\nYou can also use scientific notation yourself in NetLogo code:\nshow 3.0E6\n=> 3000000\nshow 8.123456789E6\n=> 8123456.789\nshow 8.123456789E7\n=> 8.123456789E7\nshow 3.0E16\n=> 3.0E16\nshow 8.0E-3\n=> 0.0080\nshow 8.0E-4\n=> 8.0E-4\n\nThese examples show that numbers with fractional parts are displayed using\nscientific notation if the exponent is less than -3 or greater than 6. Numbers\noutside of NetLogo\u2019s integer range of -9007199254740992 to 9007199254740992\n(+/-2^53) are also always shown in scientific notation:\nshow 2 ^ 60\n=> 1.15292150460684698E18\n\nWhen entering a number, the letter E may be either upper or lowercase. When\nprinting a number, NetLogo always uses an uppercase E:\nshow 4.5e20\n=> 4.5E20\n\nFloating point accuracy\nBecause numbers in NetLogo are subject to the limitations of how floating point\nnumbers are represented in binary, you may get answers that are slightly\ninaccurate. For example:\nshow 0.1 + 0.1 + 0.1\n=> 0.30000000000000004\nshow cos 90\n=> 6.123233995736766E-17\n\nThis is an inherent issue with floating point arithmetic; it occurs in all\nprogramming languages that use floating point numbers.\nIf you are dealing with fixed precision quantities, for example dollars and\ncents, a common technique is to use only integers (cents) internally, then\ndivide by 100 to get a result in dollars for display.\nIf you must use floating point numbers, then in some situations you may need to\nreplace a straightforward equality test such as if x = 1 [ ... ] with a test\nthat tolerates slight imprecision, for example\nif abs (x - 1) < 0.0001 [ ... ].\nAlso, the precision primitive is handy for rounding off numbers for display\npurposes. NetLogo monitors round the numbers they display to a configurable\nnumber of decimal places, too.\n"
    },
    "11": {
        "Section_title": "Random numbers",
        "Section_data": "Random numbers\nThe random numbers used by NetLogo are what is called \u201cpseudo-random\u201d. (This is\ntypical in computer programming.) That means they appear random, but are in fact\ngenerated by a deterministic process. \u201cDeterministic\u201d means that you get the\nsame results every time, if you start with the same random \u201cseed\u201d. We\u2019ll explain\nin a minute what we mean by \u201cseed\u201d.\nIn the context of scientific modeling, pseudo-random numbers are actually\ndesirable. That\u2019s because it\u2019s important that a scientific experiment be\nreproducible \u2013 so anyone can try it themselves and get the same result that you\ngot. Since NetLogo uses pseudo-random numbers, the \u201cexperiments\u201d that you do\nwith it can be reproduced by others.\nHere\u2019s how it works. NetLogo\u2019s random number generator can be started with a\ncertain seed value, which must be an integer in the range -2147483648 to\n2147483647. Once the generator has been \u201cseeded\u201d with the random-seed\ncommand, it always generates the same sequence of random numbers from then on.\nFor example, if you run these commands:\nrandom-seed 137\nshow random 100\nshow random 100\nshow random 100\n\nYou will always get the numbers 79, 89, and 61 in that order.\nNote, however, that you\u2019re only guaranteed to get those same numbers if you\u2019re\nusing the same version of NetLogo. Sometimes when we make a new version of\nNetLogo the random number generator changes. (Presently, we use a generator\nknown as the Mersenne Twister.)\nTo create a number suitable for seeding the random number generator, use the\nnew-seed reporter. new-seed creates a seed, evenly distributed over the\nspace of possible seeds, based on the current date and time. It never reports\nthe same seed twice in a row.\n\nCode Example: Random Seed Example\n\nIf you don\u2019t set the random seed yourself, NetLogo sets it to a value based on\nthe current date and time. There is no way to find out what random seed it\nchose, so if you want your model run to be reproducible, you must set the random\nseed yourself ahead of time.\nThe NetLogo primitives with \u201crandom\u201d in their names (random, random-float, and\nso on) aren\u2019t the only ones that use pseudo-random numbers. Many other\noperations also make random choices. For example, agentsets are always in random\norder, one-of and n-of choose agents randomly, the sprout command\ncreates turtles with random colors and headings, and the downhill reporter\nchooses a random patch when there\u2019s a tie. All of these random choices are\ngoverned by the random seed as well, so model runs can be reproducible.\nIn addition to the uniformly distributed random integers and floating point\nnumbers generated by random and random-float, NetLogo also offers\nseveral other random distributions. See the dictionary entries for\nrandom-normal, random-poisson,\nrandom-exponential, and random-gamma.\nAuxiliary generator\nCode run by buttons or from the command center uses the main random number\ngenerator.\nCode in monitors uses an auxiliary random generator, so even if a monitor does a\ncalculation that uses random numbers, the outcome of the model is not affected.\nThe same is true of code in sliders.\nLocal randomness\nYou may want to explicitly specify that a section of code does not affect the\nstate of the main random generator, so the outcome of the model is not affected.\nThe with-local-randomness command is provided for this purpose. See its\nentry in the NetLogo Dictionary for more information.\nSaving a Random Seed for a Run\nIf you want to know what the random seed used by a \u201crun\u201d of a model was, you can\nadd some simple code to track it.  Then if an interesting behavior emerges or\nan intermittent error condition occurs, you have a way to reproduce the run by\ngrabbing the seed and re-using it.\nAdd a starting-seed global variable, then use new-seed to give it a value\nafter you use clear-all in your setup procedure.  Then give that value\nto the random-seed command so it will be used for the rest of the run.\nglobals [starting-seed]\n\nto setup\n  clear-all\n  set starting-seed new-seed\n  random-seed starting-seed\n  ; ... rest of normal setup code\nend\n\nto go\n  ; ... the rest of normal model code will use the random seed set in `setup`\nend\n\nYou can then add a monitor for the starting-seed global or simply output it\nto the command center whenever you want to know its value.  If you are using\nBehaviorSpace to run experiments, you can also include it in the output to be\nable to later reproduce runs that it generates.\n"
    },
    "12": {
        "Section_title": "Turtle shapes",
        "Section_data": "Turtle shapes\nIn NetLogo, turtle shapes are vector shapes. They are built up from basic\ngeometric shapes; squares, circles, and lines, rather than a grid of pixels.\nVector shapes are fully scalable and rotatable. NetLogo caches bitmap images of\nvector shapes size 1, 1.5, and 2 in order to speed up execution.\nA turtle\u2019s shape is stored in its shape variable and can be set using the\nset command.\nNew turtles have a shape of \u201cdefault\u201d. The set-default-shape primitive is\nuseful for changing the default turtle shape to a different shape, or having a\ndifferent default turtle shape for each breed of turtle.\nThe shapes primitive reports a list of currently available turtle shapes in\nthe model. This is useful if, for example, you want to assign a random shape to\na turtle:\nask turtles [ set shape one-of shapes ]\n\nUse the Turtle Shapes Editor to create your own turtle shapes, or to add shapes\nto your model from our shapes library, or to transfer shapes between models. For\nmore information, see the Shapes Editor section of this manual.\nThe thickness of the lines used to draw the vector shapes can be controlled by\nthe __set-line-thickness primitive.\n\nCode Examples: Breeds and Shapes Example, Shape Animation Example\n\n"
    },
    "13": {
        "Section_title": "Link shapes",
        "Section_data": "Link shapes\nLink Shapes are similar to turtle shapes, only you use the Link Shape Editor to\ncreate and edit them. Link shapes consist of between 0 and 3 lines which can\nhave different patterns and a direction indicator that is composed of the same\nelements as turtle shapes. Links also have a shape variable that can be set\nto any link shape that is in the model. By default links have the \u201cdefault\u201d\nshape, though you can change that using set-default-shape. The\nlink-shapes reporter reports all the link shapes included in the current\nmodel.\nThe thickness of the lines in the link shape is controlled by the thickness\nlink variable.\n"
    },
    "14": {
        "Section_title": "View updates",
        "Section_data": "View updates\nThe \u201cview\u201d in NetLogo lets you see the agents in your model on your computer\u2019s\nscreen. As your agents move and change, you see them moving and changing in the\nview.\nOf course, you can\u2019t really see your agents directly. The view is a picture that\nNetLogo paints, showing you how your agents look at a particular instant. Once\nthat instant passes and your agents move and change some more, that picture\nneeds to be repainted to reflect the new state of the world. Repainting the\npicture is called \u201cupdating\u201d the view.\nWhen does the view get updated? This section discusses how NetLogo decides when\nto update the view, and how you can influence when it gets updated.\nNetLogo offers two updates modes, \u201ccontinuous\u201d updates and \u201ctick-based\u201d updates.\nYou can switch between NetLogo\u2019s two view update modes using a popup menu at the\ntop of the Interface tab.\nContinuous updates are the default when you start up NetLogo or start a new\nmodel. Nearly every model in our Models Library, however, uses tick-based\nupdates.\nContinuous updates are simplest, but tick-based updates give you more control\nover when and how often updates happen.\nIt\u2019s important exactly when an update happens, because when updates happen\ndetermines what you see on the screen. If an update comes at an unexpected time,\nyou may see something unexpected \u2013 perhaps something confusing or misleading.\nIt\u2019s also important how often updates happen, because updates take time. The\nmore time NetLogo spends updating the view, the slower your model will run. With\nfewer updates, your model runs faster.\nContinuous updates\nContinuous updates are very simple. With continuous updates, NetLogo updates the\nview a certain number of times per second \u2013 by default, 30 times a second when\nthe speed slider is in the default, middle setting.\nIf you move the speed slider to a slower setting, NetLogo will update more than\n30 times a second, effectively slowing down the model. On a faster setting,\nNetLogo will update less than 30 times a second. On the fastest setting, updates\nwill be separated by several seconds.\nAt extremely slow settings, NetLogo will be updating so often that you will see\nyour agents moving (or changing color, etc.) one at a time.\nIf you need to temporarily shut off continuous updates, use the no-display\ncommand. The display command turns updates back on, and also forces an\nimmediate update (unless the user is fast-forwarding the model using the speed\nslider).\nTick-based updates\nAs discussed above in the Tick Counter section, in many NetLogo\nmodels, time passes in discrete steps, called \u201cticks\u201d. Typically, you want the\nview to update once per tick, between ticks. That\u2019s the default behavior with\ntick-based updates.\nIf you want additional view updates, you can force an update using the\ndisplay command. (The update may be skipped if the user is fast-forwarding\nthe model using the speed slider.)\nYou don\u2019t have to use the tick counter to use tick-based updates. If the tick\ncounter never advances, the view will update only when you use the display\ncommand.\nIf you move the speed slider to a fast enough setting, eventually NetLogo will\nskip some of the updates that would ordinarily have happened. Moving the speed\nslider to a slower setting doesn\u2019t cause additional updates; rather, it makes\nNetLogo pause after each update. The slower the setting, the longer the pause.\nEven under tick-based updates, the view also updates whenever a button in the\ninterface pops up (both once and forever buttons) and when a command entered in\nthe Command Center finishes. So it\u2019s not necessary to add the display\ncommand to once buttons that don\u2019t advance the tick counter. Many forever\nbuttons that don\u2019t advance the tick counter do need to use the display\ncommand. An example in the Models Library is the Life model (under\nComputer Science -> Cellular Automata). The forever buttons that let the user\ndraw in the view use the display command so the user can see what they are\ndrawing, even though the tick counter is not advancing.\nChoosing a mode\nAdvantages of tick-based updates over continuous updates include:\n\nConsistent, predictable view update behavior which does not vary from\ncomputer to computer or from run to run.\nContinuous updates can confuse the user of your model by letting them see\nmodel states they aren\u2019t supposed to see, which may be misleading.\nSince setup buttons don\u2019t advance the tick counter, they are unaffected by\nthe speed slider; this is normally the desired behavior.\n\nNearly every model in our Models Library uses tick-based updates.\nContinuous updates are occasionally useful for those rare models in which\nexecution is not divided into short, discrete phases. An example in the Models\nLibrary is Termites. (See also, however, the State Machine Example model, which\nshows how to re-code Termites using ticks.)\nEven for models that would normally be set to tick-based updates, it may be\nuseful to switch to continuous updates temporarily for debugging purposes.\nSeeing what\u2019s going on within a tick, instead of only seeing the end result of a\ntick, could help with troubleshooting. After switching to continuous updates,\nyou may want to use the speed slider to slow the model down until you see your\nagents moving one at a time. Don\u2019t forget to change back to tick-based updates\nwhen you are done, as the choice of update mode is saved with the model.\nChanging the update mode also affects model speed. Updating the view takes time;\noften enforcing a single update per tick (by using tick-based updates) will make\nyour model faster. On the other hand, continuous updates will be faster when\nrunning a single tick is faster than drawing a frame of the model. Most models\nrun faster under tick-based updates, but for an example of a model which is\nfaster with continuous updates see the \u201cHeroes and Cowards\u201d library model.\nFrame rate\nOne of the model settings in NetLogo\u2019s \u201cSettings\u2026\u201d dialog is \u201cFrame rate\u201d\nwhich defaults to 30 frames per second.\nThe frame rate setting affects both continuous updates and tick-based updates.\nWith continuous updates, the setting directly determines the frequency of\nupdates.\nWith tick-based updates, the setting is a ceiling on how many updates per\nsecond you get. If the frame rate is 30, then NetLogo will ensure that the model\nnever runs faster than that when the speed slider is in the default position. If\nany frame takes less than 1/30 of a second to compute and display, NetLogo will\npause and wait until the full 1/30 of a second has passed before continuing.\nThe frame rate settings lets you set what you consider to be a normal speed for\nyour model. Then you, or the user of your model, can use the speed slider to\ntemporarily get a faster or slower speed.\n"
    },
    "15": {
        "Section_title": "Plotting",
        "Section_data": "Plotting\nNetLogo\u2019s plotting features let you create plots to help you understand what\u2019s\ngoing on in your model.\nBefore you can plot, you need to create one or more plots in the Interface tab.\nFor more information on using and editing plots in the Interface tab, see the\nInterface Guide.\nPlotting points\nThe two basic commands for actually plotting things are plot and plotxy.\nWith plot you need only specify the y value you want plotted. The x value will\nautomatically be 0 for the first point you plot, 1 for the second, and so on.\n(That\u2019s if the plot pen\u2019s \u201cinterval\u201d is the default value of 1; you can change\nthe interval.)\nThe plot command is especially handy when you want your model to plot a new\npoint at every time step. Example:\nplot count turtles\n\nIf you need to specify both the x and y values of the point you want plotted,\nthen use plotxy instead. This example assumes that a global variable called\ntime exists:\nplotxy time count-turtles\n\nPlot commands\nEach plot and its pens have setup and update code fields that may contain\ncommands (usually containing plot or plotxy). These commands are run\nautomatically triggered by other commands in NetLogo.\nPlot setup commands and pen setup commands are run when the either reset-ticks\nor setup-plots commands are run. If the stop command is run in the body of\nthe plot setup commands then the pen setup commands will not run.\nPlot update commands and pen update commands are run when the either\nreset-ticks, tick or update-plots commands are run. If the stop command\nis run in the body of the plot update commands then the pen update commands will\nnot run.\nHere are the four commands that trigger plotting explained in more detail.\n\nsetup-plots executes commands for one plot at a time. For each plot, the\nplot\u2019s setup commands are executed. If the stop command is not encountered\nwhile running those commands, then each of the plot\u2019s pens will have their\nsetup code executed.\nupdate-plots is very similar to setup-plots. For each plot, the plot\u2019s\nupdate commands are executed. If the stop command is not encountered while\nrunning those commands, then each of the plot\u2019s pens will have their update\ncode executed.\ntick is exactly the same as update-plots except that the tick counter is\nincremented before the plot commands are executed.\nreset-ticks first resets the tick counter to 0, and then does the equivalent\nof setup-plots followed by update-plots.\n\nA typical model will use reset-ticks and tick like so:\nto setup\n  clear-all\n  ...\n  reset-ticks\nend\n\nto go\n  ...\n  tick\nend\n\nNote that in this example we plot from both the setup and go procedures\n(because reset-ticks runs plot setup and plot update commands). We do this\nbecause we want our plot to include the initial state of the system at the end\nof setup. We plot at the end of the go procedure, not the beginning, because\nwe want the plot always to be up to date after the go button stops.\nModels that don\u2019t use ticks but still want to do plotting will instead use\nsetup-plots and update-plots. In the previous code, replace reset-ticks\nwith setup-plots update-plots and replace tick with update-plots.\n\nCode Example: Plotting Example\n\nOther kinds of plots\nBy default, NetLogo plot pens plot in line mode, so that the points you plot are\nconnected by a line.\nIf you want to move the pen without plotting, you can use the plot-pen-up\ncommand. After this command is issued, the plot and plotxy commands move the\npen but do not actually draw anything. Once the pen is where you want it, use\nplot-pen-down to put the pen back down.\nIf you want to plot individual points instead of lines, or you want to draw bars\ninstead of lines or points, you need to change the plot pen\u2019s \u201cmode\u201d. Three\nmodes are available: line, bar, and point. Line is the default mode.\nNormally, you change a pen\u2019s mode by editing the plot. This changes the pen\u2019s\ndefault mode. It\u2019s also possible to change the pen\u2019s mode temporarily using the\nset-plot-pen-mode command. That command takes a number as input: 0 for line, 1\nfor bar, 2 for point.\nHistograms\nA histogram is a special kind of plot that measures how frequently certain\nvalues, or values in certain ranges, occur in a collection of numbers that arise\nin your model.\nFor example, suppose the turtles in your model have an age variable. You could\ncreate a histogram of the distribution of ages among your turtles with the\nhistogram command, like this:\nhistogram [age] of turtles\n\nThe numbers you want to histogram don\u2019t have to come from an agentset; they\ncould be any list of numbers.\nNote that using the histogram command doesn\u2019t automatically switch the current\nplot pen to bar mode. If you want bars, you have to set the plot pen to bar mode\nyourself. (As we said before, you can change a pen\u2019s default mode by editing the\nplot in the Interface tab.)\nLike other types of plots, histograms can be set to auto scale. However, auto\nscaled histograms do not automatically resize themselves horizontally like other\nplot types do. To set the range programmatically, you can use the\nset-plot-x-range primitive.\nThe width of the bars in a histogram is controlled by the plot pen\u2019s interval.\nYou can set a plot pen\u2019s default interval by editing the plot in the Interface\ntab. You can also change the interval temporarily with the\nset-plot-pen-interval command or the set-histogram-num-bars. If you use the\nlatter command, NetLogo will set the interval appropriately so as to fit the\nspecified number of bars within the plot\u2019s current x range.\n\nCode Example: Histogram Example\n\nClearing and resetting\nYou can clear the current plot with the clear-plot command, or clear every\nplot in your model with clear-all-plots. The clear-all command also clears\nall plots, in addition to clearing everything else in your model.\nIf you want to remove only the points that a particular pen has drawn, use\nplot-pen-reset.\nWhen a whole plot is cleared, or when a pen is reset, that doesn\u2019t just remove\nthe data that has been plotted. It also restores the plot or pen to its default\nsettings, as they were specified in the Interface tab when the plot was created\nor last edited. Therefore, the effects of such commands as\nset-plot-background-color, set-plot-x-range and set-plot-pen-color are\nonly temporary.\nRanges and auto scaling\nThe default x and y ranges for a plot are fixed numbers, but they can be changed\nat setup time or as the model runs.\nTo change the ranges at any time, use set-plot-x-range and set-plot-y-range.\nOr, you can let the ranges grow automatically. Either way, when the plot is\ncleared the ranges will return to their default values.\nBy default, all NetLogo plots have the auto scaling feature enabled. This means\nthat if the model tries to plot a point which is outside the current displayed\nrange, the range of the plot will grow along one or both axes so that the new\npoint is visible. Histogram plots, however, do not auto scale horizontally.\nIn the hope that the ranges won\u2019t have to change every time a new point is\nadded, when the ranges grow they leave some extra room: 25% if growing\nhorizontally, 10% if growing vertically.\nIf you want to turn off this feature, edit the plot and uncheck the\n\u201cAuto Scale?\u201d checkbox. At present, it is not possible to enable or disable this\nfeature only on one axis; it always applies to both axes.\nUsing a Legend\nYou can show the legend of a plot by checking the \u201cShow legend\u201d checkbox in the\nedit dialog. If you don\u2019t want a particular pen to show up in the legend you can\nuncheck the \u201cShow in Legend\u201d checkbox for that pen also in the advanced plot pen\nsettings (the advanced plot pen settings can be opened by clicking the pencil\nbutton for that pen in the plot pens table in the plot edit dialog).\nTemporary plot pens\nMost plots can get along with a fixed number of pens. But some plots have more\ncomplex needs; they may need to have the number of pens vary depending on\nconditions. In such cases, you can make \u201ctemporary\u201d plot pens from code and then\nplot with them. These pens are called \u201ctemporary\u201d because they vanish when the\nplot is cleared (by the clear-plot, clear-all-plots, or clear-all\ncommands).\nTo create a temporary plot pen, use the create-temporary-plot-pen command.\nTypically, this would be done in the Code tab, but it is also possible to use\nthis command from plot setup or plot update code (in the edit dialog). By\ndefault, the new pen is down, is black in color, has an interval of 1, and plots\nin line mode. Commands are available to change all of these settings; see the\nPlotting section of the NetLogo Dictionary.\nBefore you can use the pen, you\u2019ll have to use the use the set-current-plot\nand set-current-plot-pen commands. These are explained in the next section.\nset-current-plot and set-current-plot-pen\nBefore NetLogo 5, it was not possible to put plot commands in the plot itself.\nAll of the plot code was written in the Code tab with the rest of the code. For\nbackwards compatibility, and for temporary plot pens, this is still supported.\nModels in previous versions of NetLogo (and those using temporary plot pens)\nhave to explicitly state which plot is the current plot with the\nset-current-plot command and which pen is the current pen with the\nset-current-plot-pen command.\nTo set the current plot use the set-current-plot command with the name of the\nplot enclosed in double quotes, like this:\nset-current-plot \"Distance vs. Time\"\n\nThe name of the plot must be exactly as you typed it when you created the plot.\nNote that later if you change the name of the plot, you\u2019ll also have to update\nthe set-current-plot calls in your model to use the new name. (Copy and paste\ncan be helpful here.)\nFor a plot with multiple pens, you can manually specify which pen you want to\nplot with. If you don\u2019t specify a pen, plotting will take place with the first\npen in the plot. To plot with a different pen, the set-current-plot-pen\ncommand was used with the name of the pen enclosed in double quotes, like this:\nset-current-plot-pen \"distance\"\n\nOnce the current pen is set, then commands like plot count turtles can be\nexecuted for that pen.\nOlder models with plots usually had their own do-plotting procedure that\nlooked something like this:\nto do-plotting\n  set-current-plot \"populations\"\n  set-current-plot-pen \"sheep\"\n  plot count sheep\n  set-current-plot-pen \"wolves\"\n  plot count wolves\n\n  set-current-plot \"next plot\"\n  ...\nend\n\nOnce again, this is no longer necessary in NetLogo 5, unless you are using\ntemporary plot pens.\nConclusion\nNot every aspect of NetLogo\u2019s plotting system has been explained here. See the\nPlotting section of the NetLogo Dictionary for information on additional\ncommands and reporters related to plotting.\nMany of the Sample Models in the Models Library illustrate various advanced\nplotting techniques. Also check out the following code examples:\n\nCode Examples: Plot Axis Example, Plot Smoothing Example, Rolling Plot Example\n\n"
    },
    "16": {
        "Section_title": "Strings",
        "Section_data": "Strings\nStrings may contain any Unicode characters.\nTo input a constant string in NetLogo, surround it with double quotes.\nThe empty string is written by putting nothing between the quotes, like this:\n\"\".\nMost of the list primitives work on strings as well:\nbut-first \"string\" => \"tring\"\nbut-last \"string\" => \"strin\"\nempty? \"\" => true\nempty? \"string\" => false\nfirst \"string\" => \"s\"\nitem 2 \"string\" => \"r\"\nlast \"string\" => \"g\"\nlength \"string\" => 6\nmember? \"s\" \"string\" => true\nmember? \"rin\" \"string\" => true\nmember? \"ron\" \"string\" => false\nposition \"s\" \"string\" => 0\nposition \"rin\" \"string\" => 2\nposition \"ron\" \"string\" => false\nremove \"r\" \"string\" => \"sting\"\nremove \"s\" \"strings\" => \"tring\"\nreplace-item 3 \"string\" \"o\" => \"strong\"\nreverse \"string\" => \"gnirts\"\n\nA few primitives are specific to strings, such as\nis-string?, substring, and word:\nis-string? \"string\" => true\nis-string? 37 => false\nsubstring \"string\" 2 5 => \"rin\"\nword \"tur\" \"tle\" => \"turtle\"\n\nStrings can be compared using the =, !=, <, >, <=, and >= operators.\nIf you need to embed a special character in a string, use the following escape\nsequences:\n\n\\n = newline\n\\t = tab\n\\\" = double quote\n\\\\ = backslash\n\n"
    },
    "17": {
        "Section_title": "Output",
        "Section_data": "Output\nThis section is about output to the screen. Output to the screen can also be\nlater saved to a file using the export-output command. If you\nneed a more flexible method of writing data to external files, see the next\nsection, File I/O.\nThe basic commands for generating output to the screen in NetLogo are\nprint, show, type, and write. These commands send their output\nto the Command Center.\nFor full details on these four commands, see their entries in the NetLogo\nDictionary. Here is how they are typically used:\n\nprint is useful in most situations.\nshow lets you see which agent is printing what.\ntype lets you print several things on the same line.\nwrite lets you print values in a format which can\nbe read back in using file-read.\n\nA NetLogo model may optionally have an \u201coutput area\u201d in its Interface tab,\nseparate from the Command Center. To send output there instead of the Command\nCenter, use the output-print, output-show,\noutput-type, and output-write commands.\nThe output area can be cleared with the clear-output command and saved to a\nfile with export-output. The contents of the output area will be\nsaved by the export-world command. The import-world command\nwill clear the output area and set its contents to the value in imported world\nfile. It should be noted that large amounts of data being sent to the output\narea can increase the size of your exported worlds.\nIf you use output-print, output-show,\noutput-type, output-write, clear-output, or\nexport-output in a model which does not have a separate output\narea, then the commands apply to the output portion of the Command Center.\nHow Output Primitives Differ\nThis information is a quick reference for more advanced users.\nThe print, show, type, and write primitives differ on the following facets:\n\nWhat types of values does the primitive accept?\nDoes the primitive output a newline at the end?\nAre strings output with quotes surrounding them?\nDoes the primitive output the agent which printed it?\n\nThe following table summarizes the behavior of each primitive.\n\n\nPrimitiveAcceptable valuesAdds newline?Strings quoted?Outputs self?\n\n\nprintany NetLogo valueyesnono\nshowany NetLogo valueyesyesyes\ntypeany NetLogo valuenonono\nwriteboolean, number, string, lists containing only these typesnoyesno\n\n\n"
    },
    "18": {
        "Section_title": "File I/O",
        "Section_data": "File I/O\nIn NetLogo, there is a set of primitives that give you the power to interact\nwith outside files. They all begin with the prefix file-.\nThere are two main modes when dealing with files: reading and writing. The\ndifference is the direction of the flow of data. When you are reading in\ninformation from a file, data that is stored in the file flows into your model.\nOn the other hand, writing allows data to flow out of your model and into a\nfile.\nWhen working with files, always begin by using the primitive file-open. This\nspecifies which file you will be interacting with. None of the other primitives\nwork unless you open a file first.\nThe next file- primitive you use dictates which mode the file will be in\nuntil the file is closed, reading or writing. To switch modes, close and then\nreopen the file.\nThe reading primitives include file-read, file-read-line,\nfile-read-characters, and file-at-end?. Note that the file must exist\nalready before you can open it for reading.\n\nCode Examples: File Input Example\n\nThe primitives for writing are similar to the primitives that print things in\nthe Command Center, except that the output gets saved to a file. They include\nfile-print, file-show, file-type, and file-write. Note that you\ncan never \u201coverwrite\u201d data. In other words, if you attempt to write to a file\nwith existing data, all new data will be appended to the end of the file. (If\nyou want to overwrite a file, use file-delete to delete it, then open it for\nwriting.)\n\nCode Examples: File Output Example\n\nWhen you are finished using a file, you can use the command file-close to\nend your session with the file. If you wish to remove the file afterwards, use\nthe primitive file-delete to delete it. To close multiple opened files, one\nneeds to first select the file by using file-open before closing it.\n;; Open 3 files\nfile-open \"myfile1.txt\"\nfile-open \"myfile2.txt\"\nfile-open \"myfile3.txt\"\n\n;; Now close the 3 files\nfile-close\nfile-open \"myfile2.txt\"\nfile-close\nfile-open \"myfile1.txt\"\nfile-close\n\nOr, if you know you just want to close every file, you can use\nfile-close-all.\nTwo primitives worth noting are file-write and file-read . These\nprimitives are designed to easily save and retrieve NetLogo constants such as\nnumbers, lists, booleans, and strings. file-write will always output the\nvariable in such a manner that file-read will be able to interpret it correctly.\nfile-open \"myfile.txt\"  ;; Opening file for writing\nask turtles\n  [ file-write xcor file-write ycor ]\nfile-close\n\nfile-open \"myfile.txt\"  ;; Opening file for reading\nask turtles\n  [ setxy file-read file-read ]\nfile-close\n\n\nCode Examples: File Input Example and File Output Example\n\nLetting the user choose\nThe user-directory, user-file, and user-new-file primitives are\nuseful when you want the user to choose a file or directory for your code to\noperate on.\n"
    },
    "19": {
        "Section_title": "Movies",
        "Section_data": "Movies\nThis section describes how to capture an \u201c.mp4\u201d movie of a NetLogo model.\nFirst, use the vid:start-recorder command to\nstart the video recorder.\nTo add a frame to your movie, use either\nvid:record-view or\nvid:record-interface, depending on whether you\nwant the movie to show just the current view, or the entire Interface tab. In a\nsingle movie, the resolution will be one of the following:\n\nThe resolution specified in the call to vid:start-recorder width height\nif you specified the resolution. These are optional parameters.\nThe resolution of the view if you did not specify a resolution in the call to\nvid:start-recorder and call vid:record-view before calling\nvid:record-interface\nThe resolution of the interface if you did not specify a resolution in the\ncall to vid:start-recorder and call vid:record-interface before calling\nvid:record-view\n\nNote that if the resolution of a recorded image doesn\u2019t match the resolution of\nthe recording it will be scaled to fit which can result in images which look\nblurry or out-of-focus.\nWhen you\u2019re done adding frames, use\nvid:save-recording. The filename you provide\nshould end with .mp4, the extension for MP4-encoded movies (playable in\nQuickTime and other programs).\n;; export a 30 frame movie of the view\nextensions [vid]\n\n;...\n\nsetup\nvid:start-recorder\nvid:record-view ;; show the initial state\nrepeat 30\n[ go\n  vid:record-view ]\nvid:save-recording \"out.mp4\"\n\nA movie will play back at 25 frames per second. To make the movie playback\nfaster or slower, consider using a video postprocessing tool.\nTo check whether or not you are recording, call\nvid:recorder-status, which reports a string\nthat describes the state of the current recorder.\nTo throw away the movie currently being recorded, call\nvid:reset-recorder.\n\nCode Example: Movie Example\n\nMovies generated when running headless, or by background runs in a parallel\nBehaviorSpace experiment may use only vid:record-view primitive. Movies\ngenerated in NetLogo GUI may also use vid:record-interface and\nvid:record-source.\nNetLogo movies are exported as H.264-encoded MP4 files. To play an MP4 movie,\nyou can use the VLC Player, a free\ndownload from the VideoLAN organization.\nMovies can take up a lot of disk space. You will probably want to compress your\nmovies with third-party software. The software may give you a choice of\ndifferent kinds of compression. Some kinds of compression are lossless, while\nothers are lossy. \u201cLossy\u201d means that in order to make the files smaller, some of\nthe detail in the movie is lost. Depending on the nature of your model, you may\nwant to avoid using lossy compression, for example if the view contains fine\npixel-level detail.\n"
    },
    "20": {
        "Section_title": "Perspective",
        "Section_data": "Perspective\nThe 2D and the 3D view show the world from the perspective of the observer. By\ndefault the observer is looking down on the world from the positive z-axis at\nthe origin. You can change the perspective of the observer by using the\nfollow, ride and watch observer commands and follow-me,\nride-me and watch-me turtle commands. watch-me is also a patch or\nlink command. When in follow or ride mode the observer moves with the subject\nagent around the world. The difference between follow and ride is only visible\nin the 3D view. In the 3D view the user can change the distance behind the agent\nusing the mouse. When the observer is following at zero distance from the agent\nit is actually riding the agent. When the observer is in watch mode it tracks\nthe movements of one turtle (or patch or link) without moving. In both views you\nwill see a spotlight appear on the subject and in the 3D view the observer will\nturn to face the subject. To determine which agent is the focus you can use the\nsubject reporter.\n\nCode Example: Perspective Example\n\n"
    },
    "21": {
        "Section_title": "Drawing",
        "Section_data": "Drawing\nThe drawing is a layer where turtles can make visible marks.\nIn the view, the drawing appears on top of the patches but underneath the\nturtles. Initially, the drawing is empty and transparent.\nYou can see the drawing, but the turtles (and patches) can\u2019t. They can\u2019t sense\nthe drawing or react to it. The drawing is just for people to look at.\nTurtles can draw and erase lines in the drawing using the\npen-down and pen-erase commands.\nWhen a turtle\u2019s pen is down (or erasing), the turtle draws (or erases) a line\nbehind it whenever it moves. The lines are the same color as the turtle. To stop\ndrawing (or erasing), use pen-up.\nLines drawn by turtles are normally one pixel thick. If you want a different\nthickness, set the pen-size turtle variable to a different number before\ndrawing (or erasing). In new turtles, the variable is set to 1.\nLines made when a turtle moves in a way that doesn\u2019t fix a direction, such as\nwith setxy or move-to, the shortest path line that obeys the topology\nwill be drawn.\nHere\u2019s some turtles which have made a drawing over a grid of randomly shaded\npatches. Notice how the turtles cover the lines and the lines cover the patch\ncolors. The pen-size used here was 2:\n\nThe stamp command lets a turtle leave an image of itself behind in the\ndrawing and stamp-erase lets it remove the pixels below it in the drawing.\nTo erase the whole drawing, use the observer commmand clear-drawing. (You\ncan also use clear-all, which clears everything else too.)\nImporting an image\nThe observer command import-drawing command allows you to import an image\nfile from disk into the drawing.\nimport-drawing is useful only for providing a backdrop for people to look\nat. If you want turtles and patches to react to the image, you should use\nimport-pcolors or import-pcolors-rgb instead.\nComparison to other Logos\nDrawing works somewhat differently in NetLogo than some other Logos.\nNotable differences include:\n\nNew turtles\u2019 pens are up, not down.\nInstead of using a fence command to confine the turtle inside boundaries, in\nNetLogo you edit the world and turn wrapping off.\nThere is no screen-color, bgcolor, or setbg. You can make a solid\nbackground by coloring the patches, e.g. ask patches [ set pcolor blue ].\n\nDrawing features not supported by NetLogo:\n\nThere is no window command. This is used in some other Logos to let the\nturtle roam over an infinite plane.\nThere is no flood or fill command to fill an enclosed area with color.\n\n"
    },
    "22": {
        "Section_title": "Topology",
        "Section_data": "Topology\nThe way the world of patches is connected can change. By default the world is a\ntorus which means it isn\u2019t bounded, but \u201cwraps\u201d \u2013 so when a turtle moves past\nthe edge of the world, it disappears and reappears on the opposite edge and\nevery patch has the same number of \u201cneighbor\u201d patches. If you\u2019re a patch on the\nedge of the world, some of your \u201cneighbors\u201d are on the opposite edge.\nHowever, you can change the wrap settings with the Settings button. If wrapping\nis not allowed in a given direction then in that direction (x or y) the world is\nbounded. Patches along that boundary will have fewer than 8 neighbors and\nturtles will not move beyond the edge of the world.\nThe topology of the NetLogo world has four potential values, torus, box,\nvertical cylinder, or horizontal cylinder. The topology is controlled by\nenabling or disabling wrapping in the x or y directions. The default world is a\ntorus.\nA torus wraps in both directions, meaning that the top and bottom edges of the\nworld are connected and the left and right edges are connected. So if a turtle\nmoves beyond the right edge of the world it appears again on the left and the\nsame for the top and bottom.\nA box does not wrap in either direction. The world is bounded so turtles that\ntry to move off the edge of the world cannot. Note that the patches around edge\nof the world have fewer than eight neighbors; the corners have three and the\nrest have five.\nHorizontal and vertical cylinders wrap in one direction but not the other. A\nhorizontal cylinder wraps vertically, so the top of the world is connected to\nthe bottom. but the left and right edges are bounded. A vertical cylinder is the\nopposite; it wraps horizontally so the left and right edges are connected, but\nthe top and bottom edges are bounded.\n\nCode Example: Neighbors Example\n\nWhen coordinates wrap, turtles and links wrap visually in the view, too. If a\nturtle shape or link extends past an edge, part of it will appear at the other\nedge. (Turtles themselves are points that take up no space, so they cannot be on\nboth sides of the world at once, but in the view, they appear to take up space\nbecause they have a shape.)\nWrapping also affects how the view looks when you are following a turtle. On a\ntorus, wherever the turtle goes, you will always see the whole world around it:\n\nWhereas in a box or cylinder the world has edges, so the areas past those edges\nshow up in the view as gray:\n\n\nCode Example: Termites Perspective Demo (torus), Ants Perspective Demo\n(box)\n\nThe topology settings also control the behavior of the distance(xy), in-radius,\nin-cone, face(xy), and towards(xy) primitives. The topology controls whether the\nprimitives wrap or not. They always use the shortest path allowed by the\ntopology. For example, the distance from the center of the patches in the bottom\nleft corner (min-pxcor, min-pycor) and the upper right corner (max-pxcor,\nmax-pycor) will be as follows for each topology given that the min and max pxcor\nand pycor are +/-2:\n\nTorus - sqrt(2) ~ 1.414 (this will be the same for all world sizes since the\npatches are directly diagonal to each other in a torus.)\nBox - sqrt(world-width^2 + world-height^2) ~ 7.07\nVertical Cylinder - sqrt(world-height^2 + 1) ~ 5.099\nHorizontal Cylinder - sqrt(world-width^2 + 1) ~ 5.099\n\nAll the other primitives will act similarly to distance. If you formerly used\n-nowrap primitives in your model we recommend removing them and changing the\ntopology of the world instead.\nIf your model has turtles that move around you\u2019ll need to think about what\nhappens to them when they reach the edge of the world, if the topology you\u2019re\nusing has some non-wrapping edges. There are a few common options: the turtle is\nreflected back into the world (either systematically or randomly), the turtle\nexits the system (dies), or the turtle is hidden. It is no longer necessary to\ncheck the bounds using turtle coordinates, instead we can just ask NetLogo if a\nturtle is at the edge of the world. There are a couple ways of doing this, the\nsimplest is to use the can-move? primitive.\nif not can-move? distance [ rt 180 ]\n\ncan-move? merely returns true if the position distance in front of the turtle\nis inside the NetLogo world, false otherwise. In this case, if the turtle is at\nthe edge of the world it simple goes back the way it came. You can also use\npatch-ahead 1 != nobody in place of can-move?. If you need to do something\nsmarter that simply turning around it may be useful to use patch-at with\ndx and dy.\nif patch-at dx 0 = nobody [\n  set heading (- heading)\n]\nif patch-at 0 dy = nobody [\n  set heading (180 - heading)\n]\n\nThis tests whether the turtle is hitting a horizontal or vertical wall and\nbounces off that wall.\nIn some models if a turtle can\u2019t move forward it simply dies (exits the system,\nlike in Conductor or Mousetraps).\nif not can-move? distance[ die ]\n\nIf you are moving turtles using setxy rather than forward you should test to\nmake sure the patch you are about to move to exists since setxy throws a\nruntime error if it is given coordinates outside the world. This is a common\nsituation when the model is simulating an infinite plane and turtles outside the\nview should simply be hidden.\nlet new-x new-value-of-xcor\nlet new-y new-value-of-ycor\n\nifelse patch-at (new-x - xcor) (new-y - ycor) = nobody\n  [ hide-turtle ]\n  [ setxy new-x new-y\n    show-turtle ]\n\nSeveral models in the Models Library use this technique, Gravitation, N-Bodies,\nand Electrostatics are good examples.\nThe diffuse and diffuse4 commands behave correctly in all topologies. Each\npatch diffuses and equal amount of the diffuse variable to each of its\nneighbors, if it has fewer than 8 neighbors (or 4 if you are using diffuse4),\nthe remainder stays on the diffusing patch. This means that the overall sum of\npatch-variable across the world remains constant. However, if you want the\ndiffuse matter to still fall off the edges of the world as it would on an\ninfinite plane you still need to clear the edges each step as in the Diffuse Off\nEdges Example.\n"
    },
    "23": {
        "Section_title": "Links",
        "Section_data": "Links\nA link is an agent that connects two turtles. These turtles are sometimes also\ncalled nodes.\nThe link is always drawn as a line between the two turtles. Links do not have a\nlocation as turtles do, they are not considered to be on any patch and you\ncannot find the distance from a link to another point.\nThere are two link designations: undirected and directed. A directed link is\nout of, or from, one node and into, or to, another node. The\nrelationship of a parent to a child could be modeled as a directed link. An\nundirected link appears the same to both nodes, each node has a link with\nanother node. The relationship between spouses, or siblings, could be modeled as\nan undirected link.\nThere is a global agentset of all links, just as with turtles and patches. You\ncan create undirected links using the create-link-with and\ncreate-links-with commands; and directed links using the\ncreate-link-to, create-links-to,\ncreate-link-from, and create-links-from\ncommands. Once the first link has been created directed or undirected, all\nunbreeded links must match (links also support breeds, much like turtles, which\nwill be discussed shortly); it\u2019s impossible to have two unbreeded links where\none is directed and the other is undirected. A runtime error occurs if you try\nto do it. (If all unbreeded links die, then you can create links of that breed\nthat are different in designation from the previous links.)\nIn general, link primitive names indicate what kind of links they deal with:\n\nPrimitives that have \u201cout\u201d in their name utilize outgoing and undirected\nlinks. You can think of these as \u201cthe links I can use to get from the\ncurrent node to other nodes.\u201d In general, these are probably the primitives\nyou want to use.\nPrimitives that have \u201cin\u201d in their name utilize incoming and undirected links.\nYou can think of these as \u201cthe links I can use to get to the current node\nfrom other nodes.\u201d\nPrimtives that do not specify \u201cin\u201d or \u201cout\u201d, or have \u201cwith\u201d in their name\nutilize all links, both undirected and directed, incoming and outgoing.\n\nA link\u2019s end1 and end2 variables contain the two turtles the link connects.\nIf the link is directed, it goes from end1 to end2. If the link is undirected,\nend1 is always the older of the two turtles, that is, the turtle with the\nsmaller who number.\nLink breeds, like turtle breeds, allow you to define different types of links in\nyour model. Link breeds must either be directed or undirected, unlike unbreeded\nlinks this is defined at compile time rather than run time. You declare link\nbreeds using the keywords\nundirected-link-breed and directed-link-breed. Breeded links can be\ncreated using the commands create-<breed>-with and\ncreate-<breeds>-with for undirected breeds and the commands\ncreate-<breed>-to, create-<breeds>-to,\ncreate-<breed>-from, and create-<breeds>-from\nfor directed links.\nThere cannot be more than one undirected link of the same breed (or more than\none unbreeded undirected link) between a pair of agents, nor more than one\ndirected link of the same breed in the same direction between a pair of agents.\nYou can have two directed links of the same breed (or two unbreeded directed\nlinks) between a pair if they are in opposite directions.\nLayouts\nAs part of our network support we have also added several different primitives\nthat will help you to visualize the networks. The simplest is layout-circle\nwhich evenly spaces the agents around the center of the world given a radius.\n\nlayout-radial is a good layout if you have something like a tree structure,\nthough even if there are some cycles in the tree it will still work, though as\nthere are more and more cycles it will probably not look as good.\nlayout-radial takes a root agent to be the central node places it at (0,0)\nand arranges the nodes connected to it in a concentric pattern. Nodes one degree\naway from the root will be arranged in a circular pattern around the central\nnode and the next level around those nodes and so on. layout-radial will\nattempt to account for asymmetrical graphs and give more space to branches that\nare wider. layout-radial also takes a breed as an input so you use one breed\nof links to layout the network and not another.\n\nGiven a set of anchor nodes layout-tutte places all the other nodes at the\ncenter of mass of the nodes it is linked to. The anchor set is automatically\narranged in a circle layout with a user defined radius and the other nodes will\nconverge into place (this of course means that you may have to run it several\ntimes before the layout is stable.)\n\nlayout-spring is useful for many kinds of networks. The drawback is that is\nrelatively slow since it takes many iterations to converge. In this layout the\nlinks act as springs that pull the nodes they connect toward each other and the\nnodes repel each other. The strength of the forces is controlled by inputs to\nthe primitives. These inputs will always have a value between 0 and 1; keep in\nmind that very small changes can still affect the appearance of the network. The\nsprings also have a length (in patch units), however, because of all the forces\ninvolved the nodes will not end up exactly that distance from each other.\n\n**Code Examples:**Network Example, Network Import Example, Giant Component,\nSmall Worlds, Preferential Attachment\n\n"
    },
    "24": {
        "Section_title": "Anonymous procedures",
        "Section_data": "Anonymous procedures\nAnonymous procedures let you store code to be run later. Just like regular\nNetLogo procedures, an anonymous procedures can be either a command (anonymous\ncommand) or a reporter (anonymous reporter).\nAnonymous procedures are values, which means they may be passed as input,\nreported as a result, or stored in a variable.\nAn anonymous procedure might be run once, multiple times, or not at all.\nIn other programming languages anonymous procedures are known as first-class\nfunctions, closures, or lambda.\nAnonymous procedure primitives\nPrimitives specific to anonymous procedures are ->, is-anonymous-command?,\nand is-anonymous-reporter?.\nThe -> creates an anonymous procedure. The anonymous procedure it reports\nmight be a command or a reporter, depending on what kind of block you pass it.\nFor example [ -> fd 1 ] reports an anonymous command, because fd is a\ncommand, while [ -> count turtles ] reports an anonymous reporter, because\ncount is a reporter.\nThese primitives require anonymous procedures as input: foreach, map,\nreduce, filter, n-values, sort-by. When calling these primitives, using\nan -> is optional if your anonymous procedure contains a single primitive\nwhich has requires no more inputs than are are provided by the primitive. For\nexample one may write simply foreach mylist print instead of\nforeach mylist [ [x] -> print x ], though the latter is also accepted.\nDepending on the anonymous procedure, various parts of the anonymous procedure\nsyntax can be omitted. For a summary of optional syntax, see\nthe table below.\nThe run command accepts anonymous commands as well as strings.\nThe runresult reporter accepts anonymous reporters as well as strings.\nrun and runresult allow passing inputs to an anonymous procedure. As with\nall primitives accepting varying number of inputs, the whole call must be\nsurrounded with parentheses, so for example (run my-anonymous-command 5) or\n(runresult my-anonymous-reporter \"foo\" 2). When not passing input, no\nparentheses are required.\nAnonymous procedure inputs\nAn anonymous procedure may take zero or more inputs. The inputs are referenced\nthe variables declared before the arrow. For instance, in the anonymous reporter\n[ [a b] -> a + b ], a and b are inputs.\nAnonymous procedures and strings\nCreating and running anonymous procedures is fast. To use run or runresult\non a new string for the first time is about 100x slower than running an\nanonymous procedure. Modelers should normally use anonymous procedures instead\nof running strings, except when running strings entered by the user.\nConcise syntax\nSimple uses of foreach, map, reduce, filter, n-values, and sort-by\ncan be written with an especially concise syntax. You can write:\nmap abs [1 -2 3 -4]\n;; => [1 2 3 4]\nreduce + [1 2 3 4]\n;; => 10\nfilter is-number? [1 \"x\" 3]\n;; => [1 3]\nforeach [1 2 3 4] print\n;; prints 1 through 4\n\nIn older NetLogo versions (4 and earlier), these had to be written:\nmap [abs ?] [1 -2 3 -4]\n;; => [1 2 3 4]\nreduce [?1 + ?2] [1 2 3 4]\n;; => 10\nfilter [is-number? ?] [1 \"x\" 3]\n;; => [1 3]\nforeach [1 2 3 4] [ print ? ]\n;; prints 1 through 4\n\nAnonymous procedures as closures\nAnonymous procedures are \u201cclosures\u201d; that means they capture or \u201cclose over\u201d the\nbindings (not just the current values) of local variables and procedure inputs.\nThey do not capture agent variables and do not capture the identity (or even the\nagent type) of the current agent.\nNonlocal exits\nThe stop and report commands exit from the dynamically enclosing procedure,\nnot the enclosing anonymous procedure. (This is backward-compatible with older\nNetLogo versions.)\nAnonymous procedures and extensions\nThe extensions API supports writing primitives that accept anonymous procedures\nas input. Write us for sample code.\nLimitations\nWe hope to address at least some of the following limitations in future NetLogo\nversions:\n\nimport-world does not support anonymous procedures.\nAnonymous procedures can\u2019t be variadic (accept a varying number of inputs).\nAnonymous reporters can\u2019t contain commands, only a single reporter\nexpression. So for example you must use ifelse-value not if, and you don\u2019t\nuse report at all. If your code is too complex to be written as one\nreporter, you\u2019ll need to move the code to a separate reporter procedure, and\nthen call that procedure from your anonymous reporter, passing it any needed\ninputs.\nAnonymous procedures are not interchangeable with command blocks and reporter\nblocks. Only the primitives listed above accept anonymous procedures as input.\nControl primitives such as ifelse and while and agent primitives such as\nof and with don\u2019t accept anonymous procedures. So for example if I have an\nanonymous reporter let r [ -> if random 2 == 0 ] and two anonymous commands\nlet c1 [ -> tick ] and let c2 [ -> stop ], I can\u2019t write ifelse r c1 c2,\nI must write ifelse runresult r [ run c1 ] [ run c2 ].\nThe concise syntax where -> may be omitted is only available to primitives\nand extension primitives, not ordinary procedures. So for example if I have a\nprocedure p that accepts an anonymous procedure as input, it must be called\nas e.g. p [ -> ... ] not p [ ... ].\n\nWhat is Optional?\nThere are several different ways of writing anonymous procedures which allow\nusers to omit part or all of the anonymous procedure syntax. These are\nsummarized in the table below.\n\n\n\n  What is the anonymous procedure like?\n  What can be left out?\n  Examples\n\n\n\n  \n    The anonymous procedure is a single primitive\n    \n      \n        input names\n        arrow\n        block brackets\n      \n    \n    \n      \n        foreach mylist stamp  ; no inputs\n        foreach mylist print  ; single input\n        (foreach xs ys setxy) ; multiple inputs\n        map round [1.3 2.4 3.5] ; reporter, single input\n        (map + [1 2 3] [4 5 6]) ; reporter, multiple inputs\n      \n    \n  \n  \n    The anonymous procedure takes no inputs\n    \n      \n        input names\n        arrow\n      \n    \n    \n      \n        foreach mylist [ print \"abc\" ]\n        map [ 4 ] mylist\n      \n    \n  \n  \n    The anonymous procedure has zero or one input(s)\n    \n      \n        brackets around input names\n      \n    \n    \n      \n        foreach mylist [ -> stamp ] ; no inputs\n        foreach mylist [ x -> print x ] ; single input\n        foreach mylist [ x -> rt x fd x ] ; multiple primitives, single input\n        map [ -> world-width ] mylist ; reporter, no inputs\n        map [ x -> x ^ 2 ] mylist ; reporter, single input \n    \n  \n  \n    Anonymous procedure takes more than one input\n    \n      \n        nothing\n      \n    \n    \n      \n        (foreach xs ys [ [ x y ] -> setx x + y ])\n        (map [ [ x y ] -> x mod round y ] xs ys)\n      \n    \n  \n\n\nNote: brackets around input names were always required in NetLogo 6.0.0.\nIf you copy and paste code into NetLogo 6.0.0 using anonymous procedures with\nunbracketed input names, the code will not compile until you add the brackets.\nCode example\n\nCode Example: State Machine Example\n\n"
    },
    "25": {
        "Section_title": "Ask-Concurrent",
        "Section_data": "Ask-Concurrent\nNOTE: The following information is included only for backwards\ncompatibility. We don\u2019t recommend using the ask-concurrent primitive at all in\nnew models.\nIn very old versions of NetLogo, ask had simulated concurrent behavior by\ndefault. Since NetLogo 4.0 (2007), ask is serial, that is, the agents run\nthe commands inside the ask one at a time.\nThe following information describes the behavior of the ask-concurrent\ncommand, which behaves the way the old ask behaved.\nask-concurrent produces simulated concurrency via a mechanism of\nturn-taking. The first agent takes a turn, then the second agent takes a turn,\nand so on until every agent in the asked agentset has had a turn. Then we go\nback to the first agent. This continues until all of the agents have finished\nrunning all of the commands.\nAn agent\u2019s \u201cturn\u201d ends when it performs an action that affects the state of the\nworld, such as moving, or creating a turtle, or changing the value of a global,\nturtle, patch, or link variable. (Setting a local variable doesn\u2019t count.)\nThe forward (fd) and back (bk) commands are treated\nspecially. When used inside ask-concurrent, these commands can take multiple\nturns to execute. During its turn, the turtle can only move by one step. Thus,\nfor example, fd 20 is equivalent to repeat 20 [ fd 1 ], where the turtle\u2019s\nturn ends after each run of fd. If the distance specified isn\u2019t an integer,\nthe last fraction of step takes a full turn. So for example fd 20.3 is\nequivalent to repeat 20 [ fd 1 ] fd 0.3.\nThe jump command always takes exactly one turn, regardless of distance.\nTo understand the difference between ask and ask-concurrent, consider\nthe following two commands:\nask turtles [ fd 5 ]\nask-concurrent turtles [ fd 5 ]\n\nWith ask, the first turtle takes five steps forward, then the second turtle\ntakes five steps forward, and so on.\nWith ask-concurrent, all of the turtles take one step forward. Then they all\ntake a second step, and so on. Thus, the latter command is equivalent to:\nrepeat 5 [ ask turtles [ fd 1 ] ]\n\n\nCode Example: Ask-Concurrent Example shows the difference between ask\nand ask-concurrent.\n\nThe behavior of ask-concurrent cannot always be so simply reproduced using\nask, as in this example. Consider this command:\nask-concurrent turtles [ fd random 10 ]\n\nIn order to get the same behavior using ask, we would have to write:\nturtles-own [steps]\nask turtles [ set steps random 10 ]\nwhile [any? turtles with [steps > 0]] [\n  ask turtles with [steps > 0] [\n    fd 1\n    set steps steps - 1\n  ]\n]\n\nTo prolong an agent\u2019s \u201cturn\u201d, use the without-interruption command. (The\ncommand blocks inside some commands, such as create-turtles and hatch,\nhave an implied without-interruption around them.)\nNote that the behavior of ask-concurrent is completely deterministic. Given\nthe same code and the same initial conditions, the same thing will always happen\n(if you are using the same version of NetLogo and begin your model run with the\nsame random seed).\nIn general, we suggest you not use ask-concurrent at all. If you do, we\nsuggest you write your model so that it does not depend on the exact details of\nhow ask-concurrent works. We make no guarantees that its semantics will remain\nthe same in future versions of NetLogo, or that it will continue to be supported\nat all.\n"
    },
    "26": {
        "Section_title": "User Interaction Primitives",
        "Section_data": "User Interaction Primitives\nNetLogo features several primitives which allow a model to interact with the\nuser. These primitives include user-directory,\nuser-file,\nuser-new-file,\nuser-input,\nuser-message,\nuser-one-of, and\nuser-yes-or-no?.\nThese primitives differ in precisely what interaction they take with the user.\nuser-directory, user-file, and user-new-file are all reporters which\nprompt the user to select an item from the file system and report the path of\nthe selected item to NetLogo. user-yes-or-no?, user-one-of, and user-input\nall prompt the user to provide input in the form of text or a selection.\nuser-message simply presents a message to the user.\nNote that all active forever buttons will pause when one of these primitives is\nused and will resume only when the user completes the interaction with the\nbutton.\nWhat does \u201cHalt\u201d mean?\nThe primitives which prompt the user for input, as well as user-message all\nprovide a \u201cHalt\u201d button. The effect of this button is the same for all of these\nprimitives - it halts the model. When the model is halted all running code is\nstopped, including buttons and the command center. Since halting stops code in\nthe middle of whatever it happened to be doing at the time it was halted, you\nmay see strange results if you continue to run the model after a halt without\nsetting it up again.\n"
    },
    "27": {
        "Section_title": "Tie",
        "Section_data": "Tie\nTie connects two turtles so that the movement of one turtles affects the\nlocation and heading of another. Tie is a property of links so there must be a\nlink between two turtles to create a tie relationship.\nWhen a link\u2019s tie-mode is set to \u201cfixed\u201d or \u201cfree\u201d end1 and end2 are\ntied together. If the link is directed end1 is the \u201croot agent\u201d and end2\nis the \u201cleaf agent\u201d. That is when end1 moves (using fd,\njump, setxy, etc.) end2 also moves the same distance and direction.\nHowever when end2 moves it does not affect end1.\nIf the link is undirected it is a reciprocal tie relationship, meaning, if\neither turtle moves the other turtle will also move. So depending on which\nturtle is moving either turtle can be considered the root or the leaf. The root\nturtle is always the turtle that initiates the movement.\nWhen the root turtle turns right or left, the leaf turtle rotates around the\nroot turtle the same amount as if a stiff were attaching the turtles. When\ntie-mode is set to \u201cfixed\u201d the heading of the leaf turtle changes by the\nsame amount. If the tie-mode is set to \u201cfree\u201d the heading of the leaf turtle\nis unchanged.\nThe tie-mode of a link can be set to \u201cfixed\u201d using the tie command and\nset to \u201cnone\u201d (meaning the turtles are no longer tied) using untie to set\nthe mode to \u201cfree\u201d you need to: set tie-mode \"free\".\n\nCode Example: Tie System Example\n\n"
    },
    "28": {
        "Section_title": "Multiple source files",
        "Section_data": "Multiple source files\nThe __includes keyword allows you to use multiple source files in a single\nNetLogo model.\nThe keyword begins with two underscores to indicate that the feature is\nexperimental and may change in future NetLogo releases.\nWhen you open a model that uses the __includes keyword, or if you add it to\nthe top of a model and hit the Check button, the includes menu will appear in\nthe toolbar. From the includes menu you can select from the files included in\nthis model.\nWhen you open included files they appear in additional tabs. See the\nInterface Guide for more details.\nYou can have anything in external source files (.nls) that you would normally\nput in the Code tab: globals, breed, turtles-own, patches-own,\nbreeds-own, procedure definitions, etc. Note though that these\ndeclarations all share the same namespace. That is, if you declare a global\nmy-global in the Code tab you cannot declare a global (or anything else) with\nthe name my-global in any file that is included in the model. my-global will\nbe accessible from all the included files. The same would be true if my-global\nwere declared in one of the included files.\n"
    }
}