{
    "0": {
        "Function Name": "ActivatedBCell::ActivatedBCell(int x, int y, int id, int heading) : Turtle(x, y, id, heading)",
        "Code Block": "ActivatedBCell::ActivatedBCell(int x, int y, int id, int heading) : Turtle(x, y, id, heading) {\n            // Constructor\n            // std::cout<<'Creating activated b cell with ID '<<id<<std::endl;\n        }"
    },

    "1":{
        "Function Name":"void World::activatedBCellFunction(std::shared_ptr<ActivatedBCell> abcell)",
        "Code Block": "void World::activatedBCellFunction(std::shared_ptr<ActivatedBCell> abcell) {\n            bool print_test = false;\n            if (!abcell->get_is_alive()) {return;}\n              // Only performs the following commands if currently inside the follicle, and NOT in the blood/lymph\n              if (print_test){std::cout<<'ABC function for ID '<<abcell->getID()<<' use count is '<<abcell.use_count()<<std::endl;}\n          \n              if (!abcell->getInBlood()) {\n                if (print_test){std::cout<<'doing ABC function for not in blood'<<std::endl;}\n                  // Get the patch where the B cell is\n                  Patch& bcell_patch = get_patch(abcell->getX(), abcell->getY());\n          \n                  // If the cell reaches the follicle exit\n                  if(bcell_patch.getPatchType() == 2) {\n                      abcell->setInBlood(true);\n                      abcell->setVisible(false);\n                      if (print_test){std::cout<<'killing abc cell at follicle exit '<<abcell->getID()<<std::endl;}\n                      if (print_test){std::cout<<'abcell use count is '<<abcell.use_count()<<std::endl;}\n                      kill(abcell);\n                      return;\n                  }\n          \n                  isotypeSwitch(abcell);   // Determines which isotype to switch to\n                  if (print_test){std::cout<<'abcell use count 1is '<<abcell.use_count()<<std::endl;}\n          \n                  if (abcell->getResponseType() == 2) {\n                      tdResponse(abcell);\n                      if (print_test){std::cout<<'abcell use count 2ais '<<abcell.use_count()<<std::endl;}\n                      if (!abcell->get_is_alive()){return;}\n                  } else if (abcell->getResponseType() == 1) {\n                      tiResponse(abcell);\n                      // return;\n                      if (print_test){std::cout<<'abcell use count 2bis '<<abcell.use_count()<<std::endl;}\n                  }\n          \n                  //abcell->checkBregStatus();\n                  if (print_test){std::cout<<'abcell use count 3is '<<abcell.use_count()<<std::endl;}\n          \n                  chemotaxis(abcell);\n                  if (print_test){std::cout<<'abcell use count 4is '<<abcell.use_count()<<std::endl;}\n          \n                  move_turtle(abcell);\n                  if (print_test){std::cout<<'abcell use count 5is '<<abcell.use_count()<<std::endl;}\n          \n              }\n          \n              bool die_by_tnf = checkTNFStatus(abcell);\n              if (print_test){std::cout<<'abcell use count 6is '<<abcell.use_count()<<std::endl;}\n          \n              abcell->setTimeAlive(abcell->getTimeAlive() + 1);\n              if ((abcell->getTimeAlive() > 300) || die_by_tnf) {\n                  kill(abcell);\n                  if (print_test){std::cout<<'killing abc cell at time alive or TNF'<<std::endl;}\n          \n              }\n          }"
    },

    "2":{
        "Function Name":"void World::isotypeSwitch(std::shared_ptr<ActivatedBCell> activated_b_cell)",
        "Code Block": "void World::isotypeSwitch(std::shared_ptr<ActivatedBCell> activated_b_cell) {\n            // Get the patch where the activated b cell is\n            Patch& activated_b_cell_patch = get_patch(activated_b_cell->getX(), activated_b_cell->getY());\n        \n            if (!activated_b_cell->getCsrBool()) {\n                double igM_bucket = activated_b_cell_patch.getIl12() + activated_b_cell_patch.getIl15() + activated_b_cell_patch.getIl6();\n                double igA_bucket = activated_b_cell_patch.getIl10() + activated_b_cell_patch.getIl15() + activated_b_cell_patch.getIl21() + activated_b_cell_patch.getTgfB();\n                double igG_bucket = activated_b_cell_patch.getIl4() + activated_b_cell_patch.getIl10() + activated_b_cell_patch.getIl15() + activated_b_cell_patch.getIl21();\n                double igE_bucket = activated_b_cell_patch.getIl4() - activated_b_cell_patch.getIl12() - activated_b_cell_patch.getIfA() - activated_b_cell_patch.getIfG() - activated_b_cell_patch.getTgfB() + activated_b_cell_patch.getIl21();\n        \n                std::vector<double> mylist = {igM_bucket, igA_bucket, igG_bucket, igE_bucket};\n                int max_index = std::max_element(mylist.begin(), mylist.end()) - mylist.begin();\n        \n                if (max_index == 0) {\n                    activated_b_cell->setCsrBool(true);\n                    activated_b_cell->setIsotype('m');\n                } else if (max_index == 1) {\n                    activated_b_cell->setCsrBool(true);\n                    activated_b_cell->setIsotype('a');\n                } else if (max_index == 2) {\n                    activated_b_cell->setCsrBool(true);\n                    activated_b_cell->setIsotype('g');\n                } else if (max_index == 3) {\n                    activated_b_cell->setCsrBool(true);\n                    activated_b_cell->setIsotype('e');\n                }\n            }\n        }"
    },
    "3" : {
        "Function Name":"void World::tdResponse(std::shared_ptr<ActivatedBCell> activated_b_cell)",
        "Code Block": "void World::tdResponse(std::shared_ptr<ActivatedBCell> activated_b_cell) {\n            // Try to get Tfh cell in the current location of the activated B cell\n            auto tfh = getOneTfhHere(activated_b_cell->getX(), activated_b_cell->getY());\n        \n            // If a Tfh cell is found, create a new GcB cell and link it with the Tfh cell\n            if (tfh) {\n              if (tfh->getBcellBindingStatus()){std::cout<<'TFH CELL IS ALREADY BOUND TO; skipping'<<std::endl; return;}\n                auto new_gc_b_cell = std::make_shared<GCBCell>(activated_b_cell->getX(), activated_b_cell->getY(), global_ID_counter++, activated_b_cell->getHeading());\n                // std::cout<< 'activated b cell doing tdResponse at '<< activated_b_cell->getX()<<', '<<activated_b_cell->getY()<< 'for ID '<<activated_b_cell->getID()<<std::endl;\n                new_gc_b_cell->copy_other_turtle_attributes(activated_b_cell);\n                new_gc_b_cell->setProBreg(0);\n                new_gc_b_cell->setColor('orange');\n                new_gc_b_cell->setShape('circle');\n                new_gc_b_cell->setSize(1);\n                new_gc_b_cell->setTimeAlive(0);\n        \n                std::weak_ptr<Turtle> new_gc_b_cell_weak_ptr = new_gc_b_cell;\n                all_turtles.push_back(new_gc_b_cell_weak_ptr);\n                all_gcb_cells.push_back(new_gc_b_cell);\n                get_patch(new_gc_b_cell->getX(), new_gc_b_cell->getY()).add_turtle(new_gc_b_cell);\n        \n                // createLinkWith(new_gc_b_cell, tfh);\n                new_gc_b_cell->addLinkedTurtle(tfh);\n                tfh->setEbi2rLevel(0);\n                tfh->setCcr7Level(0);\n                tfh->setBcellBindingStatus(true);\n        \n                kill(activated_b_cell);\n                return;\n            } else {\n                // If no Tfh cell is found, try to get a Th2 cell in the current location of the activated B cell\n                auto th2 = getOneTh2Here(activated_b_cell->getX(), activated_b_cell->getY());\n        \n                // If a Th2 cell is found, create a new GcB cell and link it with the Th2 cell\n                if (th2) {\n                  if (th2->getBcellBindingStatus()){std::cout<<'th2 CELL IS ALREADY BOUND TO; skipping'<<std::endl; return;}\n                  // std::cout<< 'activated b cell doing tdResponse at '<< activated_b_cell->getX()<<', '<<activated_b_cell->getY()<< 'for ID '<<activated_b_cell->getID()<<std::endl;\n        \n                    auto new_gc_b_cell = std::make_shared<GCBCell>(activated_b_cell->getX(), activated_b_cell->getY(), global_ID_counter++, activated_b_cell->getHeading());\n                    new_gc_b_cell->copy_other_turtle_attributes(activated_b_cell);\n                    new_gc_b_cell->setProBreg(0);\n                    new_gc_b_cell->setColor('orange');\n                    new_gc_b_cell->setShape('circle');\n                    new_gc_b_cell->setSize(1);\n                    new_gc_b_cell->setTimeAlive(0);\n        \n                    std::weak_ptr<Turtle> new_gc_b_cell_weak_ptr = new_gc_b_cell;\n                    all_turtles.push_back(new_gc_b_cell_weak_ptr);\n                    all_gcb_cells.push_back(new_gc_b_cell);\n                    get_patch(new_gc_b_cell->getX(), new_gc_b_cell->getY()).add_turtle(new_gc_b_cell);\n        \n                    // createLinkWith(new_gc_b_cell, th2);\n                    new_gc_b_cell->addLinkedTurtle(th2);\n                    th2->setEbi2rLevel(0);\n                    th2->setCcr7Level(0);\n                    th2->setBcellBindingStatus(true);\n        \n                    kill(activated_b_cell);\n                    return;\n                }\n            }\n        }"
    
    },
    "4" : {
        "Function Name": "void World::tiResponse(std::shared_ptr<ActivatedBCell> activated_b_cell)",
        "Code Block": "void World::tiResponse(std::shared_ptr<ActivatedBCell> activated_b_cell) {\n    bool print_test = false;\n    // Activated B-cells undergoing TI response secrete TNF-a\n    auto current_patch = get_patch(activated_b_cell->getX(), activated_b_cell->getY());\n    current_patch.setTnfA(current_patch.getTnfA() + 1);\n\n    if (activated_b_cell->getTimeAlive() % 70 == 0) {\n        double proPC = (current_patch.getIl21() + current_patch.getIl10() + current_patch.getIfA() + current_patch.getIfG()) * 10;\n        double proMem = 0;\n        if (proPC > proMem) {\n            // Create a new SL Plasma Cell and add it to the corresponding containers\n            auto new_sl_plasma_cell = std::make_shared<SLPlasmaCell>(activated_b_cell->getX(), activated_b_cell->getY(), global_ID_counter++);\n            new_sl_plasma_cell->copy_other_turtle_attributes(activated_b_cell);\n            new_sl_plasma_cell->setTimeAlive(0);\n            // Set color, shape, size, etc. as required\n            new_sl_plasma_cell->setColor('lime');\n            new_sl_plasma_cell->setShape('circle');\n            new_sl_plasma_cell->setSize(1);\n\n\n            std::weak_ptr<Turtle> new_sl_plasma_cell_weak_ptr = new_sl_plasma_cell;\n            all_turtles.push_back(new_sl_plasma_cell_weak_ptr);\n            all_sl_plasma_cells.push_back(new_sl_plasma_cell);\n            get_patch(new_sl_plasma_cell->getX(), new_sl_plasma_cell->getY()).add_turtle(new_sl_plasma_cell);\n            if(print_test){std::cout<<'final SL plasma cell use count '<<new_sl_plasma_cell.use_count()<<std::endl;}\n        } else {\n            if (step < 2800) {\n                // Create a new Memory B Cell and add it to the corresponding containers\n                auto new_mem_b_cell = std::make_shared<MemBCell>(activated_b_cell->getX(), activated_b_cell->getY(), global_ID_counter++);\n                new_mem_b_cell->copy_other_turtle_attributes(activated_b_cell);\n\n                new_mem_b_cell->setExposureNumber(1);\n                new_mem_b_cell->setTimeAlive(0);\n                // Set color, shape, size, etc. as required\n                new_mem_b_cell->setColor('pink');\n                new_mem_b_cell->setShape('target');\n                new_mem_b_cell->setSize(1);\n                new_mem_b_cell->setS1pr1Level(10);\n                new_mem_b_cell->setProBreg(0);\n                new_mem_b_cell->setCd21Level(0);\n                new_mem_b_cell->setCxcr5Level(10);\n\n                std::weak_ptr<Turtle> new_mem_b_cell_weak_ptr = new_mem_b_cell;\n                all_turtles.push_back(new_mem_b_cell_weak_ptr);\n                all_mem_b_cells.push_back(new_mem_b_cell);\n                get_patch(new_mem_b_cell->getX(), new_mem_b_cell->getY()).add_turtle(new_mem_b_cell);\n\n            } else {\n                // Create a new Memory B Cell and add it to the corresponding containers\n                auto new_mem_b_cell = std::make_shared<MemBCell>(activated_b_cell->getX(), activated_b_cell->getY(), global_ID_counter++);\n                new_mem_b_cell->copy_other_turtle_attributes(activated_b_cell);\n\n                new_mem_b_cell->setExposureNumber(2);\n                new_mem_b_cell->setTimeAlive(0);\n                // Set color, shape, size, etc. as required\n                new_mem_b_cell->setColor('pink');\n                new_mem_b_cell->setShape('target');\n                new_mem_b_cell->setSize(1);\n                new_mem_b_cell->setS1pr1Level(10);\n                new_mem_b_cell->setProBreg(0);\n                new_mem_b_cell->setCd21Level(0);\n                new_mem_b_cell->setCxcr5Level(10);\n\n                std::weak_ptr<Turtle> new_mem_b_cell_weak_ptr = new_mem_b_cell;\n                all_turtles.push_back(new_mem_b_cell_weak_ptr);\n                all_mem_b_cells.push_back(new_mem_b_cell);\n                get_patch(new_mem_b_cell->getX(), new_mem_b_cell->getY()).add_turtle(new_mem_b_cell);\n\n            }\n        }\n    }\n}"
    },
    "n" : {
        "Function Name": ,
        "Code Block":
    },


}