{
      "0": {
            "Function_name": "ActivatedBCell::ActivatedBCell(int x, int y, int id, int heading) : Turtle(x, y, id, heading)",
            "Function_body": "ActivatedBCell::ActivatedBCell(int x, int y, int id, int heading) : Turtle(x, y, id, heading) {\n            // Constructor\n            // std::cout<<'Creating activated b cell with ID '<<id<<std::endl;\n        }"
      },
      "1": {
            "Function_name": "void World::isotypeSwitch(std::shared_ptr<ActivatedBCell> activated_b_cell) ",
            "Function_body": "void World::isotypeSwitch(std::shared_ptr<ActivatedBCell> activated_b_cell) {\n    // Get the patch where the activated b cell is\n    Patch& activated_b_cell_patch = get_patch(activated_b_cell->getX(), activated_b_cell->getY());\n\n    if (!activated_b_cell->getCsrBool()) {\n        double igM_bucket = activated_b_cell_patch.getIl12() + activated_b_cell_patch.getIl15() + activated_b_cell_patch.getIl6();\n        double igA_bucket = activated_b_cell_patch.getIl10() + activated_b_cell_patch.getIl15() + activated_b_cell_patch.getIl21() + activated_b_cell_patch.getTgfB();\n        double igG_bucket = activated_b_cell_patch.getIl4() + activated_b_cell_patch.getIl10() + activated_b_cell_patch.getIl15() + activated_b_cell_patch.getIl21();\n        double igE_bucket = activated_b_cell_patch.getIl4() - activated_b_cell_patch.getIl12() - activated_b_cell_patch.getIfA() - activated_b_cell_patch.getIfG() - activated_b_cell_patch.getTgfB() + activated_b_cell_patch.getIl21();\n\n        std::vector<double> mylist = {igM_bucket, igA_bucket, igG_bucket, igE_bucket};\n        int max_index = std::max_element(mylist.begin(), mylist.end()) - mylist.begin();\n\n        if (max_index == 0) {\n            activated_b_cell->setCsrBool(true);\n            activated_b_cell->setIsotype('m');\n        } else if (max_index == 1) {\n            activated_b_cell->setCsrBool(true);\n            activated_b_cell->setIsotype('a');\n        } else if (max_index == 2) {\n            activated_b_cell->setCsrBool(true);\n            activated_b_cell->setIsotype('g');\n        } else if (max_index == 3) {\n            activated_b_cell->setCsrBool(true);\n            activated_b_cell->setIsotype('e');\n        }\n    }\n}"
      },
      "2": {
            "Function_name": "void World::activatedBCellFunction(std::shared_ptr<ActivatedBCell> abcell) ",
            "Function_body": "void World::activatedBCellFunction(std::shared_ptr<ActivatedBCell> abcell) {\n  bool print_test = false;\n  if (!abcell->get_is_alive()) {return;}\n    // Only performs the following commands if currently inside the follicle, and NOT in the blood/lymph\n    if (print_test){std::cout<<'ABC function for ID '<<abcell->getID()<<' use count is '<<abcell.use_count()<<std::endl;}\n\n    if (!abcell->getInBlood()) {\n      if (print_test){std::cout<<'doing ABC function for not in blood'<<std::endl;}\n        // Get the patch where the B cell is\n        Patch& bcell_patch = get_patch(abcell->getX(), abcell->getY());\n\n        // If the cell reaches the follicle exit\n        if(bcell_patch.getPatchType() == 2) {\n            abcell->setInBlood(true);\n            abcell->setVisible(false);\n            if (print_test){std::cout<<'killing abc cell at follicle exit '<<abcell->getID()<<std::endl;}\n            if (print_test){std::cout<<'abcell use count is '<<abcell.use_count()<<std::endl;}\n            kill(abcell);\n            return;\n        }\n\n        isotypeSwitch(abcell);   // Determines which isotype to switch to\n        if (print_test){std::cout<<'abcell use count 1is '<<abcell.use_count()<<std::endl;}\n\n        if (abcell->getResponseType() == 2) {\n            tdResponse(abcell);\n            if (print_test){std::cout<<'abcell use count 2ais '<<abcell.use_count()<<std::endl;}\n            if (!abcell->get_is_alive()){return;}\n        } else if (abcell->getResponseType() == 1) {\n            tiResponse(abcell);\n            // return;\n            if (print_test){std::cout<<'abcell use count 2bis '<<abcell.use_count()<<std::endl;}\n        }\n\n        //abcell->checkBregStatus();\n        if (print_test){std::cout<<'abcell use count 3is '<<abcell.use_count()<<std::endl;}\n\n        chemotaxis(abcell);\n        if (print_test){std::cout<<'abcell use count 4is '<<abcell.use_count()<<std::endl;}\n\n        move_turtle(abcell);\n        if (print_test){std::cout<<'abcell use count 5is '<<abcell.use_count()<<std::endl;}\n\n    }\n\n    bool die_by_tnf = checkTNFStatus(abcell);\n    if (print_test){std::cout<<'abcell use count 6is '<<abcell.use_count()<<std::endl;}\n\n    abcell->setTimeAlive(abcell->getTimeAlive() + 1);\n    if ((abcell->getTimeAlive() > 300) || die_by_tnf) {\n        kill(abcell);\n        if (print_test){std::cout<<'killing abc cell at time alive or TNF'<<std::endl;}\n\n    }\n}"
      },
      "3": {
            "Function_name": "void World::tdResponse(std::shared_ptr<ActivatedBCell> activated_b_cell) ",
            "Function_body": "void World::tdResponse(std::shared_ptr<ActivatedBCell> activated_b_cell) {\n    // Try to get Tfh cell in the current location of the activated B cell\n    auto tfh = getOneTfhHere(activated_b_cell->getX(), activated_b_cell->getY());\n\n    // If a Tfh cell is found, create a new GcB cell and link it with the Tfh cell\n    if (tfh) {\n      if (tfh->getBcellBindingStatus()){std::cout<<'TFH CELL IS ALREADY BOUND TO; skipping'<<std::endl; return;}\n        auto new_gc_b_cell = std::make_shared<GCBCell>(activated_b_cell->getX(), activated_b_cell->getY(), global_ID_counter++, activated_b_cell->getHeading());\n        // std::cout<< 'activated b cell doing tdResponse at '<< activated_b_cell->getX()<<', '<<activated_b_cell->getY()<< 'for ID '<<activated_b_cell->getID()<<std::endl;\n        new_gc_b_cell->copy_other_turtle_attributes(activated_b_cell);\n        new_gc_b_cell->setProBreg(0);\n        new_gc_b_cell->setColor('orange');\n        new_gc_b_cell->setShape('circle');\n        new_gc_b_cell->setSize(1);\n        new_gc_b_cell->setTimeAlive(0);\n\n        std::weak_ptr<Turtle> new_gc_b_cell_weak_ptr = new_gc_b_cell;\n        all_turtles.push_back(new_gc_b_cell_weak_ptr);\n        all_gcb_cells.push_back(new_gc_b_cell);\n        get_patch(new_gc_b_cell->getX(), new_gc_b_cell->getY()).add_turtle(new_gc_b_cell);\n\n        // createLinkWith(new_gc_b_cell, tfh);\n        new_gc_b_cell->addLinkedTurtle(tfh);\n        tfh->setEbi2rLevel(0);\n        tfh->setCcr7Level(0);\n        tfh->setBcellBindingStatus(true);\n\n        kill(activated_b_cell);\n        return;\n    } else {\n        // If no Tfh cell is found, try to get a Th2 cell in the current location of the activated B cell\n        auto th2 = getOneTh2Here(activated_b_cell->getX(), activated_b_cell->getY());\n\n        // If a Th2 cell is found, create a new GcB cell and link it with the Th2 cell\n        if (th2) {\n          if (th2->getBcellBindingStatus()){std::cout<<'th2 CELL IS ALREADY BOUND TO; skipping'<<std::endl; return;}\n          // std::cout<< 'activated b cell doing tdResponse at '<< activated_b_cell->getX()<<', '<<activated_b_cell->getY()<< 'for ID '<<activated_b_cell->getID()<<std::endl;\n\n            auto new_gc_b_cell = std::make_shared<GCBCell>(activated_b_cell->getX(), activated_b_cell->getY(), global_ID_counter++, activated_b_cell->getHeading());\n            new_gc_b_cell->copy_other_turtle_attributes(activated_b_cell);\n            new_gc_b_cell->setProBreg(0);\n            new_gc_b_cell->setColor('orange');\n            new_gc_b_cell->setShape('circle');\n            new_gc_b_cell->setSize(1);\n            new_gc_b_cell->setTimeAlive(0);\n\n            std::weak_ptr<Turtle> new_gc_b_cell_weak_ptr = new_gc_b_cell;\n            all_turtles.push_back(new_gc_b_cell_weak_ptr);\n            all_gcb_cells.push_back(new_gc_b_cell);\n            get_patch(new_gc_b_cell->getX(), new_gc_b_cell->getY()).add_turtle(new_gc_b_cell);\n\n            // createLinkWith(new_gc_b_cell, th2);\n            new_gc_b_cell->addLinkedTurtle(th2);\n            th2->setEbi2rLevel(0);\n            th2->setCcr7Level(0);\n            th2->setBcellBindingStatus(true);\n\n            kill(activated_b_cell);\n            return;\n        }\n    }\n}\n"
      },
      "4": {
            "Function_name": "void World::tiResponse(std::shared_ptr<ActivatedBCell> activated_b_cell) ",
            "Function_body": "void World::tiResponse(std::shared_ptr<ActivatedBCell> activated_b_cell) {\n    bool print_test = false;\n    // Activated B-cells undergoing TI response secrete TNF-a\n    auto current_patch = get_patch(activated_b_cell->getX(), activated_b_cell->getY());\n    current_patch.setTnfA(current_patch.getTnfA() + 1);\n\n    if (activated_b_cell->getTimeAlive() % 70 == 0) {\n        double proPC = (current_patch.getIl21() + current_patch.getIl10() + current_patch.getIfA() + current_patch.getIfG()) * 10;\n        double proMem = 0;\n        if (proPC > proMem) {\n            // Create a new SL Plasma Cell and add it to the corresponding containers\n            auto new_sl_plasma_cell = std::make_shared<SLPlasmaCell>(activated_b_cell->getX(), activated_b_cell->getY(), global_ID_counter++);\n            new_sl_plasma_cell->copy_other_turtle_attributes(activated_b_cell);\n            new_sl_plasma_cell->setTimeAlive(0);\n            // Set color, shape, size, etc. as required\n            new_sl_plasma_cell->setColor('lime');\n            new_sl_plasma_cell->setShape('circle');\n            new_sl_plasma_cell->setSize(1);\n\n\n            std::weak_ptr<Turtle> new_sl_plasma_cell_weak_ptr = new_sl_plasma_cell;\n            all_turtles.push_back(new_sl_plasma_cell_weak_ptr);\n            all_sl_plasma_cells.push_back(new_sl_plasma_cell);\n            get_patch(new_sl_plasma_cell->getX(), new_sl_plasma_cell->getY()).add_turtle(new_sl_plasma_cell);\n            if(print_test){std::cout<<'final SL plasma cell use count '<<new_sl_plasma_cell.use_count()<<std::endl;}\n        } else {\n            if (step < 2800) {\n                // Create a new Memory B Cell and add it to the corresponding containers\n                auto new_mem_b_cell = std::make_shared<MemBCell>(activated_b_cell->getX(), activated_b_cell->getY(), global_ID_counter++);\n                new_mem_b_cell->copy_other_turtle_attributes(activated_b_cell);\n\n                new_mem_b_cell->setExposureNumber(1);\n                new_mem_b_cell->setTimeAlive(0);\n                // Set color, shape, size, etc. as required\n                new_mem_b_cell->setColor('pink');\n                new_mem_b_cell->setShape('target');\n                new_mem_b_cell->setSize(1);\n                new_mem_b_cell->setS1pr1Level(10);\n                new_mem_b_cell->setProBreg(0);\n                new_mem_b_cell->setCd21Level(0);\n                new_mem_b_cell->setCxcr5Level(10);\n\n                std::weak_ptr<Turtle> new_mem_b_cell_weak_ptr = new_mem_b_cell;\n                all_turtles.push_back(new_mem_b_cell_weak_ptr);\n                all_mem_b_cells.push_back(new_mem_b_cell);\n                get_patch(new_mem_b_cell->getX(), new_mem_b_cell->getY()).add_turtle(new_mem_b_cell);\n\n            } else {\n                // Create a new Memory B Cell and add it to the corresponding containers\n                auto new_mem_b_cell = std::make_shared<MemBCell>(activated_b_cell->getX(), activated_b_cell->getY(), global_ID_counter++);\n                new_mem_b_cell->copy_other_turtle_attributes(activated_b_cell);\n\n                new_mem_b_cell->setExposureNumber(2);\n                new_mem_b_cell->setTimeAlive(0);\n                // Set color, shape, size, etc. as required\n                new_mem_b_cell->setColor('pink');\n                new_mem_b_cell->setShape('target');\n                new_mem_b_cell->setSize(1);\n                new_mem_b_cell->setS1pr1Level(10);\n                new_mem_b_cell->setProBreg(0);\n                new_mem_b_cell->setCd21Level(0);\n                new_mem_b_cell->setCxcr5Level(10);\n\n                std::weak_ptr<Turtle> new_mem_b_cell_weak_ptr = new_mem_b_cell;\n                all_turtles.push_back(new_mem_b_cell_weak_ptr);\n                all_mem_b_cells.push_back(new_mem_b_cell);\n                get_patch(new_mem_b_cell->getX(), new_mem_b_cell->getY()).add_turtle(new_mem_b_cell);\n\n            }\n        }\n    }\n}\n"
      },
      "5": {
            "Function_name": "Antibodies::Antibodies(int x, int y, int id, int heading) : Turtle(x, y, id, heading) ",
            "Function_body": "Antibodies::Antibodies(int x, int y, int id, int heading) : Turtle(x, y, id, heading) {\n    // Constructor\n    // std::cout<<'creating antibdy at '<<x<<', '<<y<<' with ID '<<id<<std::endl;\n}"
      },
      "6": {
            "Function_name": "void World::antibodiesFunction(std::shared_ptr<Antibodies> antibody) ",
            "Function_body": "void World::antibodiesFunction(std::shared_ptr<Antibodies> antibody) {\n  if (!antibody->get_is_alive()) {return;}\n\n    // Increase the time alive of the antibody\n    antibody->setTimeAlive(antibody->getTimeAlive() + 1);\n\n    // Check if the antibody has exceeded its lifespan\n    if (antibody->getTimeAlive() > 900) {\n        // If it has, kill the antibody\n        // std::cout<<'killing antibody at end of life. ID is '<<antibody->getID()<<std::endl;\n        kill(antibody);\n    }\n}"
      },
      "7": {
            "Function_name": "Bacteria::Bacteria(int x, int y, int id, int heading) : Turtle(x, y, id, heading) ",
            "Function_body": "Bacteria::Bacteria(int x, int y, int id, int heading) : Turtle(x, y, id, heading) {\n    // Constructor\n    // std::cout<<'creating bacteria with ID '<<id<<std::endl;\n\n}"
      },
      "8": {
            "Function_name": "void World::bacteriaFunction(std::shared_ptr<Bacteria> bacteria) ",
            "Function_body": "void World::bacteriaFunction(std::shared_ptr<Bacteria> bacteria) {\n  bool print_test = false;\n  if (!bacteria->get_is_alive()) {return;}\n    Patch& current_patch = get_patch(bacteria->getX(), bacteria->getY());\n\n    // Check if the current patch type is 2\n    if (current_patch.getPatchType() == 2) {\n        int x = rand() % 2; // Randomly generate 0 or 1\n        if (x == 0) {\n            place_turtle(WORLD_WIDTH-2, std::ceil(WORLD_HEIGHT/2), bacteria);\n            bacteria->setS1pr1Level(0);\n        } else {\n            std::vector<std::shared_ptr<FDCs>> available_fdcs = get_fdcs_with_no_presented_antigen();\n\n            if (!available_fdcs.empty()) {\n                auto fdc = available_fdcs[RNG_Engine() % available_fdcs.size()];\n                fdc->setTimePresenting(0);\n                fdc->setPresentedAntigen(bacteria->getEpitopeType());\n                if (print_test){std::cout<<'BACTERIA SETTING FDC COLOR TO RED'<<std::endl;}\n                fdc->setColor('red');\n                int rTI = RNG_Engine() % bacteria->getNumTIep();\n                int rTD = RNG_Engine() % bacteria->getNumTDep();\n                if (rTI > rTD) {\n                    fdc->setPresentedAntigenType(1);\n                } else {\n                    fdc->setPresentedAntigenType(2);\n                }\n                if (print_test){std::cout<<'killing bacteria at end of life. ID is '<<bacteria->getID()<<std::endl;}\n                kill(bacteria);\n                return;\n            }\n        }\n    }\n\n    bacteria->setS1pr1Level(bacteria->getS1pr1Level() + 0.004);\n    chemotaxis(bacteria);\n    if (print_test){std::cout<<'Moving bacteria'<<std::endl;}\n    move_turtle(bacteria);\n}\n"
      },
      "9": {
            "Function_name": "BregCell::BregCell(int x, int y, int id, int heading) : Turtle(x, y, id, heading) ",
            "Function_body": "BregCell::BregCell(int x, int y, int id, int heading) : Turtle(x, y, id, heading) {\n    // Constructor\n    // std::cout<<'Creating a breg cell with ID '<<id<<std::endl;\n}"
      },
      "10": {
            "Function_name": "void World::bregFunction(std::shared_ptr<BregCell> breg_cell) ",
            "Function_body": "void World::bregFunction(std::shared_ptr<BregCell> breg_cell) {\n  if (!breg_cell->get_is_alive()) {return;}\n\n    // std::cout<<'breg_function for ID number '<<breg_cell->getID()<<std::endl;\n\n    // Get the patch where the BReg cell is\n    Patch& breg_patch = get_patch(breg_cell->getX(), breg_cell->getY());\n\n    // Secretes the cytokines\n    breg_patch.setIl10(breg_patch.getIl10() + 5);\n    breg_patch.setTgfB(breg_patch.getTgfB() + 1);\n\n    // Chemotaxis and move\n    chemotaxis(breg_cell);\n    // std::cout<<'Moving breg'<<std::endl;\n    \n    move_turtle(breg_cell);\n\n    // Check TNF status\n    bool die_by_tnf = checkTNFStatus(breg_cell);\n\n    // Increase the time alive\n    breg_cell->setTimeAlive(breg_cell->getTimeAlive() + 1);\n\n    // Kill if the time alive exceeds 300\n    if((breg_cell->getTimeAlive() > 300)|| die_by_tnf) {\n      // std::cout<<'killing breg_cell at end of life. ID is '<<breg_cell->getID()<<std::endl;\n      kill(breg_cell);\n    }\n}\n"
      },
      "11": {
            "Function_name": "FDCs::FDCs(int x, int y, int id, int heading) : Turtle(x, y, id, heading) ",
            "Function_body": "FDCs::FDCs(int x, int y, int id, int heading) : Turtle(x, y, id, heading) {\n    // Constructor\n    // std::cout<<'creating FDC with ID '<<id<<std::endl;\n\n}"
      },
      "12": {
            "Function_name": "void World::fdcFunction(std::shared_ptr<FDCs> fdc) ",
            "Function_body": "void World::fdcFunction(std::shared_ptr<FDCs> fdc) {\n  // std::cout<<'Doing FDC Function!'<<std::endl;\n    // Get the patch where the FDC is\n    Patch& fdc_patch = get_patch(fdc->getX(), fdc->getY());\n\n    // Secretes the cytokines\n    fdc_patch.setCxcl13Level(fdc_patch.getCxcl13Level() + 2);\n    fdc_patch.setIl4(fdc_patch.getIl4() + 1);\n    fdc_patch.setIl6(fdc_patch.getIl6() + 2);\n    fdc_patch.setIl15(fdc_patch.getIl15() + 2);\n    fdc_patch.setIl12(fdc_patch.getIl12() + 2);\n\n    // If FDC is presenting antigen, determines when it will stop presenting it\n    if(fdc->getPresentedAntigen() != 0) {\n        fdc->setTimePresenting(fdc->getTimePresenting() + 1);\n    }\n    if(fdc->getTimePresenting() == 300) {\n        // Stops presenting the antigen after 300 steps\n        fdc->setPresentedAntigen(0);\n        fdc->setColor('brown');\n        fdc->setPresentedAntigenType(0);\n        fdc->setTimePresenting(0);\n    }\n\n    // Calculate FDC responsiveness\n    fdc->calculate_responsiveness();\n}"
      },
      "13": {
            "Function_name": "void FDCs::calculate_responsiveness() ",
            "Function_body": "void FDCs::calculate_responsiveness() {\n    if(responsiveness > 0) {\n        responsiveness -= 0.01;\n    }\n}"
      },
      "14": {
            "Function_name": "GCBCell::GCBCell(int x, int y, int id, int heading) : Turtle(x, y, id, heading) ",
            "Function_body": "GCBCell::GCBCell(int x, int y, int id, int heading) : Turtle(x, y, id, heading) {\n    // Constructor\n    // std::cout<<'creating GCBcell with ID '<<id<<std::endl;\n\n}"
      },
      "15": {
            "Function_name": "void World::gc_b_cell_function(std::shared_ptr<GCBCell> gc_b_cell) ",
            "Function_body": "void World::gc_b_cell_function(std::shared_ptr<GCBCell> gc_b_cell) {\n  if (!gc_b_cell->get_is_alive()) {return;}\n  bool print_test = false;\n  if (print_test){std::cout<<'doing GCB cell function for cell '<<gc_b_cell->getID()<<std::endl;}\n\n    if(!gc_b_cell->getInBlood()) {\n      // std::cout<<'doing GCB cell function for cell not in blood '<<gc_b_cell->getID()<<std::endl;\n      // std::cout<<'location is '<<gc_b_cell->getX()<<', '<<gc_b_cell->getY()<<std::endl;\n        Patch& current_patch = get_patch(gc_b_cell->getX(), gc_b_cell->getY());\n\n        if(current_patch.getPatchType() == 2) {\n            gc_b_cell->setInBlood(true);\n            gc_b_cell->setVisible(false);\n        }\n\n        // Downregulates ebi2r and ccr7 so it can localize to follicle center again\n        gc_b_cell->setEbi2rLevel(0);\n        gc_b_cell->setCcr7Level(0);\n\n        // The GC B-cell only moves if it has not yet reached the follicle center\n        if(calculateDistance(WORLD_WIDTH/2, WORLD_HEIGHT/2, gc_b_cell->getX(), gc_b_cell->getY()) > 15) {\n          if (print_test){std::cout<<'doing GCB cell function for large distance to center  '<<gc_b_cell->getID()<<std::endl;}\n          if (print_test){std::cout<<'location is '<<gc_b_cell->getX()<<', '<<gc_b_cell->getY()<<std::endl;}\n            chemotaxis(gc_b_cell);\n            if (print_test){std::cout<<'Moving gcb'<<std::endl;}\n\n            move_turtle(gc_b_cell, 0.5);\n            if (print_test){std::cout<<'gcb moved'<<std::endl;}\n\n            // gc_b_cell->gc_move();\n        } else {\n          if (print_test){std::cout<<'DISTANCE OF GC B CELL TO CENTER IS < 15 SO DOING ELSE PART OF GCB CELL FUNCTION'<<std::endl;}\n\n            double proPC2 = current_patch.getIl21() + current_patch.getIl10() * 2 + current_patch.getIfA() + current_patch.getIfG();\n            if (print_test){std::cout<<'got proPC2'<<std::endl;}\n            double proMem2 = current_patch.getIl21() + current_patch.getIl4();\n            if (print_test){std::cout<<'got proMem2'<<std::endl;}\n            double proPC = fmod(RNG_Engine(), proPC2);\n            if (print_test){std::cout<<'got proPC'<<std::endl;}\n            double proMem = fmod(RNG_Engine(), proMem2);\n            if (print_test){std::cout<<'got proMem'<<std::endl;}\n\n            if(gc_b_cell->getTimeAlive() % 80 == 0) {\n                if(proPC > proMem) {\n                    auto plasma_cell = std::make_shared<LLPlasmaCell>(gc_b_cell->getX(), gc_b_cell->getY(), global_ID_counter++, gc_b_cell->getHeading());\n                    plasma_cell->copy_other_turtle_attributes(gc_b_cell);\n                    plasma_cell->setExposureNumber(step < 2800 ? 1 : 2);\n                    plasma_cell->setTimeAlive(0);\n                    plasma_cell->setColor('lime');\n                    plasma_cell->setShape('circle');\n                    plasma_cell->setSize(1);\n                    plasma_cell->setS1pr1Level(40);\n                    plasma_cell->setProBreg(0);\n                    plasma_cell->setTnfaThreshold(plasma_cell->getTnfaThreshold() - 130);\n                    std::weak_ptr<Turtle> plasma_cell_weak_ptr = plasma_cell;\n                    all_turtles.push_back(plasma_cell_weak_ptr);\n                    all_ll_plasma_cells.push_back(plasma_cell);\n                    get_patch(plasma_cell->getX(), plasma_cell->getY()).add_turtle(plasma_cell);\n\n                } else {\n                    auto mem_b_cell = std::make_shared<MemBCell>(gc_b_cell->getX(), gc_b_cell->getY(), global_ID_counter++, gc_b_cell->getHeading());\n                    mem_b_cell->copy_other_turtle_attributes(gc_b_cell);\n                    mem_b_cell->setExposureNumber(step < 2800 ? 1 : 2);\n                    mem_b_cell->setTimeAlive(0);\n                    mem_b_cell->setColor('pink');\n                    mem_b_cell->setShape('target');\n                    mem_b_cell->setS1pr1Level(10);\n                    mem_b_cell->setProBreg(0);\n                    mem_b_cell->setCd21Level(0);\n                    mem_b_cell->setCxcr5Level(10);\n\n                    std::weak_ptr<Turtle> mem_b_cell_weak_ptr = mem_b_cell;\n                    all_turtles.push_back(mem_b_cell_weak_ptr);\n                    all_mem_b_cells.push_back(mem_b_cell);\n                    get_patch(mem_b_cell->getX(), mem_b_cell->getY()).add_turtle(mem_b_cell);\n                }\n            }\n        }\n\n        //check_breg_status(gc_b_cell);\n    }\n    if (print_test){std::cout<<'gcb function part 2'<<std::endl;}\n\n    bool die_by_tnf = checkTNFStatus(gc_b_cell);\n\n    gc_b_cell->setTimeAlive(gc_b_cell->getTimeAlive() + 1);\n    if (print_test){std::cout<<'gcb time alive'<<std::endl;}\n    if((gc_b_cell->getTimeAlive() > 700) || die_by_tnf) {\n      if (print_test){std::cout<<'gcb unbinding neighbor'<<std::endl;}\n      if (print_test){std::cout<<'linkedTurtles: '<<gc_b_cell->getLinkedTurtles().size()<<std::endl;}\n\n        for(auto neighbor : gc_b_cell->getLinkedTurtles()) {\n          if (std::shared_ptr<TfhCell> cell_to_unbind = std::dynamic_pointer_cast<TfhCell>(neighbor.lock())){\n            cell_to_unbind->setBcellBindingStatus(false);\n            if (print_test){std::cout<<'gcb neighbor unbound'<<std::endl;}\n\n          } else if (std::shared_ptr<Th2Cell> cell_to_unbind = std::dynamic_pointer_cast<Th2Cell>(neighbor.lock())){\n            cell_to_unbind->setBcellBindingStatus(false);\n            if (print_test){std::cout<<'gcb neighbor unbound'<<std::endl;}\n\n          }\n        }\n        if (print_test){std::cout<<'killing gdb'<<std::endl;}\n        kill(gc_b_cell);\n        if (print_test){std::cout<<'killing dead'<<std::endl;}\n\n    }\n}"
      },
      "16": {
            "Function_name": "// Function to calculate Euclidean distance between two points\ndouble calculateDistance(int x1, int y1, int x2, int y2) ",
            "Function_body": "// Function to calculate Euclidean distance between two points\ndouble calculateDistance(int x1, int y1, int x2, int y2) {\n    double dx = x2 - x1;\n    double dy = y2 - y1;\n    return std::sqrt(dx * dx + dy * dy);\n}"
      },
      "17": {
            "Function_name": "// Function to generate coordinates within a radius without buffer zone\nstd::vector<std::pair<int, int>> generateCoordinates(int number_to_generate, int center_x, int center_y, int radius_from_center, int buffer_zone_between_points) ",
            "Function_body": "// Function to generate coordinates within a radius without buffer zone\nstd::vector<std::pair<int, int>> generateCoordinates(int number_to_generate, int center_x, int center_y, int radius_from_center, int buffer_zone_between_points) {\n  std::size_t n = number_to_generate;\n  int x = center_x;\n  int y = center_y;\n  int r = radius_from_center;\n  int b = buffer_zone_between_points;\n  \n    std::vector<std::pair<int, int>> coordinates;\n\n    // Generate random coordinates within the radius\n    while (coordinates.size() < n) {\n        int newX = std::rand() % (2 * r + 1) + (x - r);\n        int newY = std::rand() % (2 * r + 1) + (y - r);\n        \n        bool isValid = true;\n        if (calculateDistance(newX, newY, x, y) > r){isValid=false;}\n        for (const auto& coord : coordinates) {\n            // Check if the new coordinate is within the buffer zone\n            if (!isValid){break;}\n            if (calculateDistance(newX, newY, coord.first, coord.second) <= b) {\n                isValid = false;\n            }\n        }\n\n        if (isValid) {\n            coordinates.emplace_back(newX, newY);\n        }\n    }\n\n    return coordinates;\n}\n"
      },
      "18": {
            "Function_name": "LLPlasmaCell::LLPlasmaCell(int x, int y, int id, int heading) : Turtle(x, y, id, heading) ",
            "Function_body": "LLPlasmaCell::LLPlasmaCell(int x, int y, int id, int heading) : Turtle(x, y, id, heading) {\n    // Constructor\n    // std::cout<<'creating LL Plasma cell'<<std::endl;\n\n}"
      },
      "19": {
            "Function_name": "int main(int argc, char const *argv[]) ",
            "Function_body": "int main(int argc, char const *argv[]) {\n  std::cout<<'starting main'<<std::endl;\n  World world = World();\n  World* worldptr = &world; // pointer to give to rendering engine\n  RenderingEngine engine;\n  // setting up world\n  world.setup();\n  // world.injure_sterile(INJURY_NUMBER);\n  world.updateTurtleVectors();\n\n  // setting up rendering engine\n  if (RENDERING){\n    engine.~RenderingEngine();\n    new (&engine) RenderingEngine(worldptr);\n  }\n  bool quit=false;\n  bool paused=false;\n  SDL_Event event;\n\n\n  auto startTime = std::chrono::high_resolution_clock::now();\n  // main loop\n  std::cout<<'STARTING GO'<<std::endl;\n  for (size_t i = 0; i < NUM_STEPS; i++) {\n    if (i%100==0){\n      std::cout<<'#######################################################\n Beginning Step Number ' <<i<<'\n#######################################################'<<std::endl;\n    }\n    if (!paused){\n      world.go();\n    }\n\n    // rendering loop\n    if (RENDERING){\n      engine.setBackgroundColor('black');\n      engine.renderAllPatches();\n      engine.renderPatchMode();\n      engine.renderAllTurtles();\n      engine.render();\n      while (SDL_PollEvent(&event)) {\n           if (event.type == SDL_QUIT) {\n               quit = true;\n           }\n           if (event.type == SDL_KEYDOWN && event.key.keysym.sym == SDLK_SPACE) {\n               paused = !paused; // Toggle pause state\n           }\n       }\n\n       if (quit) {\n           break;\n       }\n\n       // While paused, keep checking for events and only proceed if space is pressed again\n       while (paused) {\n           while (SDL_PollEvent(&event)) {\n               if (event.type == SDL_QUIT) {\n                   quit = true;\n                   paused = false;\n               }\n               if (event.type == SDL_KEYDOWN && event.key.keysym.sym == SDLK_SPACE) {\n                   paused = !paused; // Toggle pause state\n               }\n           }\n           std::this_thread::sleep_for(std::chrono::milliseconds(10)); // Sleep for a short duration to avoid busy-waiting\n       }\n       std::this_thread::sleep_for(std::chrono::milliseconds(50));\n   }\n\n\n  }\n  auto endTime = std::chrono::high_resolution_clock::now();\n  auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime);\n  std::cout << 'Program duration: ' << duration.count() << ' milliseconds' << std::endl;\n\n  return 0;\n}"
      },
      "20": {
            "Function_name": "MemBCell::MemBCell(int x, int y, int id, int heading) : Turtle(x, y, id, heading) ",
            "Function_body": "MemBCell::MemBCell(int x, int y, int id, int heading) : Turtle(x, y, id, heading) {\n    // Constructor\n    // std::cout<<'creating memory B cell ID '<<id<<' at x,y '<<x<<', '<<y<<std::endl;\n\n}"
      },
      "21": {
            "Function_name": "void World::memBCellFunction(std::shared_ptr<MemBCell> mem_b_cell) ",
            "Function_body": "void World::memBCellFunction(std::shared_ptr<MemBCell> mem_b_cell) {\n  if (!mem_b_cell->get_is_alive()) {return;}\n  bool print_test = false;\n  if (print_test){std::cout<<'memory_b_cellfunction for ID number '<<mem_b_cell->getID()<<std::endl;}\n  if (print_test){std::cout<<'memory_b_cellfunction location '<<mem_b_cell->getX()<<', '<<mem_b_cell->getY()<<std::endl;}\n\n  // Get the current patch of the Memory B cell\n  Patch& current_patch = get_patch(mem_b_cell->getX(), mem_b_cell->getY());\n\n  // Calculate CD21 expression based on il6 and il10 levels in the current patch\n  int cd21_level = 300 - (current_patch.getIl6() * 50 + current_patch.getIl10() * 0);\n  mem_b_cell->setCd21Level(cd21_level);\n\n  // If the memory B cell is in the follicle\n  if(current_patch.getPatchType() == 2) {\n    place_turtle(WORLD_WIDTH, std::ceil(WORLD_HEIGHT/2), mem_b_cell);\n    mem_b_cell->setProBreg(0);\n    mem_b_cell->setS1pr1Level(0);\n    mem_b_cell->setTimeInFollicle(0);\n  }\n\n  mem_b_cell->setTimeInFollicle(mem_b_cell->getTimeInFollicle() + 1);\n  if(mem_b_cell->getTimeInFollicle() > 300) {\n    mem_b_cell->setS1pr1Level(mem_b_cell->getS1pr1Level() + 0.5);\n  }\n\n  mem_b_cell->setTimeAlive(mem_b_cell->getTimeAlive() + 1);\n  if(mem_b_cell->getTimeAlive() > 15000) {\n    if (print_test){std::cout<<'Killing mem_b_cell for age '<<mem_b_cell->getID()<<'. use count:'<<mem_b_cell.use_count()<<std::endl;}\n\n    kill(mem_b_cell);\n    return;\n  }\n\n  auto apc = getOneFDCHere(mem_b_cell->getX(), mem_b_cell->getY());\n  int random_encounter = RNG_Engine() % 100;\n  auto antigen = getOneBacteriaHere(mem_b_cell->getX(), mem_b_cell->getY());\n\n  if((apc != nullptr && apc->getPresentedAntigen() != 0 && apc->getResponsiveness() > random_encounter) || antigen != nullptr){\n    if(mem_b_cell->getCd21Level() > BCELL_CD21_ACTIVATION_THRESHOLD){\n\n      auto new_activated_b_cell = std::make_shared<ActivatedBCell>(mem_b_cell->getX(), mem_b_cell->getY(), global_ID_counter++, mem_b_cell->getHeading());\n      new_activated_b_cell->copy_other_turtle_attributes(mem_b_cell);\n      current_patch.setIl6(current_patch.getIl6() + PHAG_IL6_BURST);\n      new_activated_b_cell->setProBreg(0);\n      new_activated_b_cell->setShape('target');\n      new_activated_b_cell->setSize(1);\n      new_activated_b_cell->setColor('cyan');\n      new_activated_b_cell->setCsrBool(false);\n      new_activated_b_cell->setTimeAlive(100);\n\n\n      int rTI = RNG_Engine() % 100;\n      int rTD = RNG_Engine() % 100;\n      if(antigen != nullptr){\n\n        if(rTI > rTD){\n          new_activated_b_cell->setResponseType(1); // TI response\n        } else{\n          new_activated_b_cell->setResponseType(2); // TD response\n          new_activated_b_cell->setCcr7Level(12);\n          new_activated_b_cell->setEbi2rLevel(12);\n        }\n        if (print_test){std::cout<<'Killing antigen in memory_b_cell function '<<antigen->getID()<<'. use count:'<<antigen.use_count()<<std::endl;}\n        kill(antigen);\n      }\n      else if (apc != nullptr){\n        if(rTI > rTD){\n            new_activated_b_cell->setResponseType(1); // TI response\n        }\n        else{\n            new_activated_b_cell->setResponseType(2); // TD response\n            new_activated_b_cell->setCcr7Level(12);\n            new_activated_b_cell->setEbi2rLevel(12);\n        }\n      }\n\n      std::weak_ptr<Turtle> new_activated_b_cell_weak_ptr = new_activated_b_cell;\n      all_turtles.push_back(new_activated_b_cell_weak_ptr);\n      all_activated_b_cells.push_back(new_activated_b_cell);\n      get_patch(new_activated_b_cell->getX(), new_activated_b_cell->getY()).add_turtle(new_activated_b_cell);\n\n      kill(mem_b_cell); // kill old memory b cell because its not an activated b cell\n      return;\n      // std::shared_ptr<ActivatedBCell> mem_b_cell = new_activated_b_cell;  //renaming mem_b_cell so rest of the function still works on the new cell\n    }\n  }\n  // Checks level of stimulation of b-reg differentiation\n  bool turn_into_breg = checkBregStatus(mem_b_cell);\n  if (turn_into_breg){\n    if (print_test){std::cout<<'Mem B ID '<<mem_b_cell->getID()<<'turning into Breg'<<std::endl;}\n    std::shared_ptr<BregCell> mem_b_cell = turnIntoBreg(mem_b_cell);\n  };\n\n  chemotaxis(mem_b_cell);\n  if (print_test){std::cout<<'Moving mem_b cell'<<std::endl;}\n\n  move_turtle(mem_b_cell);\n\n\n  // Checks level of TNF-a stimulation for apoptosis\n  if(checkTNFStatus(mem_b_cell)){kill(mem_b_cell);};\n}"
      },
      "22": {
            "Function_name": "NaiveBCell::NaiveBCell(int x, int y, int id, int heading) : Turtle(x, y, id, heading) ",
            "Function_body": "NaiveBCell::NaiveBCell(int x, int y, int id, int heading) : Turtle(x, y, id, heading) {\n    // Constructor\n    // std::cout<<'creating naive B cell with ID '<<id<<std::endl;\n\n}"
      },
      "23": {
            "Function_name": "void World::spawnBCell() ",
            "Function_body": "void World::spawnBCell() {\n  bool print_test = false;\n  if(step % 10 == 0) {\n    // std::cout<<'SPAWNING B CELL'<<std::endl;\n      // Position of the new Naive B-cell\n      int cell_x = WORLD_WIDTH -2; //I added std::floor()\n      int cell_y = std::floor(WORLD_HEIGHT / 2);\n\n      // Create a new Naive B-cell\n      auto b_cell = std::make_shared<NaiveBCell>(cell_x, cell_y, global_ID_counter++, 180);\n      if (print_test){std::cout<< 'NaiveBCell use count after creation  '<<b_cell.use_count()<<std::endl;}\n\n      std::weak_ptr<Turtle> b_cell_weak_ptr = b_cell;\n      if (print_test){std::cout<< 'NaiveBCell use count after weap tr  '<<b_cell.use_count()<<std::endl;}\n\n      // Set the properties of the new Naive B-cell\n      b_cell->setShape('circle');\n      b_cell->setColor('white');\n      b_cell->setSize(1);\n      b_cell->setTimeAlive(0);\n      b_cell->setBcr(RNG_Engine() % 30);\n      b_cell->setIsotype('md');\n      b_cell->setS1pr1Level(0);\n      b_cell->setS1pr2Level(0);\n      b_cell->setCxcr5Level(16);\n      b_cell->setCcr7Level(0);\n      b_cell->setEbi2rLevel(0);\n      b_cell->setCd21Level(0);\n      b_cell->setInBlood(false);\n\n      // Set thresholds\n      b_cell->setTnfaThreshold(BCELL_TNFA_APOP_THRESHOLD + (RNG_Engine() % 50));\n      b_cell->setBregThreshold(BCELL_BREG_DIFF_THRESHOLD + (RNG_Engine() % 50));\n\n      // Add the new Naive B-cell to the list\n      all_naive_b_cells.push_back(b_cell);\n      if (print_test){std::cout<< 'NaiveBCell use count after all cells pushback  '<<b_cell.use_count()<<std::endl;}\n\n      all_turtles.push_back(b_cell_weak_ptr);\n      if (print_test){std::cout<< 'NaiveBCell use count after all turtles pushback  '<<b_cell.use_count()<<std::endl;}\n\n      get_patch(b_cell->getX(), b_cell->getY()).add_turtle(b_cell);\n      if (print_test){std::cout<< 'NaiveBCell use count after all patch add  '<<b_cell.use_count()<<std::endl;}\n\n  }\n}"
      },
      "24": {
            "Function_name": "void World::naiveBCellFunction(std::shared_ptr<NaiveBCell> naive_b_cell) ",
            "Function_body": "void World::naiveBCellFunction(std::shared_ptr<NaiveBCell> naive_b_cell) {\n  if (!naive_b_cell->get_is_alive()) {return;}\n\n  bool print_test = false;\n  // std::cout<<'naive_b_cellfunction for ID number '<<naive_b_cell->getID()<<'Ebi2rLevel '<<naive_b_cell->getEbi2rLevel()<<std::endl;\n  // Get the current patch of the naive B cell\n  Patch& current_patch = get_patch(naive_b_cell->getX(), naive_b_cell->getY());\n\n  // Calculate CD21 expression based on il6 and il10 levels in the current patch\n  int cd21_level = 300 - (current_patch.getIl6() * 50 + current_patch.getIl10() * 0);\n  // std::cout<<'setting cd21 level to be '<<cd21_level<<' for cell with ID '<<naive_b_cell->getID()<<std::endl;\n  naive_b_cell->setCd21Level(cd21_level);\n\n  // If naive B cell is in the follicle, it dies\n  if (current_patch.getPatchType() == 2) {\n    // std::cout<<'killing naive Bcell on follicle exit '<<naive_b_cell->getID()<<std::endl;\n    // std::cout<<'naive_b_cell use count is '<<naive_b_cell.use_count()<<std::endl;\n    kill(naive_b_cell);\n    return;\n  }\n  auto apc = getOneFDCHere(naive_b_cell->getX(), naive_b_cell->getY());\n  int random_encounter = RNG_Engine() % 100;\n  auto antigen = getOneBacteriaHere(naive_b_cell->getX(), naive_b_cell->getY());\n\n  if ((apc != nullptr && apc->getPresentedAntigen() != 0 && apc->getResponsiveness() > random_encounter) || antigen != nullptr){\n    if (print_test){std::cout<<'STEPPING INTO NAIVE_B_CELL FUNCTION. ID is '<<naive_b_cell->getID()<<std::endl;}\n    if(naive_b_cell->getCd21Level() > BCELL_CD21_ACTIVATION_THRESHOLD){\n      if(print_test){std::cout<<'becoming activated B_cell'<<std::endl;}\n      // creating a new activated_b_cell\n      // std::cout<<'Before turning into activated b cell, original naive_b_cell use count is '<<naive_b_cell.use_count()<<std::endl;\n\n      auto new_activated_b_cell = std::make_shared<ActivatedBCell>(naive_b_cell->getX(), naive_b_cell->getY(), global_ID_counter++, naive_b_cell->getHeading());\n      if (print_test){std::cout<< 'new_activated_b_cell use count upon creation '<<new_activated_b_cell.use_count()<<std::endl;}\n      new_activated_b_cell->copy_other_turtle_attributes(naive_b_cell);\n      if (print_test){std::cout<< 'new_activated_b_cell use count after copy  '<<new_activated_b_cell.use_count()<<std::endl;}\n\n      // std::cout<<'After creeating but before turning into activated b cell, original naive_b_cell use count is '<<naive_b_cell.use_count()<<std::endl;\n      \n      current_patch.setIl6(current_patch.getIl6() + PHAG_IL6_BURST);\n      new_activated_b_cell->setProBreg(0);\n      new_activated_b_cell->setShape('target');\n      new_activated_b_cell->setSize(1);\n      new_activated_b_cell->setColor('red');\n      new_activated_b_cell->setCsrBool(false);\n      new_activated_b_cell->setTimeAlive(0);\n\n      if (print_test){std::cout<<'location of mew activated_b_Cell is '<<new_activated_b_cell->getX()<<', '<<new_activated_b_cell->getY()<<std::endl;}\n\n      int rTI = RNG_Engine() % 100;\n      int rTD = RNG_Engine() % 100;\n\n      if(antigen != nullptr){\n        if(rTI > rTD){\n          new_activated_b_cell->setResponseType(1); // TI response\n        } else{\n          new_activated_b_cell->setResponseType(2); // TD response\n          new_activated_b_cell->setCcr7Level(12);\n          new_activated_b_cell->setEbi2rLevel(12);\n        }\n        if (print_test){std::cout<<'Killing antigen in naive_b_cell function '<<antigen->getID()<<'. use count:'<<antigen.use_count()<<std::endl;}\n\n        kill(antigen);\n      }\n      else if (apc != nullptr){\n        if(rTI > rTD){\n            new_activated_b_cell->setResponseType(1); // TI response\n        }\n        else{\n            new_activated_b_cell->setResponseType(2); // TD response\n            new_activated_b_cell->setCcr7Level(12);\n            new_activated_b_cell->setEbi2rLevel(12);\n        }\n      }\n\n\n      std::weak_ptr<Turtle> new_activated_b_cell_weak_ptr = new_activated_b_cell;\n      if (print_test){std::cout<< 'new_activated_b_cell use count after weak ptr  '<<new_activated_b_cell.use_count()<<std::endl;}\n\n      all_activated_b_cells.push_back(new_activated_b_cell);\n      if (print_test){std::cout<< 'new_activated_b_cell use count after all_activated_b_cells pushback '<<new_activated_b_cell.use_count()<<std::endl;}\n      all_turtles.push_back(new_activated_b_cell_weak_ptr);\n      if (print_test){std::cout<< 'new_activated_b_cell use count after turtles pushback  '<<new_activated_b_cell.use_count()<<std::endl;}\n      \n      get_patch(new_activated_b_cell->getX(), new_activated_b_cell->getY()).add_turtle(new_activated_b_cell);\n      // current_patch.add_turtle(new_activated_b_cell);\n      if (print_test){std::cout<< 'new_activated_b_cell use count after patch add  '<<new_activated_b_cell.use_count()<<std::endl;}\n      // std::cout<<'After turning into activated b cell, original naive_b_cell use count is '<<naive_b_cell.use_count()<<std::endl;\n      // std::cout<<'After turning into activated b cell, original naive_b_cell ID is '<<naive_b_cell->getID()<<std::endl;\n      kill(naive_b_cell);\n\n      // std::shared_ptr<ActivatedBCell> naive_b_cell = new_activated_b_cell; // renaming naive_b_Cell so the rest of the function still works as expected\n      // std::cout<< 'new_activated_b_cell use count after rename  '<<new_activated_b_cell.use_count()<<std::endl;\n\n      return;\n    }\n  }\n\n\n  // if(print_test){std::cout<<'chomtaxin naive_b_cell'<<std::endl;}\n  // std::cout<< 'naive_b_cell use count before chemotaxis '<<naive_b_cell.use_count()<<std::endl;\n\n  chemotaxis(naive_b_cell);\n  // std::cout<< 'naive_b_cell use count after chemotaxis '<<naive_b_cell.use_count()<<std::endl;\n  // std::cout<<'Moving b_cell'<<std::endl;\n\n  move_turtle(naive_b_cell);\n  // std::cout<< 'naive_b_cell use count after move turtle '<<naive_b_cell.use_count()<<std::endl;\n\n  // Checks level of stimulation of b-reg differentiation\n  bool turn_into_breg = checkBregStatus(naive_b_cell);\n  if (turn_into_breg){\n    if (print_test){std::cout<<'naive_b cell ID '<<naive_b_cell->getID()<<'turning into Breg'<<std::endl;}\n    // cant do it like below, leads to weird error where orignal cell is overwritten in templated turnIntoBreg function.\n    // std::shared_ptr<BregCell> naive_b_cell = turnIntoBreg(naive_b_cell);\n    // need to do it like this instead\n    std::shared_ptr<BregCell> output_b_cell = turnIntoBreg(naive_b_cell);\n    std::shared_ptr<BregCell> naive_b_Cell;\n    naive_b_Cell = output_b_cell;\n  };\n\n  // Checks level of TNF-a stimulation for apoptosis\n  bool die_by_tnf = checkTNFStatus(naive_b_cell);\n\n  // this slowly increases the # of s1p receptors (s1pr) in the naive b cell when the b-cell is old enough\n  if(naive_b_cell->getTimeAlive() > 300)\n  {\n      naive_b_cell->setS1pr1Level(naive_b_cell->getS1pr1Level() + 0.5);\n  }\n\n  naive_b_cell->setTimeAlive(naive_b_cell->getTimeAlive() + 1);\n\n  // Checks if the cell has lived beyond its maximum lifespan, if so, it will be removed\n  if((naive_b_cell->getTimeAlive() > 1000) || die_by_tnf ) {\n      kill(naive_b_cell);\n  }\n\n\n}"
      },
      "25": {
            "Function_name": "void Patch::add_turtle(std::shared_ptr<Turtle> turtle_to_add)",
            "Function_body": "void Patch::add_turtle(std::shared_ptr<Turtle> turtle_to_add){\n  turtles_here.emplace_back(turtle_to_add);\n}"
      },
      "26": {
            "Function_name": "void Patch::remove_turtle(std::shared_ptr<Turtle> turtle_to_remove)",
            "Function_body": "void Patch::remove_turtle(std::shared_ptr<Turtle> turtle_to_remove){\n  turtles_here.erase(std::remove(turtles_here.begin(), turtles_here.end(), turtle_to_remove), turtles_here.end());\n  turtle_to_remove.reset();\n}"
      },
      "27": {
            "Function_name": "void Patch::display() ",
            "Function_body": "void Patch::display() {\n    std::cout << 'Patch position: (' << this->getX() << ', ' << getY() << ')' << std::endl;\n    // std::cout << 'Patch color: ' << color << std::endl;\n    if (turtles_here.size() > 0){\n      for (auto &turtle: turtles_here){\n        turtle->display();\n      }\n    }\n}"
      },
      "28": {
            "Function_name": "bool Patch::is_at_capacity()",
            "Function_body": "bool Patch::is_at_capacity(){\n  return (turtles_here.size() >= PATCH_MAX_CAPACITY);\n}"
      },
      "29": {
            "Function_name": "RenderingEngine::RenderingEngine()",
            "Function_body": "RenderingEngine::RenderingEngine(){\n  std::cout<<'calling default Constructor'<<std::endl;\n\n  // SDL_Init(SDL_INIT_VIDEO);\n  // window = SDL_CreateWindow('SDL Window', SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, SCREEN_WIDTH, SCREEN_HEIGHT, SDL_WINDOW_SHOWN);\n  // renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);\n  // SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_BLEND);\n  // SDL_RenderClear(renderer);\n}"
      },
      "30": {
            "Function_name": "RenderingEngine::RenderingEngine(World *world)",
            "Function_body": "RenderingEngine::RenderingEngine(World *world){\n  std::cout<<'calling world Constructor'<<std::endl;\n  myWorld = world;\n  SDL_Init(SDL_INIT_VIDEO);\n  window = SDL_CreateWindow('SDL Window', SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, SCREEN_WIDTH, SCREEN_HEIGHT, SDL_WINDOW_SHOWN);\n  renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);\n  SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_BLEND);\n  SDL_RenderClear(renderer);\n}"
      },
      "31": {
            "Function_name": "RenderingEngine::~RenderingEngine()",
            "Function_body": "RenderingEngine::~RenderingEngine(){\n  SDL_DestroyRenderer(renderer);\n  SDL_DestroyWindow(window);\n  SDL_Quit();\n}"
      },
      "32": {
            "Function_name": "std::tuple<int, int, int> RenderingEngine::getColor(const std::string& color)",
            "Function_body": "std::tuple<int, int, int> RenderingEngine::getColor(const std::string& color){\n  int red, green, blue;\n  if (color == 'red') {\n      red = 255;\n      green = 0;\n      blue = 0;\n  }\n  else if (color == 'green') {\n      red = 0;\n      green = 255;\n      blue = 0;\n  }\n  else if (color == 'cyan') {\n    red = 0;\n    green = 255;\n    blue = 255;\n  }\n  else if (color == 'blue') {\n      red = 0;\n      green = 0;\n      blue = 255;\n  }\n  else if (color =='black'){\n    red = 0;\n    green = 0;\n    blue = 0;\n  }\n  else if (color == 'white'){\n    red = 255;\n    green = 255;\n    blue = 255;\n  }\n  else if (color == 'yellow'){\n    red = 255;\n    green = 255;\n    blue = 0;\n  }\n  else if (color == 'violet'){\n    red = 127;\n    green = 0;\n    blue = 255;\n  }\n  else if (color =='brown'){\n    red = 85;\n    green = 42;\n    blue = 42;\n  }\n  else if (color == 'orange'){\n    red = 255;\n    green = 95;\n    blue = 31;\n  }\n  else if (color == 'grey' || color =='gray'){\n    red = 128;\n    green = 128;\n    blue = 128;\n  }\n  else if (color =='pink'){\n    red = 255;\n    green = 16;\n    blue = 240;\n  }\n  else if (color =='lime'){\n    red = 50;\n    green = 205;\n    blue = 50;\n  }\n  \n  else if (color == 'mauve'){\n    red = 172;\n    blue = 79;\n    green = 106;\n  }\n\n\n  else {\n    std::cout<<'using OTHER color'<<std::endl;\n    std::cout<<'color is '<<color<<std::endl;\n    \n      red = 255;\n      green = 16;\n      blue = 240;\n  }\n  return std::make_tuple(red, green, blue);\n}"
      },
      "33": {
            "Function_name": "void RenderingEngine::render()",
            "Function_body": "void RenderingEngine::render(){\n  SDL_RenderPresent(renderer);\n}"
      },
      "34": {
            "Function_name": "void RenderingEngine::setBackgroundColor(const std::string& color)",
            "Function_body": "void RenderingEngine::setBackgroundColor(const std::string& color){\n  std::tuple<int, int, int> RGB = getColor(color);\n    SDL_SetRenderDrawColor(renderer, std::get<0>(RGB), std::get<1>(RGB), std::get<2>(RGB), SDL_ALPHA_OPAQUE);\n    SDL_RenderClear(renderer);\n    // SDL_RenderPresent(renderer);\n}"
      },
      "35": {
            "Function_name": "void RenderingEngine::drawLine(double startX, double startY, double endX, double endY, const std::string& color, int alpha)",
            "Function_body": "void RenderingEngine::drawLine(double startX, double startY, double endX, double endY, const std::string& color, int alpha){\n  std::tuple<int, int, int> RGB = getColor(color);\n  SDL_SetRenderDrawColor(renderer, std::get<0>(RGB), std::get<1>(RGB), std::get<2>(RGB), alpha);\n  SDL_RenderDrawLine(renderer, startX, startY, endX, endY);\n  // SDL_RenderPresent(renderer);\n}"
      },
      "36": {
            "Function_name": "void RenderingEngine::drawCircle(double centerX, double centerY, double radius, const std::string& color, int alpha)",
            "Function_body": "void RenderingEngine::drawCircle(double centerX, double centerY, double radius, const std::string& color, int alpha){\n  centerX += GRID_SIZE/2;\n  centerY += GRID_SIZE/2;\n  std::tuple<int, int, int> RGB = getColor(color);\n  SDL_SetRenderDrawColor(renderer, std::get<0>(RGB), std::get<1>(RGB), std::get<2>(RGB), alpha);\n\n\tfor (int y = -radius; y <= radius; y++) {\n\t    for (int x = -radius; x <= radius; x++) {\n\t        if (x*x + y*y <= radius*radius) {\n\t            SDL_RenderDrawPoint(renderer, centerX + x, centerY + y);\n\t        }\n\t    }\n\t}\n\t// SDL_RenderPresent(renderer);\n}"
      },
      "37": {
            "Function_name": "void RenderingEngine::drawSquare(int x, int y, int size, const std::string& color, int alpha) ",
            "Function_body": "void RenderingEngine::drawSquare(int x, int y, int size, const std::string& color, int alpha) {\n  std::tuple<int, int, int> RGB = getColor(color);\n  SDL_SetRenderDrawColor(renderer, std::get<0>(RGB), std::get<1>(RGB), std::get<2>(RGB), alpha);\n  SDL_Rect rect = { x, y, size, size };\n  SDL_RenderFillRect(renderer, &rect);\n  // SDL_RenderPresent(renderer);\n}"
      },
      "38": {
            "Function_name": "void RenderingEngine::drawFilledEllipse(int centerX, int centerY, int radiusX, int radiusY, const std::string& color, int alpha, int angleDegrees) ",
            "Function_body": "void RenderingEngine::drawFilledEllipse(int centerX, int centerY, int radiusX, int radiusY, const std::string& color, int alpha, int angleDegrees) {\n    std::tuple<int, int, int> RGB = getColor(color);\n    SDL_SetRenderDrawColor(renderer, std::get<0>(RGB), std::get<1>(RGB), std::get<2>(RGB), alpha);\n    double angleRadians = (90 + angleDegrees) * M_PI / 180.0;\n    int major_axis = std::max(radiusX, radiusY);\n    for (int x = centerX - major_axis; x <= centerX + major_axis; ++x) {\n        for (int y = centerY - major_axis; y <= centerY + major_axis; ++y) {\n            // Compute the position of (x, y) in the rotated ellipse's frame of reference\n            double rotatedX = (x - centerX) * cos(-angleRadians) - (y - centerY) * sin(-angleRadians);\n            double rotatedY = (x - centerX) * sin(-angleRadians) + (y - centerY) * cos(-angleRadians);\n\n            // Check if this rotated point lies within the unrotated ellipse\n            if ((rotatedX * rotatedX) / (radiusX * radiusX) + (rotatedY * rotatedY) / (radiusY * radiusY) <= 1) {\n                SDL_RenderDrawPoint(renderer, x, y);\n            }\n        }\n    }\n}"
      },
      "39": {
            "Function_name": "void RenderingEngine::renderAllPatches()",
            "Function_body": "void RenderingEngine::renderAllPatches(){\n  for (int x = 0; x < WORLD_WIDTH; x++){\n    for (int y = 0; y < WORLD_HEIGHT; y++){\n      auto& patch = myWorld->get_patch(x,y);\n      int patch_x = patch.getX() * GRID_SIZE;\n      int patch_y = patch.getY() * GRID_SIZE;\n      std::string color = patch.getColor();\n      int opacity = patch.getOpacity();\n      drawSquare(patch_x,patch_y,GRID_SIZE, color, opacity);\n    }\n  }\n}"
      },
      "40": {
            "Function_name": "void RenderingEngine::renderPatchMode()",
            "Function_body": "void RenderingEngine::renderPatchMode(){\n  for (int x = 0; x < WORLD_WIDTH; x++){\n    for (int y = 0; y < WORLD_HEIGHT; y++){\n      auto& patch = myWorld->get_patch(x,y);\n      int patch_x = patch.getX() * GRID_SIZE;\n      int patch_y = patch.getY() * GRID_SIZE;\n      std::string color = patch.getModeColor();\n      int opacity = patch.getModeOpacity() * (255/3);\n      if (opacity > 255){opacity=255;}\n      // if (opacity>0){std::cout<<opacity<<std::endl;}\n      // std::cout<<'opacity '<<opacity<<std::endl;\n      // \n      // float opacity_scaling_value = (opacity - 0.001) / (3-0.001);\n      // if (opacity_scaling_value>1){opacity_scaling_value=1;}\n      // if (opacity_scaling_value<0){opacity_scaling_value=0;}\n      // opacity = opacity / (3/2);\n      // opacity = opacity_scaling_value * 255;\n      drawSquare(patch_x,patch_y,GRID_SIZE, color, opacity);\n    }\n  }\n}"
      },
      "41": {
            "Function_name": "void RenderingEngine::renderAllTurtles()",
            "Function_body": "void RenderingEngine::renderAllTurtles(){\n  int x, y;\n  for (auto& agent : myWorld->all_turtles){\n    x = agent.lock()->getX() * GRID_SIZE;\n    y = agent.lock()->getY() * GRID_SIZE;\n    std::string color = agent.lock()->getColor();\n    int opacity = agent.lock()->getOpacity();\n    std::string shape = agent.lock()->getShape();\n    if (shape=='square'){\n      drawSquare(x,y,(GRID_SIZE-1) * agent.lock()->getSize(), color, opacity);\n    }else if(shape=='target'){\n      drawSquare(x,y,(GRID_SIZE-1) * agent.lock()->getSize(), color, opacity);\n      drawCircle(x-1,y-1,(((GRID_SIZE/2)*agent.lock()->getSize())-2), 'black', opacity);\n    }else if (shape=='bug'){\n      // going to be an elipse with two little antennae on the front \n      int angle = agent.lock()->getHeading();\n      \n      drawFilledEllipse(x,y, (GRID_SIZE-1) * agent.lock()->getSize()/2, (GRID_SIZE-1) * agent.lock()->getSize()/4, color, opacity, angle);\n      drawLine(x,y, x+cos(angle*M_PI/180)*GRID_SIZE* agent.lock()->getSize(), y - sin(angle*M_PI/180)*GRID_SIZE* agent.lock()->getSize(), color, opacity);\n      // bounding rect\n      // SDL_Rect ellipseRect = \n      \n      // for (int x_draw=-1 * agent.lock()->getSize()*GRID_SIZE; x_draw <= agent.lock()->getSize()*GRID_SIZE; x_draw++){\n      //   for (int y_draw=-1 * agent.lock()->getSize()*GRID_SIZE; y_draw <= agent.lock()->getSize()*GRID_SIZE; y_draw++){\n      //     if (x_draw < ){\n      // \n      //     };\n      // \n      //   }\n      // }\n      \n      \n      // float x_offset = sin(angle) * (GRID_SIZE/2);\n      // float y_offset = cos(angle) * (GRID_SIZE/2);\n      // \n      // drawSquare(x,y,(GRID_SIZE-2) * agent.lock()->getSize(), color, opacity);\n      // drawCircle(x + x_offset,y + y_offset,(((GRID_SIZE/2)*agent.lock()->getSize())-2), color, opacity);\n\n    }else{\n      drawCircle(x,y,((GRID_SIZE/2)), color, opacity);\n\n    }\n  }\n}\n"
      },
      "42": {
            "Function_name": "void World::auto_inoculate(int numBac) ",
            "Function_body": "void World::auto_inoculate(int numBac) {\n\n    int numPhagocytosedBac = std::min(static_cast<int>(round(numBac * 0.8)), 100);\n    int numFreeBac = numBac - numPhagocytosedBac;\n\n    // Simulating the 'ask up-to-n-of num-phagocytosed-bac fdcs'\n    // Let's say all_fdcs is your list of FDCs\n    for (int i = 0; i < std::min(numPhagocytosedBac, static_cast<int>(all_fdcs.size())); i++) {\n        int random_FDC_index = RNG_Engine() % all_fdcs.size();\n        all_fdcs[random_FDC_index]->setResponsiveness(std::min(all_fdcs[random_FDC_index]->getResponsiveness() + 50, 100));\n        all_fdcs[random_FDC_index]->setTimePresenting(0);\n        all_fdcs[random_FDC_index]->setPresentedAntigen(BACTERIA_EPITOPE_TYPE);\n        all_fdcs[random_FDC_index]->setColor('red');  // Assuming you have some way to represent color in your FDC class\n\n        int rTI = RNG_Engine() % NUMBER_OF_TI_EPITOPES;\n        int rTD = RNG_Engine() % NUMBER_OF_TD_EPITOPES;\n\n        if (rTI > rTD) {\n            all_fdcs[random_FDC_index]->setPresentedAntigenType(1); // 1 is TI\n        } else {\n            all_fdcs[random_FDC_index]->setPresentedAntigenType(2); // 2 is TD\n        }\n    }\n\n    // Now simulating the 'create-bacteria num-free-bac'\n    std::cout<<'IN AUTOINOCULATE, ADDING NEW BACTERIA. TOTAL ADDED IS '<<numFreeBac<<std::endl;\n    for (int i = 0; i < numFreeBac; i++) {\n        std::shared_ptr<Bacteria> new_bacteria = std::make_shared<Bacteria>(WORLD_WIDTH-1, std::ceil(WORLD_HEIGHT/2), global_ID_counter++);\n\n        new_bacteria->setColor('red');\n        new_bacteria->setShape('bug');\n        new_bacteria->setSize(BACTERIA_SIZE);\n        new_bacteria->setTimeAlive(0);\n        new_bacteria->setInBlood(false);\n        new_bacteria->setEpitopeType(BACTERIA_EPITOPE_TYPE);\n        new_bacteria->setNumTIep(NUMBER_OF_TI_EPITOPES);\n        new_bacteria->setNumTDep(NUMBER_OF_TD_EPITOPES);\n\n        new_bacteria->setS1pr1Level(0);\n        new_bacteria->setS1pr2Level(0);\n        new_bacteria->setCxcr5Level(0);\n        new_bacteria->setCcr7Level(0);\n        new_bacteria->setEbi2rLevel(0);\n\n        std::weak_ptr<Turtle> new_bacteria_weak_ptr = new_bacteria;\n        all_bacterias.push_back(new_bacteria);  // Assuming you have a list named all_bacteria\n        all_turtles.push_back(new_bacteria_weak_ptr);\n        get_patch(new_bacteria->getX(), new_bacteria->getY()).add_turtle(new_bacteria);\n    }\n}"
      },
      "43": {
            "Function_name": "void World::check_overall_cd21_expression() ",
            "Function_body": "void World::check_overall_cd21_expression() {\n    if (step % 20 == 0) {   // Only calculating avg CD21 expression every 20 ticks to increase run speed\n        double total_cd21_expression = 0;\n\n        for (const auto& cell : all_naive_b_cells) {\n            total_cd21_expression += cell->getCd21Level();\n        }\n\n        for (const auto& cell : all_mem_b_cells) {\n            total_cd21_expression += cell->getCd21Level();\n        }\n\n        int total_cell_count = all_naive_b_cells.size() + all_mem_b_cells.size();\n\n        if (total_cell_count != 0) {\n            average_cd21_expression = total_cd21_expression / total_cell_count;\n        } else {\n            average_cd21_expression = 0;\n        }\n    }\n}"
      },
      "44": {
            "Function_name": "void World::calculateIncomingTNFaIL6Level() ",
            "Function_body": "void World::calculateIncomingTNFaIL6Level() {\n    for (auto& patchRow : all_patches) {\n      for (auto& patch : patchRow){\n        patch.setTnfA(patch.getTnfA() + (countCells<Bacteria>(patch.getX(), patch.getY()) / 500.0));\n\n        patch.setIl6(patch.getIl6() + (countCells<Bacteria>(patch.getX(), patch.getY()) / 500.0));\n      }\n    }\n}"
      },
      "45": {
            "Function_name": "void World::simulateBackgroundInflammation() ",
            "Function_body": "void World::simulateBackgroundInflammation() {\n    for (auto& patchRow : all_patches) {\n      for (auto& patch : patchRow){\n        patch.setTnfA(patch.getTnfA() + BACKGROUND_TNFA);\n        patch.setIl6(patch.getIl6() + BACKGROUND_IL6);\n      }\n    }\n}\n"
      },
      "46": {
            "Function_name": "void World::spawnTh0Cell() ",
            "Function_body": "void World::spawnTh0Cell() {\n    if(step % 20 == 0) {\n      std::cout<<'SPAWNING TH0 CELL'<<std::endl;\n\n        // Position of the new Th0-cell\n        int cell_x, cell_y;\n\n        // Keep generating random coordinates until we find a patch of type 1\n        do {\n            cell_x = RNG_Engine() % WORLD_WIDTH;\n            cell_y = RNG_Engine() % WORLD_HEIGHT;\n        } while(get_patch(cell_x, cell_y).getPatchType() != 1);\n\n        // Increase global ID counter\n        global_ID_counter++;\n        // Create a new Th0-cell\n        auto th0_cell = std::make_shared<Th0Cell>(cell_x, cell_y, global_ID_counter);\n        std::weak_ptr<Turtle> th0_cell_weak_ptr = th0_cell;\n\n        // Set the properties of the new Th0-cell\n        th0_cell->setShape('square');\n        th0_cell->setColor('yellow');\n        th0_cell->setTimeAlive(0);\n        th0_cell->setS1pr1Level(0);\n        th0_cell->setS1pr2Level(0);\n        th0_cell->setCxcr5Level(0);\n        th0_cell->setCcr7Level(6);\n        th0_cell->setEbi2rLevel(6);\n        th0_cell->setInBlood(false);\n\n        // Add the new Th0-cell to the list of all Th0-cells\n        all_th0_cells.push_back(th0_cell);\n\n        // Also add it to the list of all Turtles\n        all_turtles.push_back(th0_cell_weak_ptr);\n\n        get_patch(th0_cell->getX(), th0_cell->getY()).add_turtle(th0_cell);\n\n    }\n}\n"
      },
      "47": {
            "Function_name": "std::shared_ptr<Antibodies> World::getOneAntibodyHere(int patchX, int patchY) ",
            "Function_body": "std::shared_ptr<Antibodies> World::getOneAntibodyHere(int patchX, int patchY) {\n    // Create a vector to store antibodies on the specified patch\n    std::vector<std::shared_ptr<Antibodies>> antibodiesOnPatch;\n    Patch& current_patch = get_patch(patchX, patchY);\n    std::vector<std::shared_ptr<Turtle>> turtles_on_patch = current_patch.getTurtlesHere();\n    // Find antibodies on the patch\n    for (const auto& turtle : turtles_on_patch) {\n      if (std::shared_ptr<Antibodies> antibody = std::dynamic_pointer_cast<Antibodies>(turtle)) {\n        // The turtle is a NaiveBCell, add it to the corresponding vector\n        antibodiesOnPatch.push_back(antibody);\n      }\n    }\n    // Check if any antibodies are found on the patch\n    if (antibodiesOnPatch.empty()) {\n        return nullptr; // Return nullptr if no antibodies found on the patch\n    }\n    // Generate a random index to pick a random antibody from the antibodiesOnPatch vector\n    int randomIndex = RNG_Engine() % antibodiesOnPatch.size();\n\n    // Return the randomly selected antibody\n    return antibodiesOnPatch[randomIndex];\n}\n"
      },
      "48": {
            "Function_name": "std::shared_ptr<FDCs> World::getOneFDCHere(int patchX, int patchY)",
            "Function_body": "std::shared_ptr<FDCs> World::getOneFDCHere(int patchX, int patchY){\n    // Create a vector to store antibodies on the specified patch\n    std::vector<std::shared_ptr<FDCs>> FDCsOnPatch;\n    Patch& current_patch = get_patch(patchX, patchY);\n    std::vector<std::shared_ptr<Turtle>> turtles_on_patch = current_patch.getTurtlesHere();\n    // Find antibodies on the patch\n    for (const auto& turtle : turtles_on_patch) {\n      if (std::shared_ptr<FDCs> fdc = std::dynamic_pointer_cast<FDCs>(turtle)) {\n        // The turtle is a NaiveBCell, add it to the corresponding vector\n        FDCsOnPatch.push_back(fdc);\n      }\n    }\n    // Check if any antibodies are found on the patch\n    if (FDCsOnPatch.empty()) {\n        return nullptr; // Return nullptr if no antibodies found on the patch\n    }\n    // Generate a random index to pick a random antibody from the antibodiesOnPatch vector\n    int randomIndex = RNG_Engine() % FDCsOnPatch.size();\n\n    // Return the randomly selected antibody\n    return FDCsOnPatch[randomIndex];\n}\n"
      },
      "49": {
            "Function_name": "\nstd::shared_ptr<Bacteria> World::getOneBacteriaHere(int patchX, int patchY)",
            "Function_body": "\nstd::shared_ptr<Bacteria> World::getOneBacteriaHere(int patchX, int patchY){\n    // Create a vector to store antibodies on the specified patch\n    std::vector<std::shared_ptr<Bacteria>> bacteriaOnPatch;\n    for (float x =-BACTERIA_SIZE/2; x <= BACTERIA_SIZE/2; x++){\n      for (float y =-BACTERIA_SIZE/2; y <= BACTERIA_SIZE/2; y++){\n        float x_to_get, y_to_get;\n        if (!TOROIDAL_WORLD) {\n          x_to_get = std::min(patchX+x,(float)WORLD_WIDTH-1);\n          x_to_get = std::max(x_to_get,(float)0);\n          y_to_get = std::min(patchY+y,(float)WORLD_HEIGHT-1);\n          y_to_get = std::min(y_to_get,(float)0);\n        } else {\n          x_to_get = fmod(patchX+x,WORLD_WIDTH);\n          y_to_get = fmod(patchY+y,WORLD_HEIGHT);\n        }\n\n        Patch& current_patch = get_patch(x_to_get, y_to_get);\n        std::vector<std::shared_ptr<Turtle>> turtles_on_patch = current_patch.getTurtlesHere();\n        // Find antibodies on the patch\n        for (const auto& turtle : turtles_on_patch) {\n          if (std::shared_ptr<Bacteria> bacteria = std::dynamic_pointer_cast<Bacteria>(turtle)) {\n            // The turtle is a bacteria, add it to the corresponding vector\n            // std::cout<<'FOUND BACTERIA ON PATCH'<<std::endl;\n            bacteriaOnPatch.push_back(bacteria);\n          }\n        }\n      }\n    }\n\n    // Check if any antibodies are found on the patch\n    if (bacteriaOnPatch.empty()) {\n        return nullptr; // Return nullptr if no antibodies found on the patch\n    }\n    // Generate a random index to pick a random Bacteria from the antibodiesOnPatch vector\n    int randomIndex = RNG_Engine() % bacteriaOnPatch.size();\n\n    // Return the randomly selected Bacteria\n    return bacteriaOnPatch[randomIndex];\n}"
      },
      "50": {
            "Function_name": "std::shared_ptr<Th2Cell> World::getOneTh2Here(int patchX, int patchY)",
            "Function_body": "std::shared_ptr<Th2Cell> World::getOneTh2Here(int patchX, int patchY){\n    std::vector<std::shared_ptr<Th2Cell>> Th2CellsOnPatch;\n    Patch& current_patch = get_patch(patchX, patchY);\n    std::vector<std::shared_ptr<Turtle>> turtles_on_patch = current_patch.getTurtlesHere();\n    for (const auto& turtle : turtles_on_patch) {\n      if (std::shared_ptr<Th2Cell> th2 = std::dynamic_pointer_cast<Th2Cell>(turtle)) {\n        Th2CellsOnPatch.push_back(th2);\n      }\n    }\n    if (Th2CellsOnPatch.empty()) {\n        return nullptr;\n    }\n    int randomIndex = RNG_Engine() % Th2CellsOnPatch.size();\n    return Th2CellsOnPatch[randomIndex];\n}"
      },
      "51": {
            "Function_name": "std::shared_ptr<TfhCell> World::getOneTfhHere(int patchX, int patchY)",
            "Function_body": "std::shared_ptr<TfhCell> World::getOneTfhHere(int patchX, int patchY){\n    std::vector<std::shared_ptr<TfhCell>> TfhCellsOnPatch;\n    Patch& current_patch = get_patch(patchX, patchY);\n    std::vector<std::shared_ptr<Turtle>> turtles_on_patch = current_patch.getTurtlesHere();\n    for (const auto& turtle : turtles_on_patch) {\n      if (std::shared_ptr<TfhCell> tfh = std::dynamic_pointer_cast<TfhCell>(turtle)) {\n        TfhCellsOnPatch.push_back(tfh);\n      }\n    }\n    if (TfhCellsOnPatch.empty()) {\n        return nullptr;\n    }\n    int randomIndex = RNG_Engine() % TfhCellsOnPatch.size();\n    return TfhCellsOnPatch[randomIndex];\n}"
      },
      "52": {
            "Function_name": "std::shared_ptr<ActivatedBCell> World::getOneActivatedBCellHere(int patchX, int patchY)",
            "Function_body": "std::shared_ptr<ActivatedBCell> World::getOneActivatedBCellHere(int patchX, int patchY){\n    std::vector<std::shared_ptr<ActivatedBCell>> ActivatedBCellsOnPatch;\n    Patch& current_patch = get_patch(patchX, patchY);\n    std::vector<std::shared_ptr<Turtle>> turtles_on_patch = current_patch.getTurtlesHere();\n    for (const auto& turtle : turtles_on_patch) {\n      if (std::shared_ptr<ActivatedBCell> activated_b_cell = std::dynamic_pointer_cast<ActivatedBCell>(turtle)) {\n        ActivatedBCellsOnPatch.push_back(activated_b_cell);\n      }\n    }\n    if (ActivatedBCellsOnPatch.empty()) {\n        return nullptr;\n    }\n    int randomIndex = RNG_Engine() % ActivatedBCellsOnPatch.size();\n    return ActivatedBCellsOnPatch[randomIndex];\n}\n"
      },
      "53": {
            "Function_name": "std::vector<std::shared_ptr<FDCs>> World::get_fdcs_with_no_presented_antigen()",
            "Function_body": "std::vector<std::shared_ptr<FDCs>> World::get_fdcs_with_no_presented_antigen(){\n  std::vector<std::shared_ptr<FDCs>> FDCs_with_no_anitigen;\n  for (auto fdc : all_fdcs){\n    if (fdc->getPresentedAntigen() ==0) {\n      FDCs_with_no_anitigen.push_back(fdc);\n    }\n  }\n  return FDCs_with_no_anitigen;\n}\n"
      },
      "54": {
            "Function_name": "SLPlasmaCell::SLPlasmaCell(int x, int y, int id, int heading) : Turtle(x, y, id, heading) ",
            "Function_body": "SLPlasmaCell::SLPlasmaCell(int x, int y, int id, int heading) : Turtle(x, y, id, heading) {\n    // Constructor\n    // std::cout<<'creating SL plasma cell with ID '<<id<<std::endl;\n\n}"
      },
      "55": {
            "Function_name": "void World::sl_plasma_cell_function(std::shared_ptr<SLPlasmaCell> sl_plasma_cell) ",
            "Function_body": "void World::sl_plasma_cell_function(std::shared_ptr<SLPlasmaCell> sl_plasma_cell) {\n  if (!sl_plasma_cell->get_is_alive()) {return;}\n  bool print_test = false;\n  Patch& current_patch = get_patch(sl_plasma_cell->getX(), sl_plasma_cell->getY());\n  if (print_test){std::cout<<'doing SL plasma function for '<<sl_plasma_cell->getID()<<std::endl;}\n    if(!sl_plasma_cell->getInBlood()) {\n      if (print_test){std::cout<<'doing SL plasma cause not in blood at '<<sl_plasma_cell->getX()<<', '<<sl_plasma_cell->getY()<<std::endl;}\n\n        if(current_patch.getPatchType() == 2) {\n            sl_plasma_cell->setInBlood(true);\n            sl_plasma_cell->setVisible(false);\n            if(print_test){std::cout<<'killing Sl_plasma cell at follicle exit'<<std::endl;}\n            return;\n        }\n\n        // Assuming you have a check_breg_status function\n        bool turn_into_breg = checkBregStatus(sl_plasma_cell);\n        if (turn_into_breg){\n          if (print_test){std::cout<<'sl_plasma ID '<<sl_plasma_cell->getID()<<'turning into Breg'<<std::endl;}\n          std::shared_ptr<BregCell> sl_plasma_cell = turnIntoBreg(sl_plasma_cell);\n        };\n\n        chemotaxis(sl_plasma_cell);\n        if (print_test){std::cout<<'moving SL_plasma_cell with use count '<<sl_plasma_cell.use_count()<<std::endl;}\n\n        move_turtle(sl_plasma_cell);\n        //std::cout<<'moved SL_plasma_cell with use count '<<sl_plasma_cell.use_count()<<std::endl;\n    }\n\n    if(sl_plasma_cell->getTimeAlive() % 50 == 0) {\n        auto antibody = std::make_shared<Antibodies>(sl_plasma_cell->getX(), sl_plasma_cell->getY(), global_ID_counter++, sl_plasma_cell->getHeading());\n        antibody->copy_other_turtle_attributes(sl_plasma_cell);\n        antibody->setTimeAlive(0);\n        antibody->setAntibodyType(sl_plasma_cell->getIsotype());\n        antibody->setVisible(false);\n        antibody->setColor('mauve');\n        \n        std::weak_ptr<Turtle> antibody_weak_ptr = antibody;\n        all_turtles.push_back(antibody_weak_ptr);\n        all_antibodies.push_back(antibody);\n        get_patch(antibody->getX(), antibody->getY()).add_turtle(antibody);\n    }\n\n    // Checks level of TNF-a stimulation for apoptosis\n    bool die_by_tnf = checkTNFStatus(sl_plasma_cell);\n\n    sl_plasma_cell->setTimeAlive(sl_plasma_cell->getTimeAlive() + 1);\n    if((sl_plasma_cell->getTimeAlive() > 240 + (current_patch.getIl6() + current_patch.getIl21()) * 10) || die_by_tnf) {\n        kill(sl_plasma_cell);\n    }\n}\n"
      },
      "56": {
            "Function_name": "TfhCell::TfhCell(int x, int y, int id, int heading) : Turtle(x, y, id, heading) ",
            "Function_body": "TfhCell::TfhCell(int x, int y, int id, int heading) : Turtle(x, y, id, heading) {\n    // Constructor\n    // std::cout<<'creating TFH cell ID '<<id<<std::endl;\n\n}"
      },
      "57": {
            "Function_name": "void World::tfhCellFunction(std::shared_ptr<TfhCell> tfh_cell) ",
            "Function_body": "void World::tfhCellFunction(std::shared_ptr<TfhCell> tfh_cell) {\n  if (!tfh_cell->get_is_alive()) {return;}\n  bool print_test = false;\n  if (print_test){std::cout<<'TfH function for ID '<<tfh_cell->getID()<<std::endl;}\n\n    Patch& current_patch = get_patch(tfh_cell->getX(), tfh_cell->getY());\n\n    if (calculateDistance(WORLD_WIDTH / 2, WORLD_HEIGHT / 2, tfh_cell->getX(), tfh_cell->getY()) > 20 || !tfh_cell->getBcellBindingStatus()) {\n      // std::cout<<'chemotaxin TfH with distance to center equal to '<<calculateDistance(WORLD_WIDTH / 2, WORLD_HEIGHT / 2, tfh_cell->getX(), tfh_cell->getY())<<std::endl;\n\n        chemotaxis(tfh_cell);\n        // std::cout<<'Moving tfh'<<std::endl;\n\n        move_turtle(tfh_cell);\n    }\n\n    // Secretes the following cytokines\n    current_patch.setIl21(current_patch.getIl21() + 1);\n    current_patch.setIl4(current_patch.getIl4() + 1);\n    current_patch.setIl2(current_patch.getIl2() + 1);\n    current_patch.setIl10(current_patch.getIl10() + 1);\n\n    tfh_cell->setTimeAlive(tfh_cell->getTimeAlive() + 1);\n\n    // Uncomment the following lines if you want the Tfh cells to die after being alive for more than 500 time steps.\n    //if (tfh_cell->getTimeAlive() > 500) {\n    //    kill(tfh_cell);\n    //}\n}"
      },
      "58": {
            "Function_name": "Th0Cell::Th0Cell(int x, int y, int id, int heading) : Turtle(x, y, id, heading) ",
            "Function_body": "Th0Cell::Th0Cell(int x, int y, int id, int heading) : Turtle(x, y, id, heading) {\n    // Constructor\n    // std::cout<<'creating TH 0 cell with ID '<<id<<std::endl;\n\n}"
      },
      "59": {
            "Function_name": "void World::th0CellFunction(std::shared_ptr<Th0Cell> th0_cell) ",
            "Function_body": "void World::th0CellFunction(std::shared_ptr<Th0Cell> th0_cell) {\n  if (!th0_cell->get_is_alive()) {return;}\n\n  std::cout<<'TH 0 function'<<std::endl;\n    // Get the current patch of the Th0 cell\n    Patch& current_patch = get_patch(th0_cell->getX(), th0_cell->getY());\n\n    double pro_TH1 = (current_patch.getIl12() + current_patch.getIfG()) * 100;\n    double pro_TH2 = (current_patch.getIl10() + current_patch.getIl4()) * 100;\n    double pro_TFH = (current_patch.getIl21() + current_patch.getIl12()) * 100;\n\n    double rTH1 = fmod((double)RNG_Engine(), pro_TH1);\n    double rTH2 = fmod((double)RNG_Engine(), pro_TH2);\n    double rTFH = fmod((double)RNG_Engine(), pro_TFH);\n\n    th0_cell->setR1(rTH1);\n    th0_cell->setR2(rTH2);\n    th0_cell->setRf(rTFH);\n\n    if (rTH1 > rTH2 && rTH1 > rTFH) {\n        th0_cell->setTh1Activation(th0_cell->getTh1Activation() + 1);\n    }\n    if (rTH2 > rTH1 && rTH2 > rTFH) {\n        th0_cell->setTh2Activation(th0_cell->getTh2Activation() + 1);\n    }\n    if (rTFH > rTH1 && rTFH > rTH2) {\n        th0_cell->setTfhActivation(th0_cell->getTfhActivation() + 1);\n    }\n\n    if (th0_cell->getTh1Activation() >= 20) {\n        auto th1_cell = std::make_shared<Th1Cell>(th0_cell->getX(), th0_cell->getY(), global_ID_counter++, th0_cell->getHeading());\n        th1_cell->copy_other_turtle_attributes(th0_cell);\n        th1_cell->setColor('blue');\n        th1_cell->setTimeAlive(0);\n        th1_cell->setSize(1);\n        th1_cell->setShape('circle');\n\n        std::weak_ptr<Turtle> th1_cell_weak_ptr = th1_cell;\n        all_turtles.push_back(th1_cell_weak_ptr);\n        all_th1_cells.push_back(th1_cell);\n        current_patch.add_turtle(th1_cell);\n\n        kill(th0_cell);\n        std::shared_ptr<Th1Cell> th0_cell = th1_cell;\n    } else if (th0_cell->getTh2Activation() >= 20) {\n        auto th2_cell = std::make_shared<Th2Cell>(th0_cell->getX(), th0_cell->getY(), global_ID_counter++, th0_cell->getHeading());\n        th2_cell->copy_other_turtle_attributes(th0_cell);\n        th2_cell->setColor('blue');\n        th2_cell->setTimeAlive(0);\n        th2_cell->setSize(1);\n        th2_cell->setShape('circle');\n        th2_cell->setBcellBindingStatus(false);\n\n        std::weak_ptr<Turtle> th2_cell_weak_ptr = th2_cell;\n        all_turtles.push_back(th2_cell_weak_ptr);\n        all_th2_cells.push_back(th2_cell);\n        current_patch.add_turtle(th2_cell);\n\n        kill(th0_cell);\n        std::shared_ptr<Th2Cell> th0_cell = th2_cell;\n\n    } else if (th0_cell->getTfhActivation() >= 20) {\n        auto tfh_cell = std::make_shared<TfhCell>(th0_cell->getX(), th0_cell->getY(), global_ID_counter++, th0_cell->getHeading());\n        global_ID_counter++;\n        tfh_cell->copy_other_turtle_attributes(th0_cell);\n        tfh_cell->setCxcr5Level(10);\n        tfh_cell->setColor('cyan');\n        tfh_cell->setShape('circle');\n        tfh_cell->setSize(1);\n        tfh_cell->setTimeAlive(0);\n        tfh_cell->setBcellBindingStatus(false);\n\n        std::weak_ptr<Turtle> tfh_cell_weak_ptr = tfh_cell;\n        all_turtles.push_back(tfh_cell_weak_ptr);\n        all_tfh_cells.push_back(tfh_cell);\n        current_patch.add_turtle(tfh_cell);\n\n        kill(th0_cell);\n        std::shared_ptr<TfhCell> th0_cell = tfh_cell;\n\n    }\n    std::cout<<'chemotaxin from TH0 '<<std::endl;\n    chemotaxis(th0_cell);\n    // std::cout<<'Moving th0'<<std::endl;\n\n    move_turtle(th0_cell);\n\n    th0_cell->setTimeAlive(th0_cell->getTimeAlive() + 1);\n    if (th0_cell->getTimeAlive() > 300) {\n      std::cout <<'killing th0 cell '<<th0_cell->getID()<<std::endl;\n        kill(th0_cell);\n    }\n}\n"
      },
      "60": {
            "Function_name": "Th1Cell::Th1Cell(int x, int y, int id, int heading) : Turtle(x, y, id, heading) ",
            "Function_body": "Th1Cell::Th1Cell(int x, int y, int id, int heading) : Turtle(x, y, id, heading) {\n    // Constructor\n    // std::cout<<'creating TH 1 cell with ID '<<id<<std::endl;\n\n}"
      },
      "61": {
            "Function_name": "void World::th1CellFunction(std::shared_ptr<Th1Cell> th1_cell) ",
            "Function_body": "void World::th1CellFunction(std::shared_ptr<Th1Cell> th1_cell) {\n  if (!th1_cell->get_is_alive()) {return;}\n    bool print_test = false;\n    if (print_test){std::cout<<'TH1 function for '<<th1_cell->getID()<<std::endl;}\n    Patch& current_patch = get_patch(th1_cell->getX(), th1_cell->getY());\n\n    chemotaxis(th1_cell);\n    // std::cout<<'Moving th1'<<std::endl;\n\n    move_turtle(th1_cell);\n\n    // Secretes the following cytokines\n    current_patch.setIfG(current_patch.getIfG() + 1);\n\n    th1_cell->setTimeAlive(th1_cell->getTimeAlive() + 1);\n\n    // Uncomment the following lines if you want the Th1 cells to die after being alive for more than 500 time steps.\n    //if (th1_cell->getTimeAlive() > 500) {\n    //    kill(th1_cell);\n    //}\n}\n"
      },
      "62": {
            "Function_name": "Th2Cell::Th2Cell(int x, int y, int id, int heading) : Turtle(x, y, id, heading) ",
            "Function_body": "Th2Cell::Th2Cell(int x, int y, int id, int heading) : Turtle(x, y, id, heading) {\n    // Constructor\n    // std::cout<<'creating TH 2 cell ID '<<id<<std::endl;\n\n}"
      },
      "63": {
            "Function_name": "void World::th2CellFunction(std::shared_ptr<Th2Cell> th2_cell) ",
            "Function_body": "void World::th2CellFunction(std::shared_ptr<Th2Cell> th2_cell) {\n  if (!th2_cell->get_is_alive()) {return;}\n  bool print_test = false;\n  if (print_test){std::cout<<'TH2 function for '<<th2_cell->getID()<<std::endl;}\n\n    Patch& current_patch = get_patch(th2_cell->getX(), th2_cell->getY());\n\n    // Calculate the Euclidean distance between the cell's location and the center of the world (WORLD_WIDTH/2, WORLD_HEIGHT/2)\n    if (calculateDistance(WORLD_WIDTH/2, WORLD_HEIGHT/2, th2_cell->getX(), th2_cell->getY()) > 20 || !th2_cell->getBcellBindingStatus()) {\n        chemotaxis(th2_cell);\n        // std::cout<<'Moving th2'<<std::endl;\n\n        move_turtle(th2_cell);\n    }\n\n    // Secretes the following cytokines\n    current_patch.setIl4(current_patch.getIl4() + 1);\n    current_patch.setIl10(current_patch.getIl10() + 1);\n\n    th2_cell->setTimeAlive(th2_cell->getTimeAlive() + 1);\n\n    // Uncomment the following lines if you want the Th2 cells to die after being alive for more than 500 time steps.\n    //if (th2_cell->getTimeAlive() > 500) {\n    //    kill(th2_cell);\n    //}\n}\n"
      },
      "64": {
            "Function_name": "void Turtle::addLinkedTurtle(std::weak_ptr<Turtle> linkedTurtle) ",
            "Function_body": "void Turtle::addLinkedTurtle(std::weak_ptr<Turtle> linkedTurtle) {\n    linkedTurtles.push_back(linkedTurtle);\n    std::shared_ptr<Turtle> temp_shared_ptr = std::dynamic_pointer_cast<Turtle>(shared_from_this());\n    std::weak_ptr<Turtle> weak_ptr = temp_shared_ptr;\n    linkedTurtle.lock()->getLinkedTurtles().push_back(weak_ptr);\n    temp_shared_ptr.reset();\n}\n"
      },
      "65": {
            "Function_name": "std::vector<std::weak_ptr<Turtle>>& Turtle::getLinkedTurtles() ",
            "Function_body": "std::vector<std::weak_ptr<Turtle>>& Turtle::getLinkedTurtles() {\n    return linkedTurtles;\n}\n"
      },
      "66": {
            "Function_name": "void Turtle::removeLinkedTurtle()",
            "Function_body": "void Turtle::removeLinkedTurtle(){\n  for(auto neighbor : this->getLinkedTurtles()){\n    auto iter = std::find_if(neighbor.lock()->getLinkedTurtles().begin(), neighbor.lock()->getLinkedTurtles().end(), WeakPtrComparator<Turtle>(ID_num));  // finding where current ID_num of this turtle is in the nieghbors list of links\n    if (iter != neighbor.lock()->getLinkedTurtles().end()) {\n         neighbor.lock()->getLinkedTurtles().erase(iter);\n     } else {\n         std::cout << 'Linked turtle not found in the neighbors vector. 1 ERRORRRR' << std::endl;\n     }\n\n     iter = std::find_if(this->getLinkedTurtles().begin(), this->getLinkedTurtles().end(), WeakPtrComparator<Turtle>(neighbor.lock()->getID()));\n     if (iter != this->getLinkedTurtles().end()) {\n          this->getLinkedTurtles().erase(iter);\n      } else {\n          std::cout << 'Neighbor Linked turtle not found in the vector. 2 ERRORRRR' << std::endl;\n      }\n  }\n  linkedTurtles.clear();\n}\n\n"
      },
      "67": {
            "Function_name": "std::pair<double,double> Turtle::move(float distance) ",
            "Function_body": "std::pair<double,double> Turtle::move(float distance) {\n  // this function moves the turtle internally and is called inside World::move_turtle(), so should only really be accessed from there.\n\n  // default val for distance=1\n  // calculates the movement for the turtle based on its heading and distance to move and returns the coordinates of the destination patch\n    temp_x = x_dec;   //placeholders in case we are not able to actually execute the move. In that case, these will reset x/y decimal values\n    temp_y = y_dec;\n    double d_x = cos(heading * M_PI/180) * distance;   // converting degrees to radians and getting delta x and delta y\n    double d_y = -1 * sin(heading * M_PI/180) * distance;\n    if (!TURTLE_CONTINOUS_MOVEMENT) {   //ie discrete movement, turtles always land on the middle of patches\n      d_x = round(d_x);\n      d_y = round(d_y);\n    }\n    x_dec += d_x;\n    y_dec += d_y;\n    if (TOROIDAL_WORLD){\n      x_dec = fmod(fmod(x_dec, WORLD_WIDTH) +WORLD_WIDTH, WORLD_WIDTH);              // wrapping around world with modulo\n      y_dec = fmod(fmod(y_dec, WORLD_HEIGHT) +WORLD_HEIGHT, WORLD_HEIGHT);           // taking double mod to make sure that a positive number for grid coordinates\n    } else{\n      if (x_dec >= WORLD_WIDTH){x_dec = WORLD_WIDTH-1;}\n      if (y_dec >= WORLD_HEIGHT){y_dec = WORLD_HEIGHT-1;}\n      if (x_dec < 0){x_dec = 0;}\n      if (y_dec < 0){y_dec = 0;}\n    }\n    return std::make_pair(x_dec, y_dec);\n}"
      },
      "68": {
            "Function_name": "void Turtle::execute_move(bool didMove)",
            "Function_body": "void Turtle::execute_move(bool didMove){\n  // if we execute the move, then the world has moved the turtle to a new patch, and we need to update internal variables\n  if(didMove){\n    setX(trunc(x_dec));                             // truncating decimal coords to get int coords\n    setY(trunc(y_dec));\n    temp_x = x_dec;\n    temp_y = y_dec;\n  } else{\n    x_dec = temp_x;\n    y_dec = temp_y;\n  }\n}"
      },
      "69": {
            "Function_name": "std::pair<int,int> Turtle::jumpRandom(std::mt19937 &RNG_Engine) ",
            "Function_body": "std::pair<int,int> Turtle::jumpRandom(std::mt19937 &RNG_Engine) {\n  // get a random direction, then a random distance, then return the coordinates that we jumped to\n    int random_heading = RNG_Engine()%360;\n    int random_distance = RNG_Engine()%MAX_RANDOM_DISTANCE;\n\n    this->setHeading(random_heading);\n    return this->move(random_distance);\n}\n"
      },
      "70": {
            "Function_name": "void Turtle::wiggle(std::mt19937 &RNG_Engine)",
            "Function_body": "void Turtle::wiggle(std::mt19937 &RNG_Engine){\n  // randomly wiggle heading up to 45 degrees left up to 45 degrees right\n  int random_left = RNG_Engine()%45;\n  int random_right = RNG_Engine()%45;\n\n  // std::cout<<'WIGGLING TURTLE NOW. new heading is '<<this->getHeading() + random_left - random_right<<std::endl;\n  this->setHeading(this->getHeading() + (random_left - random_right));\n}\n"
      },
      "71": {
            "Function_name": "void Turtle::display() ",
            "Function_body": "void Turtle::display() {\n  std::cout << 'Turtle position: (' << this->getX() << ', ' << this->getY() << ')' << std::endl;\n  std::cout << 'Turtle exact position: (' << x_dec << ', ' << y_dec << ')' << std::endl;\n  std::cout << 'Turtle Heading: (' << heading << ')' << std::endl;\n  std::cout << 'Turtle ID: (' << ID_num << ')' << std::endl;\n}\n"
      },
      "72": {
            "Function_name": "void Turtle::copy_other_turtle_attributes(std::shared_ptr<Turtle> otherTurtle)",
            "Function_body": "void Turtle::copy_other_turtle_attributes(std::shared_ptr<Turtle> otherTurtle){\n  this->setHeading(otherTurtle->getHeading());\n  this->setTimeAlive(otherTurtle->getTimeAlive());\n  // Copying the additional attributes\n  // this->x_dec = otherTurtle->get_x_dec();\n  // this->y_dec = otherTurtle->get_y_dec();\n  // this->temp_x = otherTurtle->get_temp_x();\n  // this->temp_y = otherTurtle->get_temp_y();\n  this->setInBlood(otherTurtle->getInBlood());\n  this->setBcr(otherTurtle->getBcr());\n  this->setIsotype(otherTurtle->getIsotype());\n  this->setCsrBool(otherTurtle->getCsrBool());\n  this->setTnfaThreshold(otherTurtle->getTnfaThreshold());\n  this->setBregThreshold(otherTurtle->getBregThreshold());\n  this->setCd21Level(otherTurtle->getCd21Level());\n  this->setS1pr1Level(otherTurtle->getS1pr1Level());\n  this->setS1pr2Level(otherTurtle->getS1pr2Level());\n  this->setCxcr5Level(otherTurtle->getCxcr5Level());\n  this->setCcr7Level(otherTurtle->getCcr7Level());\n  this->setEbi2rLevel(otherTurtle->getEbi2rLevel());\n  this->setProBreg(otherTurtle->getProBreg());\n  this->setLevelOfActivation(otherTurtle->getLevelOfActivation());\n  this->setTnfaStimulation(otherTurtle->getTnfaStimulation());\n  this->setExposureNumber(otherTurtle->getExposureNumber());\n}\n"
      },
      "73": {
            "Function_name": "void World::add_patch(int x, int y)",
            "Function_body": "void World::add_patch(int x, int y){\n  all_patches[x][y] = Patch(x,y);\n}\n"
      },
      "74": {
            "Function_name": "Patch& World::get_patch(double x_arg, double y_arg)",
            "Function_body": "Patch& World::get_patch(double x_arg, double y_arg){\n  int x = trunc(x_arg);\n  int y = trunc(y_arg);\n  x = (x+WORLD_WIDTH)%WORLD_WIDTH;\n  y = (y+WORLD_HEIGHT)%WORLD_HEIGHT;\n  return all_patches[x][y];\n}\n"
      },
      "75": {
            "Function_name": "Patch& World::get_patch_ahead(std::shared_ptr<Turtle> turtle, float distance)",
            "Function_body": "Patch& World::get_patch_ahead(std::shared_ptr<Turtle> turtle, float distance){\n  // default value for distance=1\n  // get the patch in front of the turtle, based on its current heading\n  int heading = turtle->getHeading();\n  int current_x = turtle->getX();\n  int current_y = turtle->getY();\n\n  float d_x = cos(heading * M_PI/180) * distance;   // converting degrees to radians and getting delta x and delta y\n  float d_y = sin(heading * M_PI/180) * distance;\n\n  int ahead_x = round(current_x + d_x);\n  int ahead_y = round(current_y + d_y);\n\n  return get_patch(ahead_x, ahead_y);\n}\n"
      },
      "76": {
            "Function_name": "Patch& World::get_patch_ahead_right(std::shared_ptr<Turtle> turtle, float distance)",
            "Function_body": "Patch& World::get_patch_ahead_right(std::shared_ptr<Turtle> turtle, float distance){\n  // default value for distance=1\n  // get the patch in front and to the right of the turtle, based on its current heading\n  int heading = turtle->getHeading() - 45; // to look right 45 degrees\n  int current_x = turtle->getX();\n  int current_y = turtle->getY();\n\n  float d_x = cos(heading * M_PI/180) * distance;   // converting degrees to radians and getting delta x and delta y\n  float d_y = sin(heading * M_PI/180) * distance;\n\n  int ahead_x = round(current_x + d_x);\n  int ahead_y = round(current_y + d_y);\n\n  return get_patch(ahead_x, ahead_y);\n}\n"
      },
      "77": {
            "Function_name": "Patch& World::get_patch_ahead_left(std::shared_ptr<Turtle> turtle, float distance)",
            "Function_body": "Patch& World::get_patch_ahead_left(std::shared_ptr<Turtle> turtle, float distance){\n  // default value for distance=1\n  // get the patch in front and to the right of the turtle, based on its current heading\n  int heading = turtle->getHeading() + 45; // to look left 45 degrees\n  int current_x = turtle->getX();\n  int current_y = turtle->getY();\n\n  float d_x = cos(heading * M_PI/180) * distance;   // converting degrees to radians and getting delta x and delta y\n  float d_y = sin(heading * M_PI/180) * distance;\n\n  int ahead_x = round(current_x + d_x);\n  int ahead_y = round(current_y + d_y);\n\n  return get_patch(ahead_x, ahead_y);\n}\n"
      },
      "78": {
            "Function_name": "void World::setup_patches()",
            "Function_body": "void World::setup_patches(){\n  for(int x=0; x<WORLD_WIDTH; x++){\n    for(int y=0; y<WORLD_HEIGHT; y++){\n      add_patch(x,y);\n      // set initial values on patches here; eg patch.setOxy(100) to set patch oxy to initial value\n    }\n  }\n}\n"
      },
      "79": {
            "Function_name": "void World::display_patches()",
            "Function_body": "void World::display_patches(){\n  // prints details about all patches as well as any turtles associated with them to the console\n  for(auto &patchArr: all_patches){\n    for(auto &patch: patchArr){\n      patch.display();\n    }\n  }\n}\n"
      },
      "80": {
            "Function_name": "void World::add_turtle(int x, int y, int id, int heading)",
            "Function_body": "void World::add_turtle(int x, int y, int id, int heading){\n  // creates a new generic turtle and adds it to the patch, as well as the list of all turtles\n  std::shared_ptr<Turtle> new_turtle = std::make_shared<Turtle>(x, y, id, heading);\n  get_patch(x,y).add_turtle(new_turtle);\n  all_turtles.emplace_back(new_turtle);\n}\n"
      },
      "81": {
            "Function_name": "void World::place_turtle(double x, double y, std::shared_ptr<Turtle> turtle)",
            "Function_body": "void World::place_turtle(double x, double y, std::shared_ptr<Turtle> turtle){\n  // moves turtle from its original patch to a new patch\n  Patch& original_patch = get_patch(turtle->getX(), turtle->getY());\n  Patch& new_patch = get_patch(x, y);\n  turtle->setX(trunc(x));\n  turtle->setY(trunc(y));\n  turtle->set_x_dec(x);\n  turtle->set_y_dec(y);\n  turtle->set_temp_x(x);\n  turtle->set_temp_y(y);\n\n  original_patch.remove_turtle(turtle);\n  new_patch.add_turtle(turtle);\n}\n"
      },
      "82": {
            "Function_name": "void World::move_turtle(std::shared_ptr<Turtle> turtle, float distance)",
            "Function_body": "void World::move_turtle(std::shared_ptr<Turtle> turtle, float distance){\n  // moves the turtle but asking the turtle to calculate its movement, and if there is space on the target_patch, the world executes the move\n  // This is the way that turtls should really be moved in the simulation, because this is the highest level control and will move them on world, their patch, and internally\n\n  turtle->wiggle(RNG_Engine);\n\n\n  Patch &turtle_current_patch = get_patch(turtle->getX(), turtle->getY());\n  std::pair<double,double> new_coords = turtle->move(distance); //moving along turtle.heading for the default value of 1 unit unless a parameter is given\n  Patch& target_patch = get_patch(new_coords.first, new_coords.second);\n  if (target_patch.is_at_capacity()){\n    turtle->execute_move(false);\n  }\n  else{\n    // moving linked turtles here\n    float main_turtle_dx = new_coords.first - turtle->get_temp_x();\n    float main_turtle_dy = new_coords.second - turtle->get_temp_y();\n    if (turtle->getLinkedTurtles().size()>0){\n      for (auto link : turtle->getLinkedTurtles()) {\n        float current_x = link.lock()->get_x_dec();\n        float current_y = link.lock()->get_y_dec();\n        place_turtle(current_x+main_turtle_dx, current_y+main_turtle_dy, link.lock());\n      }\n    }\n    turtle->execute_move(true);\n    int temp = turtle_current_patch.getTurtlesHere().size();\n    turtle_current_patch.remove_turtle(turtle);\n    // if we do not actually remove the turtle from the patch, something is wrong\n    if ((temp - turtle_current_patch.getTurtlesHere().size()) != 1){std::cout<<'We did not remove the turtle from a patch when moving it. current size is '<< turtle_current_patch.getTurtlesHere().size()<<'. This is a problem and we will exit now'; exit(10);}\n    // adding the turtle to the new patch (can be the same as the old patch)\n    target_patch.add_turtle(turtle);\n  }\n}\n"
      },
      "83": {
            "Function_name": "void World::move_turtle_random_jump(std::shared_ptr<Turtle> turtle)",
            "Function_body": "void World::move_turtle_random_jump(std::shared_ptr<Turtle> turtle){\n  // same as move turtle but instead of turtle-> move() we are using turtle->jumpRandom(RNG_Engine)\n  Patch &turtle_current_patch = get_patch(turtle->getX(), turtle->getY());\n  std::pair<int,int> new_coords = turtle->jumpRandom(RNG_Engine);\n\n  Patch& target_patch = get_patch(new_coords.first, new_coords.second);\n    if (turtle_current_patch == target_patch){\n    return;\n  } else if (target_patch.is_at_capacity()){\n    turtle->execute_move(false);\n  }\n  else{\n    turtle->execute_move(true);\n    turtle_current_patch.remove_turtle(turtle);\n    target_patch.add_turtle(turtle);\n  }\n}\n"
      },
      "84": {
            "Function_name": "void World::turtle_wiggle(std::shared_ptr<Turtle> turtle)",
            "Function_body": "void World::turtle_wiggle(std::shared_ptr<Turtle> turtle){\n  // wiggles the turtles heading, then moves forward along the new heading for 1 unit\n  turtle->wiggle(RNG_Engine);\n  move_turtle(turtle);\n}"
      },
      "85": {
            "Function_name": "void World::kill_turtle(std::shared_ptr<Turtle> turtle)",
            "Function_body": "void World::kill_turtle(std::shared_ptr<Turtle> turtle){\n  // removed turtle from its patch\n  turtle->set_is_alive(false);\n  Patch &turtle_current_patch = get_patch(turtle->getX(), turtle->getY());\n  turtle_current_patch.remove_turtle(turtle);\n  turtle.reset();\n}\n"
      },
      "86": {
            "Function_name": "void World::updateTurtleVectors()",
            "Function_body": "void World::updateTurtleVectors(){\n    for(auto& turtle : all_turtles_to_kill){\n      if (std::shared_ptr<Bacteria> bacteria = std::dynamic_pointer_cast<Bacteria>(turtle)) {\n        all_bacterias.erase(std::remove(begin(all_bacterias), end(all_bacterias), bacteria), end(all_bacterias));\n        bacteria.reset();\n      } else if (std::shared_ptr<Antibodies> antibody = std::dynamic_pointer_cast<Antibodies>(turtle)) {\n        all_antibodies.erase(std::remove(begin(all_antibodies), end(all_antibodies), antibody), end(all_antibodies));\n      } else if (std::shared_ptr<FDCs> fdc = std::dynamic_pointer_cast<FDCs>(turtle)) {\n        all_fdcs.erase(std::remove(begin(all_fdcs), end(all_fdcs), fdc), end(all_fdcs));\n        fdc.reset();\n      } else if (std::shared_ptr<NaiveBCell> naive_b_cell = std::dynamic_pointer_cast<NaiveBCell>(turtle)) {\n        all_naive_b_cells.erase(std::remove(begin(all_naive_b_cells), end(all_naive_b_cells), naive_b_cell), end(all_naive_b_cells));\n        naive_b_cell.reset();\n      } else if (std::shared_ptr<ActivatedBCell> activated_b_cell = std::dynamic_pointer_cast<ActivatedBCell>(turtle)) {\n        all_activated_b_cells.erase(std::remove(begin(all_activated_b_cells), end(all_activated_b_cells), activated_b_cell),end(all_activated_b_cells));\n        activated_b_cell.reset();\n      } else if (std::shared_ptr<GCBCell> gcb_cell = std::dynamic_pointer_cast<GCBCell>(turtle)) {\n        all_gcb_cells.erase(std::remove(begin(all_gcb_cells), end(all_gcb_cells), gcb_cell), end(all_gcb_cells));\n        gcb_cell.reset();\n      } else if (std::shared_ptr<SLPlasmaCell> sl_plasma_cell = std::dynamic_pointer_cast<SLPlasmaCell>(turtle)) {\n        all_sl_plasma_cells.erase(std::remove(begin(all_sl_plasma_cells), end(all_sl_plasma_cells), sl_plasma_cell), end(all_sl_plasma_cells));\n        sl_plasma_cell.reset();\n      } else if (std::shared_ptr<LLPlasmaCell> ll_plasma_cell = std::dynamic_pointer_cast<LLPlasmaCell>(turtle)) {\n        all_ll_plasma_cells.erase(std::remove(begin(all_ll_plasma_cells), end(all_ll_plasma_cells), ll_plasma_cell), end(all_ll_plasma_cells));\n        ll_plasma_cell.reset();\n      } else if (std::shared_ptr<MemBCell> mem_b_cell = std::dynamic_pointer_cast<MemBCell>(turtle)) {\n        all_mem_b_cells.erase(std::remove(begin(all_mem_b_cells), end(all_mem_b_cells), mem_b_cell), end(all_mem_b_cells));\n        mem_b_cell.reset();\n      } else if (std::shared_ptr<BregCell> breg_cell = std::dynamic_pointer_cast<BregCell>(turtle)) {\n        all_breg_cells.erase(std::remove(begin(all_breg_cells), end(all_breg_cells), breg_cell), end(all_breg_cells));\n        breg_cell.reset();\n      } else if (std::shared_ptr<TfhCell> tfh_cell = std::dynamic_pointer_cast<TfhCell>(turtle)) {\n        all_tfh_cells.erase(std::remove(begin(all_tfh_cells), end(all_tfh_cells), tfh_cell), end(all_tfh_cells));\n        tfh_cell.reset();\n      } else if (std::shared_ptr<Th0Cell> th0_cell = std::dynamic_pointer_cast<Th0Cell>(turtle)) {\n        all_th0_cells.erase(std::remove(begin(all_th0_cells), end(all_th0_cells), th0_cell), end(all_th0_cells));\n        th0_cell.reset();\n      } else if (std::shared_ptr<Th1Cell> th1_cell = std::dynamic_pointer_cast<Th1Cell>(turtle)){\n        all_th1_cells.erase(std::remove(begin(all_th1_cells), end(all_th1_cells), th1_cell), end(all_th1_cells));\n        th1_cell.reset();\n      } else if (std::shared_ptr<Th2Cell> th2_cell = std::dynamic_pointer_cast<Th2Cell>(turtle)) {\n        all_th2_cells.erase(std::remove(begin(all_th2_cells), end(all_th2_cells), th2_cell), end(all_th2_cells));\n        th2_cell.reset();\n      }\n      // std::cout<<'turtle ID '<<turtle->getID()<<' use count '<<turtle.use_count()<<std::endl;\n      turtle.reset();\n\n    }\n    all_turtles_to_kill.clear();\n\n    // erasing the turtle weak pointers that are now a null pointer because they have been reset\n    all_turtles.erase(std::remove_if(all_turtles.begin(), all_turtles.end(),\n    [](const std::weak_ptr<Turtle>& wp) {     //lambda function to check if weak pointer is expired (aka killed and reset() has been called)\n        // if (wp.expired()){std::cout<<'Deleting expired Turtle'<<std::endl;}\n        return wp.expired();\n      }),\n    all_turtles.end());\n}\n"
      },
      "87": {
            "Function_name": "void World::setup()",
            "Function_body": "void World::setup(){\n  // This function initializes the global variables and setus up the world\n  global_ID_counter = 0;\n  step = 0;\n  time = 1;\n  setup_patches(); // Initializing the patches\n\n  // Clear all existing entities\n  all_turtles.clear();\n  all_bacterias.clear();\n  all_antibodies.clear();\n  all_fdcs.clear();\n  all_naive_b_cells.clear();\n  all_activated_b_cells.clear();\n  all_gcb_cells.clear();\n  all_sl_plasma_cells.clear();\n  all_ll_plasma_cells.clear();\n  all_mem_b_cells.clear();\n  all_breg_cells.clear();\n  all_tfh_cells.clear();\n  all_th0_cells.clear();\n  all_th1_cells.clear();\n  all_th2_cells.clear();\n\n  // Check if random runs is false, then set seed\n  if (!RandomRuns) {\n      set_rng_seed(RNG_SEED);\n      std::cout<<'printing test RNG'<<std::endl;\n      for (size_t i = 0; i < 10; i++) {\n        std::cout<<RNG_Engine()<<std::endl;\n      }\n  }\n\n  // Sets up the world structure\n  // In NetLogo, the center of the world is 0,0\n  // In C++, the bottom left of the world is 0,0\n  // Therefore, we need to shift the patches\n  int center_x = std::ceil(WORLD_WIDTH / 2);   //added the std::floor() because only in odd world sizes\n  int center_y = std::ceil(WORLD_HEIGHT / 2);  //will it matter, but 101 is odd\n\n  // Paracortex zone\n  for (int x = center_x - 200; x <= center_x + 200; x++) {\n      for (int y = center_y - 200; y <= center_y + 200; y++) {\n          if (x >= 0 && x < WORLD_WIDTH && y >= 0 && y < WORLD_HEIGHT) {\n              Patch& p = get_patch(x, y);\n              p.setPatchType(1);\n              p.setColor('gray');\n          }\n      }\n  }\n\n  // Follicle zone\n  for (int x = center_x - 49; x <= center_x + 49; x++) {\n      for (int y = center_y - 49; y <= center_y + 49; y++) {\n          if (x >= 0 && x < WORLD_WIDTH && y >= 0 && y < WORLD_HEIGHT) {\n            // Calculate the distance from the center\n            int dist_x = center_x - x;\n            int dist_y = center_y - y;\n            if (dist_x * dist_x + dist_y * dist_y <= 49 * 49) {  // Radius of 49 units\n                Patch& p = get_patch(x, y);\n                p.setPatchType(0);\n                p.setColor('black');\n            }\n          }\n      }\n  }\n\n// Rendering orientation squares\n  // get_patch(0,0).setColor('pink');\n  // get_patch(0,WORLD_HEIGHT-1).setColor('green');\n  // get_patch(WORLD_WIDTH-1,0).setColor('yellow');\n  // get_patch(WORLD_WIDTH-1,WORLD_HEIGHT-1).setColor('orange');\n  //\n  // std::cout<<'Angle To neighbor 0-TL(degrees)'<<atan2(1,-1) * 180/M_PI<<std::endl;\n  // std::cout<<'Angle To neighbor 1-T(degrees)'<<atan2(1,0) * 180/M_PI<<std::endl;\n  // std::cout<<'Angle To neighbor 2-TR(degrees)'<<atan2(1,1) * 180/M_PI<<std::endl;\n  // std::cout<<'Angle To neighbor 3-L(degrees)'<<atan2(0,-1) * 180/M_PI<<std::endl;\n  // std::cout<<'Angle To neighbor 4-R(degrees)'<<atan2(0,1) * 180/M_PI<<std::endl;\n  // std::cout<<'Angle To neighbor 5-BL(degrees)'<<atan2(-1,-1) * 180/M_PI<<std::endl;\n  // std::cout<<'Angle To neighbor 6-B(degrees)'<<atan2(-1,0) * 180/M_PI<<std::endl;\n  // std::cout<<'Angle To neighbor 7-BR(degrees)'<<atan2(-1,1) * 180/M_PI<<std::endl;\n  //\n  // get_patch(0,0).setColor('pink');\n  // get_patch(1,0).setColor('blue');\n  // get_patch(2,0).setColor('green');\n  // get_patch(0,1).setColor('black');\n  // get_patch(1,1).setColor('white');\n  // get_patch(2,1).setColor('brown');\n  // get_patch(0,2).setColor('yellow');\n  // get_patch(1,2).setColor('orange');\n  // get_patch(2,2).setColor('cyan');\n\n  // Exit from follicle\n  for (int y = center_y - 5; y <= center_y + 5; y++) {\n      if (y >= 0 && y < WORLD_HEIGHT) {\n          Patch& p1 = get_patch(center_x - 50, y);\n          Patch& p2 = get_patch(center_x - 49, y);\n          p1.setPatchType(2);\n          p1.setColor('red');\n          p2.setPatchType(2);\n          p2.setColor('red');\n      }\n  }\n\n  //I added this part. In order to initialize 100 (or however many) FDCs that are apropriate distances from the center and also from eachother, we need to generate their positions intentionally, and not randomly. To do this we should generate all of them ahead of time, then create the cells.\n  std::vector<std::pair<int, int>> FDCcoordinates = generateCoordinates(100, center_x, center_y, 30, 3);\n  // creates 100 coordinates, centered on our origin (center_x/y) within 30 units of the center, and each at least 3 units apart from eachother\n\n  // using the above command, I told gpt to recreate the pmn example from the general world.h example, but doing a different initialization command\n  for (size_t i = 0; i < FDCcoordinates.size(); i++) {\n      int x = FDCcoordinates[i].first;  // x-coordinate of the FDC\n      int y = FDCcoordinates[i].second; // y-coordinate of the FDC\n      auto fdc = std::make_shared<FDCs>(x, y, global_ID_counter++); // creating the actual FDC turtle\n      Patch& patch = get_patch(x, y); // get patch to add the turtle to\n\n      // Set shape and color for the FDC\n      fdc->setShape('square');\n      fdc->setColor('brown');\n\n      std::weak_ptr<Turtle> fdc_weak_ptr = fdc;   // creating a weak pointer to give to all turtles vector so that deleting fdc object kills it in the turtle list\n\n      // adding new turtle to all turtles vector, and specific type vector\n      all_turtles.push_back(fdc_weak_ptr);\n      all_fdcs.push_back(fdc);\n      patch.add_turtle(fdc); // add turtle to patch\n  }\n\n  int NUM_TFH_CELLS_TO_ADD = 50;\n  for (int i = 0; i < NUM_TFH_CELLS_TO_ADD; i++) {\n      // generate a new coordinate and verify if the patch at the coordinate is of type 1\n      std::pair<int, int> coord;\n      // do while loop. executes the codeblock once, then checks. while condition, it executes the block again then checks. Same thing as a normal while loop, but it will always do it at least once\n      do {\n          int random_x = RNG_Engine() % WORLD_WIDTH; //random X and Y position\n          int random_y = RNG_Engine() % WORLD_HEIGHT;\n          coord = std::make_pair(random_x, random_y);\n      } while (get_patch(coord.first, coord.second).getPatchType() != 1);\n      auto tfhCell = std::make_shared<TfhCell>(coord.first, coord.second, global_ID_counter++, RNG_Engine()%360); // create the TfhCell\n      Patch& patch = get_patch(coord.first, coord.second); // get patch to add the turtle to\n\n      // Set cell variables\n      tfhCell->setTimeAlive(-1000);\n      tfhCell->setShape('square');\n      tfhCell->setColor('cyan');\n      tfhCell->setCxcr5Level(11);\n      tfhCell->setCcr7Level(6);\n      tfhCell->setEbi2rLevel(5);\n      tfhCell->setBcellBindingStatus(false);\n\n      std::weak_ptr<Turtle> tfhCell_weak_ptr = tfhCell; // creating a weak pointer to give to all turtles vector\n\n      // adding new turtle to all turtles vector, and specific type vector\n      all_turtles.push_back(tfhCell_weak_ptr);\n      all_tfh_cells.push_back(tfhCell);\n      patch.add_turtle(tfhCell); // add turtle to patch\n  }\n\n  int NUM_TH1_CELLS_TO_ADD = 10;\n  for (int i = 0; i < NUM_TH1_CELLS_TO_ADD; i++) {\n      std::pair<int, int> coord;\n      do {\n          int random_x = RNG_Engine() % WORLD_WIDTH; //random X and Y position\n          int random_y = RNG_Engine() % WORLD_HEIGHT;\n          coord = std::make_pair(random_x, random_y);\n      } while (get_patch(coord.first, coord.second).getPatchType() != 1);\n\n      auto th1Cell = std::make_shared<Th1Cell>(coord.first, coord.second, global_ID_counter++, RNG_Engine()%360); // create the Th1Cell\n      Patch& patch = get_patch(coord.first, coord.second); // get patch to add the turtle to\n\n      // Set cell variables\n      th1Cell->setTimeAlive(-1000);\n      th1Cell->setShape('square');\n      th1Cell->setColor('blue');\n      th1Cell->setCxcr5Level(0);\n      th1Cell->setCcr7Level(2);\n      th1Cell->setEbi2rLevel(2);\n      th1Cell->setBcellBindingStatus(false);\n\n      std::weak_ptr<Turtle> th1Cell_weak_ptr = th1Cell; // creating a weak pointer to give to all turtles vector\n\n      // adding new turtle to all turtles vector, and specific type vector\n      all_turtles.push_back(th1Cell_weak_ptr);\n      all_th1_cells.push_back(th1Cell);\n      patch.add_turtle(th1Cell); // add turtle to patch\n  }\n\n  int NUM_TH2_CELLS_TO_ADD = 50;\n  for (int i = 0; i < NUM_TH2_CELLS_TO_ADD; i++) {\n      std::pair<int, int> coord;\n      do {\n          int random_x = RNG_Engine() % WORLD_WIDTH; //random X and Y position\n          int random_y = RNG_Engine() % WORLD_HEIGHT;\n          coord = std::make_pair(random_x, random_y);\n      } while (get_patch(coord.first, coord.second).getPatchType() != 1);\n\n      auto th2Cell = std::make_shared<Th2Cell>(coord.first, coord.second, global_ID_counter++, RNG_Engine()%360); // create the Th2Cell\n      Patch& patch = get_patch(coord.first, coord.second); // get patch to add the turtle to\n\n      // Set cell variables\n      th2Cell->setTimeAlive(-1000);\n      th2Cell->setShape('square');\n      th2Cell->setColor('blue');\n      th2Cell->setCxcr5Level(0);\n      th2Cell->setCcr7Level(2);\n      th2Cell->setEbi2rLevel(2);\n      th2Cell->setBcellBindingStatus(false);\n\n      std::weak_ptr<Turtle> th2Cell_weak_ptr = th2Cell; // creating a weak pointer to give to all turtles vector\n\n      // adding new turtle to all turtles vector, and specific type vector\n      all_turtles.push_back(th2Cell_weak_ptr);\n      all_th2_cells.push_back(th2Cell);\n      patch.add_turtle(th2Cell); // add turtle to patch\n  }\n\n\n\n  // Initialize global variables and counters\n  days_passed = 0;\n\n  // Reset ticks or equivalent time step counter\n  step = 0;\n}\n"
      },
      "88": {
            "Function_name": "void World::go() ",
            "Function_body": "void World::go() {\n  bool print_test = false;\n  calculateIncomingTNFaIL6Level();\n  simulateBackgroundInflammation();\n\n  // Update days_passed based on the step value.\n  setDaysPassed(step / 48);\n\n  spawnBCell();\n  // spawnTh0Cell();\n\n  // Cytokine release from paracortex\n  for (int x = 0; x < WORLD_WIDTH; x++) {\n      for (int y = 0; y < WORLD_HEIGHT; y++) {\n          Patch& p = get_patch(x, y);\n          if (p.getPatchType() == 1) {\n              p.setCcl19Level(p.getCcl19Level() + 2);\n              p.setEbi2Level(p.getEbi2Level() + 2);\n          }\n      }\n  }\n\n  // Cytokine release from follicle exit\n  for (int x = 0; x < WORLD_WIDTH; x++) {\n      for (int y = 0; y < WORLD_HEIGHT; y++) {\n          Patch& p = get_patch(x, y);\n          if (p.getPatchType() == 2) {\n              p.setS1pLevel(p.getS1pLevel() + 2);\n          }\n      }\n  }\n  if (print_test){std::cout<<'go 1'<<std::endl;}\n  // Ask all agents to perform their functions\n  for (auto& fdc : all_fdcs){fdcFunction(fdc);}\n  if (print_test){std::cout<<'go 2'<<std::endl;}\n\n  for (auto& naiveBCell : all_naive_b_cells){naiveBCellFunction(naiveBCell);}\n  if (print_test){std::cout<<'go 3'<<std::endl;}\n\n  for (auto& activatedBCell : all_activated_b_cells){activatedBCellFunction(activatedBCell);}\n  if (print_test){std::cout<<'go 4'<<std::endl;}\n\n  for (auto& gcbCell : all_gcb_cells){gc_b_cell_function(gcbCell);}\n  if (print_test){std::cout<<'go 5'<<std::endl;}\n\n  for (auto& llPlasmaCell : all_ll_plasma_cells){ll_plasma_cell_function(llPlasmaCell);}\n  if (print_test){std::cout<<'go 6'<<std::endl;}\n\n  for (auto& slPlasmaCell : all_sl_plasma_cells){sl_plasma_cell_function(slPlasmaCell);}\n  if (print_test){std::cout<<'go 7'<<std::endl;}\n\n  for (auto& memBCell : all_mem_b_cells){memBCellFunction(memBCell);}\n  if (print_test){std::cout<<'go 8'<<std::endl;}\n\n  for (auto& antibody : all_antibodies){antibodiesFunction(antibody);}\n  if (print_test){std::cout<<'go 9'<<std::endl;}\n\n  for (auto& bregCell : all_breg_cells){bregFunction(bregCell);}\n  if (print_test){std::cout<<'go 10'<<std::endl;}\n\n  for (auto& tfhCell : all_tfh_cells){tfhCellFunction(tfhCell);}\n  if (print_test){std::cout<<'go 11'<<std::endl;}\n\n  for (auto& th0Cell : all_th0_cells){th0CellFunction(th0Cell);}\n  if (print_test){std::cout<<'go 12'<<std::endl;}\n\n  for (auto& th1Cell : all_th1_cells){th1CellFunction(th1Cell);}\n  if (print_test){std::cout<<'go 13'<<std::endl;}\n\n  for (auto& th2Cell : all_th2_cells){th2CellFunction(th2Cell);}\n  if (print_test){std::cout<<'go 14'<<std::endl;}\n\n  for (auto& bacteria : all_bacterias){bacteriaFunction(bacteria);}\n  if (print_test){std::cout<<'go 15'<<std::endl;}\n\n  update_chemokine_gradient();\n  if (print_test){std::cout<<'go 16'<<std::endl;}\n  check_overall_cd21_expression();\n  if (print_test){std::cout<<'go 17'<<std::endl;}\n\n  // Check if autoinoculate is active\n  if(AUTOINOCULATE) {\n      if(step == AUTOINOCULATE_FIRST_TIME) {\n        std::cout<<'INNOCULATING FOR THE FIRST TIME NOWWWWWW'<<std::endl;\n          auto_inoculate(FIRST_EXPOSURE_AMOUNT);\n      }\n      else if(step == AUTOINOCULATE_SECOND_TIME) {\n        std::cout<<'INNOCULATING FOR THE SECONDDDDDDDDDD TIME NOWWWWWW'<<std::endl;\n          auto_inoculate(SECOND_EXPOSURE_AMOUNT);\n      }\n      else if(step == STOP_EXPOSURE_TIME) {\n          // stop();  // You might want to stop the simulation\n      }\n  }\n\n  // Increase the step (equivalent to NetLogo's tick)\n  step++;\n  // end of go\n  updateTurtleVectors(); // need to update turtle positions/delete dead turtles\n  if (print_test){std::cout<<'go 18'<<std::endl;}\n\n}\n"
      },
      "89": {
            "Function_name": "void World::update_chemokine_gradient()",
            "Function_body": "void World::update_chemokine_gradient(){\n  diffuse();\n  evaporate();\n}\n"
      },
      "90": {
            "Function_name": "void World::diffuse()",
            "Function_body": "void World::diffuse(){\n  // need to diffuse values from patches out to neighboring patches\n  double factor_for_neighbors = 1.0/8; //normally eight neighbors in a 2D grid\n\n  // follow this example format for each diffusing variable\n  for (auto& patch_row : all_patches) {  // reset temp_var\n    for (auto& patch : patch_row){\n      patch.setTempS1pLevel(0);\n      patch.setTempCxcl13Level(0);\n      patch.setTempCcl19Level(0);\n      patch.setTempEbi2Level(0);\n      patch.setTempIl2(0);\n      patch.setTempIl4(0);\n      patch.setTempIl6(0);\n      patch.setTempIl10(0);\n      patch.setTempIl12(0);\n      patch.setTempIl15(0);\n      patch.setTempIl21(0);\n      patch.setTempIfG(0);\n      patch.setTempIfA(0);\n      patch.setTempTnfA(0);\n      patch.setTempTgfB(0);\n    }\n  }\n  // start with Endotoxin\n  // get totals for neighbors\n  for (auto& patch_row : all_patches){\n    for (auto& center_patch : patch_row){\n      int center_patch_x_pos = center_patch.getX();\n      int center_patch_y_pos = center_patch.getY();\n      if (!TOROIDAL_WORLD){\n        bool x_edge = (center_patch_x_pos==0 || center_patch_x_pos==(WORLD_WIDTH-1));\n        bool y_edge = (center_patch_y_pos==0|| center_patch_y_pos==(WORLD_HEIGHT-1));\n        if(x_edge && y_edge){factor_for_neighbors = (1.0/3);}\n        else if (x_edge || y_edge){factor_for_neighbors=(1.0/5);}\n        else{factor_for_neighbors=(1.0/8);}\n      }\n      for (int i=-1; i<2; i++){\n        for (int j=-1; j<2; j++){\n          if (i==0 && j==0) { // skipping center cell\n            continue;\n          }\n          int neighbor_x, neighbor_y;\n          if (TOROIDAL_WORLD){\n            neighbor_x = fmod((center_patch_x_pos + i), WORLD_WIDTH); // getting modulo of position + x/y to wrap around toroidal world\n            neighbor_y = fmod((center_patch_y_pos + j), WORLD_HEIGHT);\n          } else{\n            neighbor_x = center_patch_x_pos + i;\n            neighbor_y = center_patch_y_pos + j;\n            // if not toroidal world and neighbor is out of bounds (ie we are on the edge) then continue\n            if ((neighbor_y >= WORLD_HEIGHT) || (neighbor_y < 0)){continue;}\n            if ((neighbor_x >= WORLD_WIDTH) || (neighbor_x < 0)){continue;}\n          }\n          auto& neighbor_patch = get_patch(neighbor_x, neighbor_y);\n\n          // evenly adding the amount diffused out from the center patch to neighbor patches\n          neighbor_patch.setTempCxcl13Level(neighbor_patch.getTempCxcl13Level() + center_patch.getCxcl13Level() * factor_for_neighbors * CXCL13_LEVEL_DIFFUSION_FACTOR);\n          neighbor_patch.setTempCcl19Level(neighbor_patch.getTempCcl19Level() + center_patch.getCcl19Level() * factor_for_neighbors * CCL19_LEVEL_DIFFUSION_FACTOR);\n          neighbor_patch.setTempEbi2Level(neighbor_patch.getTempEbi2Level() + center_patch.getEbi2Level() * factor_for_neighbors * EBI2_LEVEL_DIFFUSION_FACTOR);\n          neighbor_patch.setTempS1pLevel(neighbor_patch.getTempS1pLevel() + center_patch.getS1pLevel() * factor_for_neighbors * S1P_LEVEL_DIFFUSION_FACTOR);\n          neighbor_patch.setTempIl2(neighbor_patch.getTempIl2() + center_patch.getIl2() * factor_for_neighbors * IL2_DIFFUSION_FACTOR);\n          neighbor_patch.setTempIl4(neighbor_patch.getTempIl4() + center_patch.getIl4() * factor_for_neighbors * IL4_DIFFUSION_FACTOR);\n          neighbor_patch.setTempIl6(neighbor_patch.getTempIl6() + center_patch.getIl6() * factor_for_neighbors * IL6_DIFFUSION_FACTOR);\n          neighbor_patch.setTempIl10(neighbor_patch.getTempIl10() + center_patch.getIl10() * factor_for_neighbors * IL10_DIFFUSION_FACTOR);\n          neighbor_patch.setTempIl12(neighbor_patch.getTempIl12() + center_patch.getIl12() * factor_for_neighbors * IL12_DIFFUSION_FACTOR);\n          neighbor_patch.setTempIl15(neighbor_patch.getTempIl15() + center_patch.getIl15() * factor_for_neighbors * IL15_DIFFUSION_FACTOR);\n          neighbor_patch.setTempIl21(neighbor_patch.getTempIl21() + center_patch.getIl21() * factor_for_neighbors * IL21_DIFFUSION_FACTOR);\n          neighbor_patch.setTempIfG(neighbor_patch.getTempIfG() + center_patch.getIfG() * factor_for_neighbors * IF_G_DIFFUSION_FACTOR);\n          neighbor_patch.setTempIfA(neighbor_patch.getTempIfA() + center_patch.getIfA() * factor_for_neighbors * IF_A_DIFFUSION_FACTOR);\n          neighbor_patch.setTempTnfA(neighbor_patch.getTempTnfA() + center_patch.getTnfA() * factor_for_neighbors * TNF_A_DIFFUSION_FACTOR);\n          neighbor_patch.setTempTgfB(neighbor_patch.getTempTgfB() + center_patch.getTgfB() * factor_for_neighbors * TGF_B_DIFFUSION_FACTOR);\n        }\n      }\n    }\n  }\n  // set Endotoxin on each patch from the temp var, then reset tempvar\n  for (auto& patch_row : all_patches){\n    for (auto& patch : patch_row){\n      // new total is starting amount minus the amount that diffused out, plus the amount that diffused in from neighbors\n      patch.setS1pLevel((patch.getS1pLevel() * (1 - S1P_LEVEL_DIFFUSION_FACTOR)) + patch.getTempS1pLevel());\n      // std::cout<<'S1p level in diffusion: '<<patch.getTempS1pLevel()<<std::endl;\n      patch.setTempS1pLevel(0); // resetting\n\n      patch.setCxcl13Level((patch.getCxcl13Level() * (1 - CXCL13_LEVEL_DIFFUSION_FACTOR)) + patch.getTempCxcl13Level());\n      patch.setTempCxcl13Level(0); // resetting\n\n      patch.setCcl19Level((patch.getCcl19Level() * (1 - CCL19_LEVEL_DIFFUSION_FACTOR)) + patch.getTempCcl19Level());\n      patch.setTempCcl19Level(0); // resetting\n\n      patch.setEbi2Level((patch.getEbi2Level() * (1 - EBI2_LEVEL_DIFFUSION_FACTOR)) + patch.getTempEbi2Level());\n      patch.setTempEbi2Level(0); // resetting\n\n      patch.setIl2((patch.getIl2() * (1 - IL2_DIFFUSION_FACTOR)) + patch.getTempIl2());\n      patch.setTempIl2(0); // resetting\n\n      patch.setIl4((patch.getIl4() * (1 - IL4_DIFFUSION_FACTOR)) + patch.getTempIl4());\n      patch.setTempIl4(0); // resetting\n\n      patch.setIl6((patch.getIl6() * (1 - IL6_DIFFUSION_FACTOR)) + patch.getTempIl6());\n      patch.setTempIl6(0); // resetting\n\n      patch.setIl10((patch.getIl10() * (1 - IL10_DIFFUSION_FACTOR)) + patch.getTempIl10());\n      patch.setTempIl10(0); // resetting\n\n      patch.setIl12((patch.getIl12() * (1 - IL12_DIFFUSION_FACTOR)) + patch.getTempIl12());\n      patch.setTempIl12(0); // resetting\n\n      patch.setIl15((patch.getIl15() * (1 - IL15_DIFFUSION_FACTOR)) + patch.getTempIl15());\n      patch.setTempIl15(0); // resetting\n\n      patch.setIl21((patch.getIl21() * (1 - IL21_DIFFUSION_FACTOR)) + patch.getTempIl21());\n      patch.setTempIl21(0); // resetting\n\n      patch.setIfG((patch.getIfG() * (1 - IF_G_DIFFUSION_FACTOR)) + patch.getTempIfG());\n      patch.setTempIfG(0); // resetting\n\n      patch.setIfA((patch.getIfA() * (1 - IF_A_DIFFUSION_FACTOR)) + patch.getTempIfA());\n      patch.setTempIfA(0); // resetting\n\n      patch.setTnfA((patch.getTnfA() * (1 - TNF_A_DIFFUSION_FACTOR)) + patch.getTempTnfA());\n      patch.setTempTnfA(0); // resetting\n\n      patch.setTgfB((patch.getTgfB() * (1 - TGF_B_DIFFUSION_FACTOR)) + patch.getTempTgfB());\n      patch.setTempTgfB(0); // resetting\n    }\n  }\n}\n"
      },
      "91": {
            "Function_name": "void World::evaporate()",
            "Function_body": "void World::evaporate(){\n  // evaporate variables off of all patches\n  for (auto& patch_row : all_patches) {\n    for (auto& patch : patch_row){\n      // Endotoxin as an example, amount to set is current amount times the evaporation factor\n      patch.setCxcl13Level(patch.getCxcl13Level() * CXCL13_EVAPORATION_FACTOR);\n      patch.setCcl19Level(patch.getCcl19Level() * CCL19_EVAPORATION_FACTOR);\n      patch.setEbi2Level(patch.getEbi2Level() * EBI2_EVAPORATION_FACTOR);\n      patch.setS1pLevel(patch.getS1pLevel() * S1P_EVAPORATION_FACTOR);\n      patch.setIl2(patch.getIl2() * IL2_EVAPORATION_FACTOR);\n      patch.setIl4(patch.getIl4() * IL4_EVAPORATION_FACTOR);\n      patch.setIl6(patch.getIl6() * IL6_EVAPORATION_FACTOR);\n      patch.setIl10(patch.getIl10() * IL10_EVAPORATION_FACTOR);\n      patch.setIl12(patch.getIl12() * IL12_EVAPORATION_FACTOR);\n      patch.setIl15(patch.getIl15() * IL15_EVAPORATION_FACTOR);\n      patch.setIl21(patch.getIl21() * IL21_EVAPORATION_FACTOR);\n      patch.setIfG(patch.getIfG() * IF_G_EVAPORATION_FACTOR);\n      patch.setIfA(patch.getIfA() * IF_A_EVAPORATION_FACTOR);\n      patch.setTnfA(patch.getTnfA() * TNF_A_EVAPORATION_FACTOR);\n      patch.setTgfB(patch.getTgfB() * TGF_B_EVAPORATION_FACTOR);\n    }\n  }\n}\n"
      },
      "92": {
            "Function_name": "  template <typename CellType>\n  int countCells(int patchX, int patchY)",
            "Function_body": "  template <typename CellType>\n  int countCells(int patchX, int patchY){\n    int total_count = 0;\n    Patch& current_patch = get_patch(patchX, patchY);\n    std::vector<std::shared_ptr<Turtle>> turtles_on_patch = current_patch.getTurtlesHere();\n\n    for (const auto& turtle : turtles_on_patch){\n      if (std::dynamic_pointer_cast<CellType>(turtle)) {\n        // The turtle is of type we are looking for, increment count\n        total_count++;\n      }\n    }\n    return total_count;\n  }"
      },
      "93": {
            "Function_name": "template <typename CellType>\n  bool checkTNFStatus(CellType& cell)",
            "Function_body": "template <typename CellType>\n  bool checkTNFStatus(CellType& cell){\n// if returns true, that means this cell needs to die\n    Patch& current_patch = get_patch(cell->getX(), cell->getY());\n    current_patch.setTnfA(current_patch.getTnfA() - .01);\n    cell->setTnfaStimulation(current_patch.getTnfA() * 100);\n\n    return (cell->getTnfaStimulation() > cell->getTnfaThreshold());\n  }"
      },
      "94": {
            "Function_name": "template <typename CellType>\n  bool checkBregStatus(CellType& cell)",
            "Function_body": "template <typename CellType>\n  bool checkBregStatus(CellType& cell){\n    Patch& current_patch = get_patch(cell->getX(), cell->getY());\n    if (cell->getProBreg() > cell->getBregThreshold()){\n      return true;\n    } else{\n      float amount_to_set = (current_patch.getIl6() + current_patch.getIl21()) * 45;\n      cell->setProBreg(amount_to_set);\n      return false;\n    }\n  }"
      },
      "95": {
            "Function_name": "template <typename CellType>\n  std::shared_ptr<BregCell> turnIntoBreg(CellType& cell)",
            "Function_body": "template <typename CellType>\n  std::shared_ptr<BregCell> turnIntoBreg(CellType& cell){\n    // std::cout<<std::endl<<std::endl<<std::endl<<std::endl;\n    // std::cout<<'turning into breg'<<std::endl;\n    // std::cout<<'original cell ID '<<cell->getID()<< ' and location '<<cell<<std::endl;\n    CellType placeholder = cell;\n    // std::cout<<'placeholder cell ID '<<placeholder->getID()<<' and location '<<placeholder<<std::endl;\n\n    std::shared_ptr<BregCell> breg = std::make_shared<BregCell>(cell->getX(), cell->getY(), global_ID_counter++, cell->getHeading());\n    // std::shared_ptr<BregCell> breg = std::make_shared<BregCell>(0, 0, 99,0);\n    // std::cout<<'breg ID '<<breg->getID()<<' and location '<<breg<<std::endl;\n    // std::cout<<'original cell ID '<<cell->getID()<< ' and location '<<cell<<std::endl;\n    // std::cout<<'placeholder cell ID '<<placeholder->getID()<<' and location '<<placeholder<<std::endl;\n    // global_ID_counter++;\n    // std::cout<<'breg ID '<<breg->getID()<<' and location '<<breg<<std::endl;\n    // std::cout<<'original cell ID '<<cell->getID()<< ' and location '<<cell<<std::endl;\n    // std::cout<<'placeholder cell ID '<<placeholder->getID()<<' and location '<<placeholder<<std::endl;\n\n\n\n    breg->copy_other_turtle_attributes(cell);\n    breg->setSize(1);\n    breg->setShape('circle');\n    breg->setColor('violet');\n    breg->setS1pr1Level(0);\n    breg->setCxcr5Level(10);\n    breg->setTimeAlive(0);\n\n    std::weak_ptr<Turtle> breg_weak_ptr = breg;\n    all_turtles.push_back(breg_weak_ptr);\n    all_breg_cells.push_back(breg);\n    get_patch(cell->getX(), cell->getY()).add_turtle(breg);\n    // std::cout<<'breg ID '<<breg->getID()<<std::endl;\n    // std::cout<<'original cell ID '<<cell->getID()<<std::endl;\n    kill(cell);\n    return breg;\n  }"
      },
      "96": {
            "Function_name": "template <typename CellType>\n  void chemotaxis(CellType& cell)",
            "Function_body": "template <typename CellType>\n  void chemotaxis(CellType& cell){\n    // std::cout<<'chemotaxing'<<std::endl;\n    // std::cout<<'my location' <<cell->getX()<<', '<< cell->getY()<<std::endl;\n    Patch& current_patch = get_patch(cell->getX(), cell->getY());\n    double final_heading = cell->getHeading();\n    std::shared_ptr<Bacteria> test_cell = std::dynamic_pointer_cast<Bacteria>(cell);\n    bool print_test = false;\n    // print_test = (test_cell != NULL);\n    // if (print_test){print_test = bool(test_cell->getID() == 120);}\n    // if (print_test){test_cell->setColor('orange'); test_cell->setShape('bug');}\n    // if (print_test){\n    //   print_test = (cell->getX() == WORLD_WIDTH);\n    // }\n    if(print_test){std::cout<<'1st time: ID '<<cell->getID()<<', HEADING '<<cell->getHeading()<<std::endl;};\n\n    std::vector<Patch> neighbors;\n    int count = 0;\n    for (int x = -1; x < 2; x++) {\n      for (int y = -1; y < 2; y++) {\n        if (x==0 && y==0){continue;}\n\n        if (!TOROIDAL_WORLD){\n          if ((current_patch.getX() + x) >= WORLD_WIDTH){continue;}\n          if ((current_patch.getX() + x) < 0){continue;}\n          if ((current_patch.getY() + y) >= WORLD_HEIGHT){continue;}\n          if ((current_patch.getY() + x) < 0){continue;}\n        }\n        // std::cout<<'neighbor '<<count<<' location'<<cell->getX() + x<<', '<< cell->getY()+ y <<std::endl;\n        count ++;\n        neighbors.push_back(get_patch(current_patch.getX() + x, current_patch.getY() + y));\n      }\n    }\n    if (print_test){std::cout<<'chemotaxing2:    '<<count<<std::endl;}\n\n    int random_max_patch_ind = RNG_Engine() % neighbors.size();\n    Patch max_patch = neighbors[random_max_patch_ind];\n\n    double s1pr1_weight = cell->getS1pr1Level() / 100.0;\n    double max_s1p = 0;\n    for (auto neighbor_patch: neighbors){\n      if (neighbor_patch.getS1pLevel() > max_s1p) {\n        // std::cout<<'Changing max patch'<<std::endl;\n        max_s1p = neighbor_patch.getS1pLevel();\n        max_patch = get_patch(neighbor_patch.getX(), neighbor_patch.getY());\n      }\n    }\n    double angle_absolute_to_s1p = cell->angle_to(get_patch(max_patch.getX(), max_patch.getY()));\n    double angle_relative_to_s1p = angle_absolute_to_s1p - cell->getHeading();\n    if (angle_relative_to_s1p<-180){angle_relative_to_s1p+=360;}\n    if (angle_relative_to_s1p>180){angle_relative_to_s1p-=360;}\n    angle_relative_to_s1p = fmod(angle_relative_to_s1p,360);\n\n    if (print_test){std::cout<<'my current position is '<<test_cell->getX()<<', '<<test_cell->getY()<<std::endl;\n      std::cout<<'Max Patch position is '<<max_patch.getX()<<', '<<max_patch.getY()<<std::endl;}\n\n\n    if(print_test){\n      std::cout<<'2nd  time: ID '<<cell->getID()<<', HEADING '<< final_heading;\n      std::cout<<' s1pr1_weight '<<s1pr1_weight<<std::endl;\n      std::cout<<'angle_absolute_to_s1p  '<<angle_absolute_to_s1p<<std::endl;\n      std::cout<<'angle_relative_to_s1p  '<<angle_relative_to_s1p<<std::endl;\n    };\n    final_heading += angle_relative_to_s1p*s1pr1_weight;\n\n\n    // random_max_patch_ind = RNG_Engine() % neighbors.size();\n    // max_patch = neighbors[random_max_patch_ind];\n    double s1pr2_weight = cell->getS1pr2Level() / 100.0;\n    double max_s1pr2 = 0;\n    for (auto neighbor_patch: neighbors){\n        if (neighbor_patch.getS1pLevel() > max_s1pr2) {\n            max_s1pr2 = neighbor_patch.getS1pLevel();\n            max_patch = get_patch(neighbor_patch.getX(), neighbor_patch.getY());\n        }\n    }\n    double angle_absolute_to_s1pr2 = cell->angle_to(get_patch(max_patch.getX(), max_patch.getY()));\n    double angle_relative_to_s1pr2 = angle_absolute_to_s1pr2 - cell->getHeading();\n    if (angle_relative_to_s1pr2<-180){angle_relative_to_s1pr2+=360;}\n    if (angle_relative_to_s1pr2>180){angle_relative_to_s1pr2-=360;}\n    angle_relative_to_s1pr2 = fmod(angle_relative_to_s1pr2,360);\n\n    if (print_test){std::cout<<'my current position is '<<test_cell->getX()<<', '<<test_cell->getY()<<std::endl;\n      std::cout<<'Max Patch position is '<<max_patch.getX()<<', '<<max_patch.getY()<<std::endl;}\n\n\n    final_heading += angle_relative_to_s1pr2*s1pr2_weight;\n    if(print_test){std::cout<<'3rd time: ID '<<cell->getID()<<', HEADING '<<final_heading<<' s1pr2_weight '<<s1pr2_weight<<std::endl;\n    std::cout<<'angle_absolute_to_s1pr2  '<<angle_absolute_to_s1pr2<<std::endl;\n    std::cout<<'angle_relative_to_s1pr2  '<<angle_relative_to_s1pr2<<std::endl;\n    };\n\n\n    //for CxCR5/cxcl13\n    // random_max_patch_ind = RNG_Engine() % neighbors.size();\n    // max_patch = neighbors[random_max_patch_ind];\n    double cxcr5_weight = cell->getCxcr5Level() / 100.0;\n    double max_cxcl13 = 0;\n    for (auto neighbor_patch: neighbors){\n        if (neighbor_patch.getCxcl13Level() > max_cxcl13) {\n            max_cxcl13 = neighbor_patch.getCxcl13Level();\n            max_patch = get_patch(neighbor_patch.getX(), neighbor_patch.getY());\n        }\n    }\n    double angle_absolute_to_cxcl13 = cell->angle_to(get_patch(max_patch.getX(), max_patch.getY()));\n    double angle_relative_to_cxcl13 = angle_absolute_to_cxcl13 - cell->getHeading();\n    if (angle_relative_to_cxcl13<-180){angle_relative_to_cxcl13+=360;}\n    if (angle_relative_to_cxcl13>180){angle_relative_to_cxcl13-=360;}\n    angle_relative_to_cxcl13 = fmod(angle_relative_to_cxcl13,360);\n\n    if (print_test){std::cout<<'my current position is '<<test_cell->getX()<<', '<<test_cell->getY()<<std::endl;\n      std::cout<<'Max Patch position is '<<max_patch.getX()<<', '<<max_patch.getY()<<std::endl;}\n\n    final_heading += angle_relative_to_cxcl13*cxcr5_weight;\n    if(print_test){std::cout<<'4th time: ID '<<cell->getID()<<', HEADING '<< final_heading<<' CXCR5 weight '<<cxcr5_weight<<std::endl;\n    std::cout<<'angle_absolute_to_cxcl13  '<<angle_absolute_to_cxcl13<<std::endl;\n    std::cout<<'angle_relative_to_cxcl13  '<<angle_relative_to_cxcl13<<std::endl;\n    };\n\n    // for ccr7/ccl19\n    // random_max_patch_ind = RNG_Engine() % neighbors.size();\n    // max_patch = neighbors[random_max_patch_ind];\n    double cccl7_weight = cell->getCcr7Level() / 100.0;\n    double max_ccl19 = 0;\n    for (auto neighbor_patch: neighbors){\n        if (neighbor_patch.getCcl19Level() > max_ccl19) {\n            max_ccl19 = neighbor_patch.getCcl19Level();\n            max_patch = get_patch(neighbor_patch.getX(), neighbor_patch.getY());\n        }\n    }\n    double angle_absolute_to_ccl19 = cell->angle_to(get_patch(max_patch.getX(), max_patch.getY()));\n    double angle_relative_to_ccl19 = angle_absolute_to_ccl19 - cell->getHeading();\n    if (angle_relative_to_ccl19<-180){angle_relative_to_ccl19+=360;}\n    if (angle_relative_to_ccl19>180){angle_relative_to_ccl19-=360;}\n    angle_relative_to_ccl19 = fmod(angle_relative_to_ccl19,360);\n\n    if (print_test){std::cout<<'my current position is '<<test_cell->getX()<<', '<<test_cell->getY()<<std::endl;\n      std::cout<<'Max Patch position is '<<max_patch.getX()<<', '<<max_patch.getY()<<std::endl;}\n\n    final_heading += angle_relative_to_ccl19*cccl7_weight;\n    if(print_test){std::cout<<'5th time: ID '<<cell->getID()<<', HEADING '<< final_heading<<' CCcL7 weight '<<cccl7_weight<<std::endl;\n    std::cout<<'angle_absolute_to_ccl19  '<<angle_absolute_to_ccl19<<std::endl;\n    std::cout<<'angle_relative_to_ccl19  '<<angle_relative_to_ccl19<<std::endl;\n    };\n\n    // For ebi2r_level\n    // random_max_patch_ind = RNG_Engine() % neighbors.size();\n    // max_patch = neighbors[random_max_patch_ind];\n    double ebi2r_weight = cell->getEbi2rLevel() / 100.0;\n    double max_ebi2 = 0;\n    for (auto neighbor_patch: neighbors){\n        if (neighbor_patch.getEbi2Level() > max_ebi2) {\n\n            max_ebi2 = neighbor_patch.getEbi2Level();\n            max_patch = get_patch(neighbor_patch.getX(), neighbor_patch.getY());\n        }\n    }\n    double angle_absolute_to_ebi2 = cell->angle_to(get_patch(max_patch.getX(), max_patch.getY()));\n    double angle_relative_to_ebi2 = angle_absolute_to_ebi2 - cell->getHeading();\n    if (angle_relative_to_ebi2<-180){angle_relative_to_ebi2+=360;}\n    if (angle_relative_to_ebi2>180){angle_relative_to_ebi2-=360;}\n    angle_relative_to_ebi2 = fmod(angle_relative_to_ebi2,360);\n\n    if (print_test){std::cout<<'my current position is '<<test_cell->getX()<<', '<<test_cell->getY()<<std::endl;\n      std::cout<<'Max Patch position is '<<max_patch.getX()<<', '<<max_patch.getY()<<std::endl;}\n\n\n\n    final_heading += angle_relative_to_ebi2 * ebi2r_weight;\n    if(print_test){std::cout<<'6th time: ID '<<cell->getID()<<', HEADING '<< final_heading<<' ebi2r_weight'<<ebi2r_weight<<std::endl;\n    std::cout<<'angle_absolute_to_ebi2  '<<angle_absolute_to_ebi2<<std::endl;\n    std::cout<<'angle_relative_to_ebi2  '<<angle_relative_to_ebi2<<std::endl;\n    };\n\n\n    if (final_heading > 180){final_heading-=360;}\n    if (final_heading < -180){final_heading+=360;}\n  cell->setHeading((int)final_heading%(360));\n  // cell->setHeading(180);\n  if(print_test){std::cout<<'FINAL TIME: ID '<<cell->getID()<<', HEADING '<<cell->getHeading()<<std::endl<<std::endl<<std::endl<<std::endl;};\n\n  // std::cout<<'END CHEMOTAXING'<<std::endl;\n  }\n\n\n};"
      }
}