{
      "0": {
            "Header_file_name": "WORLD_H",
            "Header_file_content": "\n// world.h\n#ifndef WORLD_H\n#define WORLD_H\n\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <vector>\n#include <stdlib.h>\n#include <memory>\n#include <algorithm>\n#include <random>\n\n\n#include 'parameters.h'\n#include 'agent.h'\n#include 'patch.h'\n#include 'turtle.h'\n#include 'bacteria.h'\n#include 'antibodies.h'\n#include 'fdcs.h'\n#include 'naive_b_cell.h'\n#include 'activated_b_cell.h'\n#include 'gc_b_cell.h'\n#include 'sl_plasma_cell.h'\n#include 'll_plasma_cell.h'\n#include 'mem_b_cell.h'\n#include 'breg_cell.h'\n#include 'tfh_cell.h'\n#include 'th0_cell.h'\n#include 'th1_cell.h'\n#include 'th2_cell.h'\n\nclass World {\nprivate:\n  std::mt19937 RNG_Engine;\n  int global_ID_counter;  //ID counter for creating new turtles to make sure each has a unique ID\n  int step;\n  int time;\n  int loop_run;\n\n  // NetLogo global variables\n  int days_passed;\n  double average_cd21_expression;\n  int total_num_of_apoptosed_cells;\n\n  Patch all_patches[WORLD_WIDTH][WORLD_HEIGHT];\n\n  // Vectors of shared pointers to different turtle subclasses\n  std::vector<std::shared_ptr<Bacteria>> all_bacterias;\n  std::vector<std::shared_ptr<Antibodies>> all_antibodies;\n  std::vector<std::shared_ptr<FDCs>> all_fdcs;\n  std::vector<std::shared_ptr<NaiveBCell>> all_naive_b_cells;\n  std::vector<std::shared_ptr<ActivatedBCell>> all_activated_b_cells;\n  std::vector<std::shared_ptr<GCBCell>> all_gcb_cells;\n  std::vector<std::shared_ptr<SLPlasmaCell>> all_sl_plasma_cells;\n  std::vector<std::shared_ptr<LLPlasmaCell>> all_ll_plasma_cells;\n  std::vector<std::shared_ptr<MemBCell>> all_mem_b_cells;\n  std::vector<std::shared_ptr<BregCell>> all_breg_cells;\n  std::vector<std::shared_ptr<TfhCell>> all_tfh_cells;\n  std::vector<std::shared_ptr<Th0Cell>> all_th0_cells;\n  std::vector<std::shared_ptr<Th1Cell>> all_th1_cells;\n  std::vector<std::shared_ptr<Th2Cell>> all_th2_cells;\n  std::vector<std::shared_ptr<Turtle>> all_turtles_to_kill;\n\n  void set_rng_seed(int newSeed){RNG_Engine.seed(newSeed);}\n  void add_patch(int x, int y);\n\npublic:\n  std::vector<std::weak_ptr<Turtle>> all_turtles;\n\n  World(){};\n\n  Patch& get_patch(double x_arg, double y_arg);\n  Patch& get_patch_ahead(std::shared_ptr<Turtle> turtle, float distance=1);\n  Patch& get_patch_ahead_right(std::shared_ptr<Turtle> turtle, float distance=1);\n  Patch& get_patch_ahead_left(std::shared_ptr<Turtle> turtle, float distance=1);\n\n  void setup_patches();\n  void display_patches();\n\n  void add_turtle(int x, int y, int id, int heading=0);\n  void place_turtle(double x, double y, std::shared_ptr<Turtle> turtle);\n  void move_turtle(std::shared_ptr<Turtle> turtle, float distance=1);\n  void move_turtle_random_jump(std::shared_ptr<Turtle> turtle);\n  void turtle_wiggle(std::shared_ptr<Turtle> turtle);\n\n  void kill_turtle(std::shared_ptr<Turtle> turtle);\n\n  // templated function to kill any turtle or agent\n  template <typename T>\n  void kill(std::shared_ptr<T> &ptr){\n    // std::cout<<'Killing turtle with ID '<<ptr->getID()<<std::endl;\n    ptr->removeLinkedTurtle();\n    all_turtles_to_kill.push_back(ptr);\n    kill_turtle(ptr);\n  }\n\n  void updateTurtleVectors();\n\n  void setup();\n  void go();\n\n  void check_overall_cd21_expression();\n  void calculateIncomingTNFaIL6Level();\n  void simulateBackgroundInflammation();\n  void update_chemokine_gradient();\n  void auto_inoculate(int numBac);\n\n  void diffuse();\n  void evaporate();\n\n  void spawnTh0Cell();\n  void spawnBCell();\n\n  void fdcFunction(std::shared_ptr<FDCs> fdc);\n  void antibodiesFunction(std::shared_ptr<Antibodies> antibody);\n  void naiveBCellFunction(std::shared_ptr<NaiveBCell> naive_b_cell);\n  void bregFunction(std::shared_ptr<BregCell> breg_cell);\n  void activatedBCellFunction(std::shared_ptr<ActivatedBCell> activated_b_cell);\n  void tdResponse(std::shared_ptr<ActivatedBCell> activated_b_cell);\n  void tiResponse(std::shared_ptr<ActivatedBCell> activated_b_cell);\n  void gc_b_cell_function(std::shared_ptr<GCBCell> gc_b_cell);\n  void ll_plasma_cell_function(std::shared_ptr<LLPlasmaCell> ll_plasma_cell);\n  void sl_plasma_cell_function(std::shared_ptr<SLPlasmaCell> sl_plasma_cell);\n  void memBCellFunction(std::shared_ptr<MemBCell> naive_b_cell);\n  void th0CellFunction(std::shared_ptr<Th0Cell> th0_cell);\n  void tfhCellFunction(std::shared_ptr<TfhCell> tfh_cell);\n  void th1CellFunction(std::shared_ptr<Th1Cell> th1_cell);\n  void th2CellFunction(std::shared_ptr<Th2Cell> th2_cell);\n  void bacteriaFunction(std::shared_ptr<Bacteria> bacteria);\n\n  std::shared_ptr<Antibodies> getOneAntibodyHere(int xPos, int yPos);\n  std::shared_ptr<FDCs> getOneFDCHere(int patchX, int patchY);\n  std::shared_ptr<Bacteria> getOneBacteriaHere(int patchX, int patchY);\n  std::shared_ptr<Th2Cell> getOneTh2Here(int patchX, int patchY);\n  std::shared_ptr<TfhCell> getOneTfhHere(int patchX, int patchY);\n  std::shared_ptr<ActivatedBCell> getOneActivatedBCellHere(int patchX, int patchY);\n  std::vector<std::shared_ptr<FDCs>> get_fdcs_with_no_presented_antigen();\n\n  // void checkTNFStatus(std::shared_ptr<T> cell) lives at bottom because of template declaration restrictions\n  void isotypeSwitch(std::shared_ptr<ActivatedBCell> activated_b_cell);\n  // Getters and setters for global variables\n  int getDaysPassed() const { return days_passed; }\n  void setDaysPassed(int days) { days_passed = days; }\n\n  double getAverageCD21Expression() const { return average_cd21_expression; }\n  void setAverageCD21Expression(double expr) { average_cd21_expression = expr; }\n\n  int getTotalNumOfApoptosedCells() const { return total_num_of_apoptosed_cells; }\n  void setTotalNumOfApoptosedCells(int num) { total_num_of_apoptosed_cells = num; }\n\n\n};\n\n\n#endif\n"
      },
      "1": {
            "Header_file_name:": "ACTIVATED_B_CELL_H",
            "Header_file_content": "\n#ifndef ACTIVATED_B_CELL_H\n#define ACTIVATED_B_CELL_H\n\n#include 'turtle.h'\n\nclass ActivatedBCell : public Turtle {\nprivate:\n    // Response type for activated B cells\n    int response_type;\n\npublic:\n    // You can add specific methods and properties for this subclass\n    ActivatedBCell(int x, int y, int id, int heading);\n\n    // Override Turtle methods if needed\n\n    // Getter for response type\n    int getResponseType() const { return response_type; }\n\n    // Setter for response type\n    void setResponseType(int response_type) { this->response_type = response_type; }\n\n};\n\n#endif\n"
      },
      "2": {
            "Function_name": "    template <typename agent>\n    double angle_to(agent& target)",
            "Function_body": "    template <typename agent>\n    double angle_to(agent& target){\n      int targetx = target.getX();\n      int targety = target.getY();\n\n      int delta_x = targetx - x;\n      int delta_y = y - targety; //do this opposite to X because the origin is in the top left corner\n\n      // dealing with when the world wraps and target is all the way on the left, and from is all the way on the right\n      // it would give a delta_x close to -WORLD_WIDTH,\n      if ((delta_x + WORLD_WIDTH) < abs(delta_x)){\n        delta_x = (delta_x + WORLD_WIDTH)% WORLD_WIDTH;\n      }\n      if ((delta_y + WORLD_HEIGHT) < abs(delta_y)){\n        delta_y = (delta_y + WORLD_HEIGHT)% WORLD_HEIGHT;\n      }\n      // opposite case as above\n      if ((abs(delta_x - WORLD_WIDTH)) < abs(delta_x)){\n        delta_x -= WORLD_WIDTH;\n      }\n      if ((abs(delta_y - WORLD_WIDTH)) < abs(delta_y)){\n        delta_y -= WORLD_HEIGHT;\n      }\n\n      // std::cout<<'Angle To neighbor 0-TL(degrees)'<<atan2(1,-1) * 180/M_PI<<std::endl;\n      // std::cout<<'Angle To neighbor 1-T(degrees)'<<atan2(1,0) * 180/M_PI<<std::endl;\n      // std::cout<<'Angle To neighbor 2-TR(degrees)'<<atan2(1,1) * 180/M_PI<<std::endl;\n      // std::cout<<'Angle To neighbor 3-L(degrees)'<<atan2(0,-1) * 180/M_PI<<std::endl;\n      // std::cout<<'Angle To neighbor 4-R(degrees)'<<atan2(0,1) * 180/M_PI<<std::endl;\n      // std::cout<<'Angle To neighbor 5-BL(degrees)'<<atan2(-1,-1) * 180/M_PI<<std::endl;\n      // std::cout<<'Angle To neighbor 6-B(degrees)'<<atan2(-1,0) * 180/M_PI<<std::endl;\n      // std::cout<<'Angle To neighbor 7-BR(degrees)'<<atan2(-1,1) * 180/M_PI<<std::endl;\n\n      double angle_radian = atan2(delta_y, delta_x);\n      while (angle_radian<0){angle_radian+=2*M_PI;}\n\n      return angle_radian *  180/M_PI;\n    }\n"
      },
      "3": {
            "Header_file_name:": "AGENT_H",
            "Header_file_content": "\n// agent.h\n#ifndef AGENT_H\n#define AGENT_H\n\n#include <memory>\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <algorithm>\n#include <random>\n#include 'parameters.h'\n\nclass Agent: public std::enable_shared_from_this<Agent> {\n  protected:\n    Agent(int x, int y) : x(x), y(y) {}\n  private:\n    std::string color = '';\n    std::string secondaryColor = '';\n    std::string shape = '';\n    int size=1;\n    int alpha = 255;\n    int x;\n    int y;\n    bool visible = true;\n  public:\n    virtual double getX() const {return x;};\n    virtual double getY() const {return y;};\n    virtual void setX(int newX){x=newX;};\n    virtual void setY(int newY){y=newY;};\n    void setColor(std::string newColor){color = newColor;};\n    std::string getColor() const {return color;};\n    void setSecondaryColor(std::string newColor){secondaryColor = newColor;};\n    std::string getSecondaryColor() const {return secondaryColor;};\n    void setShape(std::string newShape){shape = newShape;};\n    std::string getShape() const {return shape;};\n    void setOpacity(int newAlpha){alpha = newAlpha;};\n    int getOpacity() const {return alpha;};\n\n    void setSize(int newSize){size = newSize;};\n    int getSize() const {return size;};\n\n    void setVisible(bool status){visible = status;}\n    bool getVisible() const {return visible;}\n\n    std::weak_ptr<Agent> createWeakPtr() {std::cout<<'getting pointer from this in agent' <<std::endl; return shared_from_this();}\n\n\n};\n\n\n#endif"
      },
      "4": {
            "Header_file_name:": "ANTIBODIES_H",
            "Header_file_content": "\n#ifndef ANTIBODIES_H\n#define ANTIBODIES_H\n\n#include 'turtle.h'\n#include <string>\n\nclass Antibodies : public Turtle {\nprivate:\n    // Type of the antibody\n    std::string antibody_type;\n\npublic:\n    // You can add specific methods and properties for this subclass\n    Antibodies(int x, int y, int id, int heading=90);\n\n    // Override Turtle methods if needed\n\n    // Getter for antibody type\n    std::string getAntibodyType() const { return antibody_type; }\n\n    // Setter for antibody type\n    void setAntibodyType(const std::string& antibody_type) { this->antibody_type = antibody_type; }\n};\n\n#endif\n"
      },
      "5": {
            "Header_file_name:": "BACTERIA_H",
            "Header_file_content": "\n#ifndef BACTERIA_H\n#define BACTERIA_H\n\n#include 'turtle.h'\n#include <string>\n\nclass Bacteria : public Turtle {\nprivate:\n    // Type of the epitope\n    int epitope_type;\n    // Number of TI-ep\n    int num_TI_ep;\n    // Number of TD-ep\n    int num_TD_ep;\n\npublic:\n    // You can add specific methods and properties for this subclass\n    Bacteria(int x, int y, int id, int heading=90);\n\n    // Override Turtle methods if needed\n\n    // Getter for epitope type\n    int getEpitopeType() const { return epitope_type; }\n\n    // Setter for epitope type\n    void setEpitopeType(const int epitope_type) { this->epitope_type = epitope_type; }\n\n    // Getter for num_TI_ep\n    int getNumTIep() const { return num_TI_ep; }\n\n    // Setter for num_TI_ep\n    void setNumTIep(int num_TI_ep) { this->num_TI_ep = num_TI_ep; }\n\n    // Getter for num_TD_ep\n    int getNumTDep() const { return num_TD_ep; }\n\n    // Setter for num_TD_ep\n    void setNumTDep(int num_TD_ep) { this->num_TD_ep = num_TD_ep; }\n};\n\n#endif\n"
      },
      "6": {
            "Header_file_name:": "BREG_CELL_H",
            "Header_file_content": "\n#ifndef BREG_CELL_H\n#define BREG_CELL_H\n\n#include 'turtle.h'\n\nclass BregCell : public Turtle {\npublic:\n    // You can add specific methods and properties for this subclass\n    BregCell(int x, int y, int id, int heading=0);\n\n    // Override Turtle methods if needed\n};\n\n#endif\n"
      },
      "7": {
            "Header_file_name:": "FDCS_H",
            "Header_file_content": "\n#ifndef FDCS_H\n#define FDCS_H\n\n#include 'turtle.h'\n#include <string>\n\nclass FDCs : public Turtle {\nprivate:\n    // Presented antigen\n    int presented_antigen;\n    // Time presenting\n    int time_presenting;\n    // Type of presented antigen\n    int presented_antigen_type;\n    // Responsiveness\n    int responsiveness;\n\npublic:\n    // You can add specific methods and properties for this subclass\n    FDCs(int x, int y, int id, int heading=90);\n\n    // Override Turtle methods if needed\n\n    // Getter for presented antigen\n    int getPresentedAntigen() const { return presented_antigen; }\n\n    // Setter for presented antigen\n    void setPresentedAntigen(int new_presented_antigen) { this->presented_antigen = new_presented_antigen; }\n\n    // Getter for time presenting\n    int getTimePresenting() const { return time_presenting; }\n\n    // Setter for time presenting\n    void setTimePresenting(int time_presenting) { this->time_presenting = time_presenting; }\n\n    // Getter for presented antigen type\n    int getPresentedAntigenType() const { return presented_antigen_type; }\n\n    // Setter for presented antigen type\n    void setPresentedAntigenType(int presented_antigen_type) { this->presented_antigen_type = presented_antigen_type; }\n\n    // Getter for responsiveness\n    int getResponsiveness() const { return responsiveness; }\n\n    // Setter for responsiveness\n    void setResponsiveness(int responsiveness) { this->responsiveness = responsiveness; }\n\n    void calculate_responsiveness();\n};\n\n#endif\n"
      },
      "8": {
            "Header_file_name:": "GC_B_CELL_H",
            "Header_file_content": "\n#ifndef GC_B_CELL_H\n#define GC_B_CELL_H\n\n#include 'turtle.h'\n\nclass GCBCell : public Turtle {\npublic:\n    // You can add specific methods and properties for this subclass\n    GCBCell(int x, int y, int id, int heading=90);\n\n    // Override Turtle methods if needed\n};\n\n#endif\n"
      },
      "9": {
            "Header_file_name:": "HELPER_FUNCTIONS_H",
            "Header_file_content": "\n\n#ifndef HELPER_FUNCTIONS_H\n#define HELPER_FUNCTIONS_H\n\n#include <iostream>\n#include <vector>\n#include <cmath>\n\n\ndouble calculateDistance(int x1, int y1, int x2, int y2);\nstd::vector<std::pair<int, int>> generateCoordinates(int number_to_generate, int center_x, int center_y, int radius_from_center, int buffer_zone_between_points);\n\n#endif"
      },
      "10": {
            "Header_file_name:": "LL_PLASMA_CELL_H",
            "Header_file_content": "\n#ifndef LL_PLASMA_CELL_H\n#define LL_PLASMA_CELL_H\n\n#include 'turtle.h'\n\nclass LLPlasmaCell : public Turtle {\npublic:\n    // You can add specific methods and properties for this subclass\n    LLPlasmaCell(int x, int y, int id, int heading=90);\n\n    // Override Turtle methods if needed\n};\n\n#endif\n"
      },
      "11": {
            "Header_file_name:": "MEM_B_CELL_H",
            "Header_file_content": "\n#ifndef MEM_B_CELL_H\n#define MEM_B_CELL_H\n\n#include 'turtle.h'\n\nclass MemBCell : public Turtle {\nprivate:\n    // Time in follicle for memory B cells\n    int time_in_follicle;\n\npublic:\n    // You can add specific methods and properties for this subclass\n    MemBCell(int x, int y, int id, int heading=90);\n\n    // Override Turtle methods if needed\n\n    // Getter for time in follicle\n    int getTimeInFollicle() const { return time_in_follicle; }\n\n    // Setter for time in follicle\n    void setTimeInFollicle(int time_in_follicle) { this->time_in_follicle = time_in_follicle; }\n};\n\n#endif\n"
      },
      "12": {
            "Header_file_name:": "NAIVE_B_CELL_H",
            "Header_file_content": "\n#ifndef NAIVE_B_CELL_H\n#define NAIVE_B_CELL_H\n\n#include 'turtle.h'\n\nclass NaiveBCell : public Turtle {\nprivate:\n\npublic:\n    // You can add specific methods and properties for this subclass\n    NaiveBCell(int x, int y, int id, int heading=90);\n\n    // Override Turtle methods if needed\n};\n\n#endif\n"
      },
      "13": {
            "Header_file_name:": "PARAMETERS_H",
            "Header_file_content": "\n// parameters.h\n#ifndef PARAMETERS_H\n#define PARAMETERS_H\n\nconst bool RENDERING = true;\nconst bool SAVING_DATA = false;\nconst bool TURTLE_CONTINOUS_MOVEMENT = true;\nconst bool TOROIDAL_WORLD = false;\n\nconst int RNG_SEED=108;\nconst int NUM_STEPS = 10000;\n\n\nconst static int WORLD_WIDTH = 101;\nconst static int WORLD_HEIGHT = 101;\nconst int PATCH_MAX_CAPACITY = 10000;\nconst int MAX_RANDOM_DISTANCE = 100;\n\n// this netlgoo implementation specific variables\nconst bool RandomRuns = false;\nconst bool AUTOINOCULATE = true;\nconst int AUTOINOCULATE_FIRST_TIME = 480;\nconst int AUTOINOCULATE_SECOND_TIME = 2880;\nconst int STOP_EXPOSURE_TIME = 4800;\nconst int FIRST_EXPOSURE_AMOUNT = 50;\nconst int SECOND_EXPOSURE_AMOUNT = 50;\nconst int BACTERIA_SIZE = 2;\n\nconst int BACTERIA_EPITOPE_TYPE = 30;\nconst int NUMBER_OF_TI_EPITOPES = 10;\nconst int NUMBER_OF_TD_EPITOPES = 10;\n\nconst int BCELL_CD21_ACTIVATION_THRESHOLD =101;\nconst int BCELL_TNFA_APOP_THRESHOLD = 277;\nconst int BCELL_BREG_DIFF_THRESHOLD = 181;\n\nconst int PHAG_IL6_BURST=0;\n\nconst int BACKGROUND_TNFA = 0;\nconst int BACKGROUND_IL6 = 0;\n\nstatic const int CXCL13_LEVEL_DIFFUSION_FACTOR = 1.0;\nstatic const int S1P_LEVEL_DIFFUSION_FACTOR = 1.0;\nstatic const int CCL19_LEVEL_DIFFUSION_FACTOR = 1.0;\nstatic const int EBI2_LEVEL_DIFFUSION_FACTOR = 1.0;\nstatic const int IL2_DIFFUSION_FACTOR = 1.0;\nstatic const int IL4_DIFFUSION_FACTOR = 1.0;\nstatic const int IL6_DIFFUSION_FACTOR = 1.0;\nstatic const int IL10_DIFFUSION_FACTOR = 1.0;\nstatic const int IL12_DIFFUSION_FACTOR = 1.0;\nstatic const int IL15_DIFFUSION_FACTOR = 1.0;\nstatic const int IL21_DIFFUSION_FACTOR = 1.0;\nstatic const int IF_G_DIFFUSION_FACTOR = 1.0;\nstatic const int IF_A_DIFFUSION_FACTOR = 1.0;\nstatic const int TNF_A_DIFFUSION_FACTOR = 1.0;\nstatic const int TGF_B_DIFFUSION_FACTOR = 1.0;\n\nstatic const double CXCL13_EVAPORATION_FACTOR = 0.9;\nstatic const double S1P_EVAPORATION_FACTOR = 0.9;\nstatic const double CCL19_EVAPORATION_FACTOR = 0.9;\nstatic const double EBI2_EVAPORATION_FACTOR = 0.9;\nstatic const double IL2_EVAPORATION_FACTOR = 0.9;\nstatic const double IL4_EVAPORATION_FACTOR = 0.9;\nstatic const double IL6_EVAPORATION_FACTOR = 0.95;\nstatic const double IL10_EVAPORATION_FACTOR = 0.95;\nstatic const double IL12_EVAPORATION_FACTOR = 0.9;\nstatic const double IL15_EVAPORATION_FACTOR = 0.9;\nstatic const double IL21_EVAPORATION_FACTOR = 0.9;\nstatic const double IF_G_EVAPORATION_FACTOR = 0.9;\nstatic const double IF_A_EVAPORATION_FACTOR = 0.9;\nstatic const double TNF_A_EVAPORATION_FACTOR = 0.9;\nstatic const double TGF_B_EVAPORATION_FACTOR = 0.9;\n\n#endif\n"
      },
      "14": {
            "Header_file_name:": "PATCH_H",
            "Header_file_content": "\n// patch.h\n#ifndef PATCH_H\n#define PATCH_H\n\n#include 'parameters.h'\n#include 'agent.h'\n#include 'turtle.h'\n#include <memory>\n#include <vector>\n\nclass Patch : public Agent{\nprivate:\n    std::vector<std::shared_ptr<Turtle>> turtles_here;\n\n    int patch_type;\n    double s1p_level, cxcl13_level, ccl19_level, ebi2_level;\n    double il2, il4, il6, il10, il12, il15, il21;\n    double if_g, if_a, tnf_a, tgf_b;\n\n    double temp_var; // placeholder for diffusion totals before updating\n    double temp_s1p_level, temp_cxcl13_level, temp_ccl19_level, temp_ebi2_level;\n    double temp_il2, temp_il4, temp_il6, temp_il10, temp_il12, temp_il15, temp_il21;\n    double temp_if_g, temp_if_a, temp_tnf_a, temp_tgf_b;\n\npublic:\n    virtual ~Patch() = default;\n    Patch():Agent(0,0){setColor('red');setModeColor('green');}; // base patch color is red\n    Patch(int xCoord, int yCoord) : Agent(xCoord, yCoord) {setColor('red');setModeColor('green');};\n\n    void setModeColor(std::string newColor){setSecondaryColor(newColor);}\n    std::string getModeColor(){return getSecondaryColor();}\n\n// In order to view a cytokine layer on top of everything,\n// specify what mode to view here by putting a patch variable, otherwise return 0\n    double getModeOpacity(){return il21;}\n\n    void add_turtle(std::shared_ptr<Turtle> turtle_to_add);\n    void remove_turtle(std::shared_ptr<Turtle> turtle_to_remove);\n    const std::vector<std::shared_ptr<Turtle>>& getTurtlesHere() const {return turtles_here;}\n    void display();\n    bool is_at_capacity();\n\n    void setTempVar(double newVal){temp_var=newVal;};\n    double getTempVar() const {return temp_var;};\n\n    void setPatchType(int type) { patch_type = type; }\n    int getPatchType() const { return patch_type; }\n\n    // Getter and setter for each new variable\n    // s1p_level\n    void setS1pLevel(double level) { s1p_level = level; }\n    double getS1pLevel() const { return s1p_level; }\n\n    // cxcl13_level\n    void setCxcl13Level(double level) { cxcl13_level = level; }\n    double getCxcl13Level() const { return cxcl13_level; }\n\n    // ccl19_level\n    void setCcl19Level(double level) { ccl19_level = level; }\n    double getCcl19Level() const { return ccl19_level; }\n\n    // ebi2_level\n    void setEbi2Level(double level) { ebi2_level = level; }\n    double getEbi2Level() const { return ebi2_level; }\n\n    // il2\n    void setIl2(double value) { il2 = value; }\n    double getIl2() const { return il2; }\n\n    // il4\n    void setIl4(double value) { il4 = value; }\n    double getIl4() const { return il4; }\n\n    // il6\n    void setIl6(double value) { il6 = value; }\n    double getIl6() const { return il6; }\n\n    // il10\n    void setIl10(double value) { il10 = value; }\n    double getIl10() const { return il10; }\n\n    // il12\n    void setIl12(double value) { il12 = value; }\n    double getIl12() const { return il12; }\n\n    // il15\n    void setIl15(double value) { il15 = value; }\n    double getIl15() const { return il15; }\n\n    // il21\n    void setIl21(double value) { il21 = value; }\n    double getIl21() const { return il21; }\n\n    // if_g\n    void setIfG(double value) { if_g = value; }\n    double getIfG() const { return if_g; }\n\n    // if_a\n    void setIfA(double value) { if_a = value; }\n    double getIfA() const { return if_a; }\n\n    // tnf_a\n    void setTnfA(double value) { tnf_a = value; }\n    double getTnfA() const { return tnf_a; }\n\n    // tgf_b\n    void setTgfB(double value) { tgf_b = value; }\n    double getTgfB() const { return tgf_b; }\n\n    // Getter and setter functions for temp_s1p_level\n    void setTempS1pLevel(double value) { temp_s1p_level = value; }\n    double getTempS1pLevel() const { return temp_s1p_level; }\n\n    // Getter and setter functions for temp_cxcl13_level\n    void setTempCxcl13Level(double value) { temp_cxcl13_level = value; }\n    double getTempCxcl13Level() const { return temp_cxcl13_level; }\n\n    // Getter and setter functions for temp_ccl19_level\n    void setTempCcl19Level(double value) { temp_ccl19_level = value; }\n    double getTempCcl19Level() const { return temp_ccl19_level; }\n\n    // Getter and setter functions for temp_ebi2_level\n    void setTempEbi2Level(double value) { temp_ebi2_level = value; }\n    double getTempEbi2Level() const { return temp_ebi2_level; }\n\n    // Getter and setter functions for temp_il2\n    void setTempIl2(double value) { temp_il2 = value; }\n    double getTempIl2() const { return temp_il2; }\n\n    // Getter and setter functions for temp_il4\n    void setTempIl4(double value) { temp_il4 = value; }\n    double getTempIl4() const { return temp_il4; }\n\n    // Getter and setter functions for temp_il6\n    void setTempIl6(double value) { temp_il6 = value; }\n    double getTempIl6() const { return temp_il6; }\n\n    // Getter and setter functions for temp_il10\n    void setTempIl10(double value) { temp_il10 = value; }\n    double getTempIl10() const { return temp_il10; }\n\n    // Getter and setter functions for temp_il12\n    void setTempIl12(double value) { temp_il12 = value; }\n    double getTempIl12() const { return temp_il12; }\n\n    // Getter and setter functions for temp_il15\n    void setTempIl15(double value) { temp_il15 = value; }\n    double getTempIl15() const { return temp_il15; }\n\n    // Getter and setter functions for temp_il21\n    void setTempIl21(double value) { temp_il21 = value; }\n    double getTempIl21() const { return temp_il21; }\n\n    // Getter and setter functions for temp_if_g\n    void setTempIfG(double value) { temp_if_g = value; }\n    double getTempIfG() const { return temp_if_g; }\n\n    // Getter and setter functions for temp_if_a\n    void setTempIfA(double value) { temp_if_a = value; }\n    double getTempIfA() const { return temp_if_a; }\n\n    // Getter and setter functions for temp_tnf_a\n    void setTempTnfA(double value) { temp_tnf_a = value; }\n    double getTempTnfA() const { return temp_tnf_a; }\n\n    // Getter and setter functions for temp_tgf_b\n    void setTempTgfB(double value) { temp_tgf_b = value; }\n    double getTempTgfB() const { return temp_tgf_b; }\n\n    // patch is the same iff the x and y positions are equal\n    bool operator== (Patch& that){return (this->getX()==that.getX() && this->getY()==that.getY());};\n\n    // Add more patch specific functions below for the particular implementation of a net logo model being ported\n};\n\n#endif\n"
      },
      "15": {
            "Header_file_name:": "RENDERING_H",
            "Header_file_content": "\n// rendering.h\n#ifndef RENDERING_H\n#define RENDERING_H\n\n//Using SDL and standard IO\n#include <SDL2/SDL.h>\n#include <stdlib.h>\n#include <string>\n#include <stdio.h>\n#include <tuple>\n#include 'world.h'\n\n#include 'parameters.h'\n\nclass RenderingEngine {\nprivate:\n  /* data */\n  SDL_Window* window;\n  SDL_Renderer* renderer;\n  World* myWorld;\n\n\npublic:\n  const static int GRID_SIZE = 10;\n  const static int SCREEN_WIDTH = WORLD_WIDTH * GRID_SIZE;\n  const static int SCREEN_HEIGHT = WORLD_WIDTH * GRID_SIZE;\n  RenderingEngine();\n  RenderingEngine(World *world);\n  ~RenderingEngine ();\n\n  std::tuple<int, int, int> getColor(const std::string& color);\n  void drawCircle(double centerX, double centerY, double radius=GRID_SIZE/2, const std::string& color='red', int alpha=SDL_ALPHA_OPAQUE);\n  void drawSquare(int x, int y, int size=GRID_SIZE, const std::string& color='red', int alpha=SDL_ALPHA_OPAQUE);\n  void drawLine(double startX, double startY, double endX, double endY, const std::string& color='black', int alpha=SDL_ALPHA_OPAQUE);\n  void drawFilledEllipse(int centerX, int centerY, int radiusX, int radiusY, const std::string& color='black', int alpha=SDL_ALPHA_OPAQUE, int angleDegrees=0);\n  void setBackgroundColor(const std::string& color='red');\n  void render();\n\n  void renderAllPatches();\n  void renderAllTurtles();\n  void renderPatchMode();\n};\n\n\n#endif\n"
      },
      "16": {
            "Header_file_name:": "SL_PLASMA_CELL_H",
            "Header_file_content": "\n#ifndef SL_PLASMA_CELL_H\n#define SL_PLASMA_CELL_H\n\n#include 'turtle.h'\n\nclass SLPlasmaCell : public Turtle {\npublic:\n    // You can add specific methods and properties for this subclass\n    SLPlasmaCell(int x, int y, int id, int heading=90);\n\n    // Override Turtle methods if needed\n};\n\n#endif\n"
      },
      "17": {
            "Header_file_name:": "TFH_CELL_H",
            "Header_file_content": "\n#ifndef TFH_CELL_H\n#define TFH_CELL_H\n\n#include 'turtle.h'\n\nclass TfhCell : public Turtle {\nprivate:\n    // Variables specific to TfhCell\n    bool bcell_binding_status; // Assuming it's a boolean status, adjust type as needed\n\npublic:\n    // You can add specific methods and properties for this subclass\n    TfhCell(int x, int y, int id, int heading=90);\n\n    // Override Turtle methods if needed\n\n    // Getter for bcell_binding_status\n    bool getBcellBindingStatus() const { return bcell_binding_status; }\n\n    // Setter for bcell_binding_status\n    void setBcellBindingStatus(bool status) { this->bcell_binding_status = status; }\n};\n\n#endif\n"
      },
      "18": {
            "Header_file_name:": "TH0_CELL_H",
            "Header_file_content": "\n#ifndef TH0_CELL_H\n#define TH0_CELL_H\n\n#include 'turtle.h'\n\nclass Th0Cell : public Turtle {\nprivate:\n    // Variables specific to Th0Cell\n    float r1;\n    float r2;\n    float rf;\n    float th1_activation;\n    float th2_activation;\n    float tfh_activation;\n\npublic:\n    // You can add specific methods and properties for this subclass\n    Th0Cell(int x, int y, int id, int heading=90);\n\n    // Override Turtle methods if needed\n\n    // Getter for r1\n    float getR1() const { return r1; }\n\n    // Setter for r1\n    void setR1(float r1) { this->r1 = r1; }\n\n    // Getter for r2\n    float getR2() const { return r2; }\n\n    // Setter for r2\n    void setR2(float r2) { this->r2 = r2; }\n\n    // Getter for rf\n    float getRf() const { return rf; }\n\n    // Setter for rf\n    void setRf(float rf) { this->rf = rf; }\n\n    // Getter for th1_activation\n    float getTh1Activation() const { return th1_activation; }\n\n    // Setter for th1_activation\n    void setTh1Activation(float th1_activation) { this->th1_activation = th1_activation; }\n\n    // Getter for th2_activation\n    float getTh2Activation() const { return th2_activation; }\n\n    // Setter for th2_activation\n    void setTh2Activation(float th2_activation) { this->th2_activation = th2_activation; }\n\n    // Getter for tfh_activation\n    float getTfhActivation() const { return tfh_activation; }\n\n    // Setter for tfh_activation\n    void setTfhActivation(float tfh_activation) { this->tfh_activation = tfh_activation; }\n};\n\n#endif\n"
      },
      "19": {
            "Header_file_name:": "TH1_CELL_H",
            "Header_file_content": "\n#ifndef TH1_CELL_H\n#define TH1_CELL_H\n\n#include 'turtle.h'\n\nclass Th1Cell : public Turtle {\nprivate:\n    // Variables specific to Th1Cell\n    bool bcell_binding_status; // Assuming it's a boolean status, adjust type as needed\n\npublic:\n    // You can add specific methods and properties for this subclass\n    Th1Cell(int x, int y, int id, int heading=0);\n\n    // Override Turtle methods if needed\n\n    // Getter for bcell_binding_status\n    bool getBcellBindingStatus() const { return bcell_binding_status; }\n\n    // Setter for bcell_binding_status\n    void setBcellBindingStatus(bool status) { this->bcell_binding_status = status; }\n};\n\n#endif\n"
      },
      "20": {
            "Header_file_name:": "TH2_CELL_H",
            "Header_file_content": "\n#ifndef TH2_CELL_H\n#define TH2_CELL_H\n\n#include 'turtle.h'\n\nclass Th2Cell : public Turtle {\nprivate:\n    // Variables specific to Th2Cell\n    bool bcell_binding_status; // Assuming it's a boolean status, adjust type as needed\n\npublic:\n    // You can add specific methods and properties for this subclass\n    Th2Cell(int x, int y, int id, int heading=0);\n\n    // Override Turtle methods if needed\n\n    // Getter for bcell_binding_status\n    bool getBcellBindingStatus() const { return bcell_binding_status; }\n\n    // Setter for bcell_binding_status\n    void setBcellBindingStatus(bool status) { this->bcell_binding_status = status; }\n};\n\n#endif\n"
      },
      "21": {
            "Header_file_name:": "TURTLE_H",
            "Header_file_content": "\n// turtle.h\n#ifndef TURTLE_H\n#define TURTLE_H\n\n#include 'agent.h'\n\n\nclass Turtle : public Agent{\n  public :\n    Turtle(int x, int y, int ID_num, int heading=90) : Agent(x, y), ID_num(ID_num), heading(heading) {x_dec=x; y_dec=y;};\n    virtual ~Turtle() = default;\n\n  private:\n    std::vector<std::weak_ptr<Turtle>> linkedTurtles;\n\n\n    int type =0;  //agent type, will be used for the get-one-of functions\n    int ID_num;\n    int heading;\n    // int age;\n    int time_alive;\n    bool is_alive=true;\n    float x_dec; //x and y decimal coordinates\n    float y_dec;\n    float temp_x; // temporary coords for turtle move, before actual turtle coords are moved in case destination patch is full.\n    float temp_y; // Turtle cant know about the world cause circular dependency in #include, so world will handle turtle movement between patches\n\n    // added turtles-own variables\n    bool in_blood;\n    int bcr;\n    std::string isotype;\n    bool csr_bool;\n    float tnfa_threshold;\n    float breg_threshold;\n    float cd21_level;\n    float s1pr1_level;\n    float s1pr2_level;\n    float cxcr5_level;\n    float ccr7_level;\n    float ebi2r_level;\n    bool pro_breg;\n    int level_of_activation;\n    float tnf_a_stimulation;\n    int exposure_number;\n\n    // add more variables that apply to all turtles here for the specific NetLogo model being ported\n\n  public:\n    std::pair<double,double> move(float distance=1);\n    std::pair<int,int> jumpRandom(std::mt19937 &RNG_Engine);\n    void execute_move(bool didMove);\n    void wiggle(std::mt19937 &RNG_Engine);\n    void display();\n    void copy_other_turtle_attributes(std::shared_ptr<Turtle> otherTurtle); // meant to be used when netlogo sets breed, cause this will copy values from original cell to new cell\n\n    int getID() const {return ID_num;};\n    int getType() const {return type;};\n\n    void setHeading(int newHeading){heading = newHeading;};\n    int getHeading() const {return heading;};\n\n    float get_x_dec() const {return x_dec;}       // already has regular getX() and getY() from agent parent class\n    float get_y_dec() const {return y_dec;}\n    void set_x_dec(double new_x_dec) {x_dec = new_x_dec;}\n    void set_y_dec(double new_y_dec) {y_dec = new_y_dec;}\n\n    float get_temp_x() const {return temp_x;}\n    float get_temp_y() const {return temp_y;}\n    void set_temp_x(double new_temp_x) {temp_x = new_temp_x;}\n    void set_temp_y(double new_temp_y) {temp_y = new_temp_y;}\n\n\n    void addLinkedTurtle(std::weak_ptr<Turtle> linkedTurtle);\n    void removeLinkedTurtle();\n    std::vector<std::weak_ptr<Turtle>>& getLinkedTurtles();\n\n\n\n\n    // Add setter and getter for new variables here\n    void set_is_alive(bool new_is_alive) { is_alive = new_is_alive; }\n    bool get_is_alive() const { return is_alive; }\n    // in_blood\n    void setInBlood(bool inBlood) { in_blood = inBlood; }\n    bool getInBlood() const { return in_blood; }\n\n    // bcr\n    void setBcr(int bcrValue) { bcr = bcrValue; }\n    int getBcr() const { return bcr; }\n\n    // isotype\n    void setIsotype(const std::string& isotypeValue) { isotype = isotypeValue; }\n    std::string getIsotype() const { return isotype; }\n\n    // csr_bool\n    void setCsrBool(bool csrBool) { csr_bool = csrBool; }\n    bool getCsrBool() const { return csr_bool; }\n\n    // time_alive\n    void setTimeAlive(int timeAlive) { time_alive = timeAlive; }\n    int getTimeAlive() const { return time_alive; }\n\n    // tnfa_threshold\n    void setTnfaThreshold(float threshold) { tnfa_threshold = threshold; }\n    float getTnfaThreshold() const { return tnfa_threshold; }\n\n    // breg_threshold\n    void setBregThreshold(float threshold) { breg_threshold = threshold; }\n    float getBregThreshold() const { return breg_threshold; }\n\n    // cd21_level\n    void setCd21Level(float level) { cd21_level = level; }\n    float getCd21Level() const { return cd21_level; }\n\n    // s1pr1_level\n    void setS1pr1Level(float level) { s1pr1_level = level; }\n    float getS1pr1Level() const { return s1pr1_level; }\n\n    // s1pr2_level\n    void setS1pr2Level(float level) { s1pr2_level = level; }\n    float getS1pr2Level() const { return s1pr2_level; }\n\n    // cxcr5_level\n    void setCxcr5Level(float level) { cxcr5_level = level; }\n    float getCxcr5Level() const { return cxcr5_level; }\n\n    // ccr7_level\n    void setCcr7Level(float level) { ccr7_level = level; }\n    float getCcr7Level() const { return ccr7_level; }\n\n    // ebi2r_level\n    void setEbi2rLevel(float level) { ebi2r_level = level; }\n    float getEbi2rLevel() const { return ebi2r_level; }\n\n    // pro_breg\n    void setProBreg(bool proBreg) { pro_breg = proBreg; }\n    bool getProBreg() const { return pro_breg; }\n\n    // level_of_activation\n    void setLevelOfActivation(int level) { level_of_activation = level; }\n    int getLevelOfActivation() const { return level_of_activation; }\n\n    // tnf_a_stimulation\n    void setTnfaStimulation(float stimulation) { tnf_a_stimulation = stimulation; }\n    float getTnfaStimulation() const { return tnf_a_stimulation; }\n\n    // exposure_number\n    void setExposureNumber(int exposureNumber) { exposure_number = exposureNumber; }\n    int getExposureNumber() const { return exposure_number; }\n\n    std::weak_ptr<Turtle> createWeakTurtlePtr() {\n      std::weak_ptr<Turtle> test = std::dynamic_pointer_cast<Turtle>(createWeakPtr().lock());\n      std::cout<<'greated weak turtle pointer in turtle function'<<std::endl;\n       return test;\n     }\n\n    bool operator== (const Turtle& turt2){return this->ID_num==turt2.ID_num;};\n    bool operator== (const Turtle* turt2){return this->ID_num==turt2->ID_num;};\n    bool operator== (const std::weak_ptr<Turtle> turt2){return this->ID_num==turt2.lock()->ID_num;};\n\n    // add more turtle specific functions below. These are functions that will apply to all turtle types, not a single breed\n\n};\n\n\n#endif"
      }
}